From b50c5c5317b7f4c0d3de28658b675eb18ca944f9 Mon Sep 17 00:00:00 2001
From: Michal Srb <msrb@redhat.com>
Date: Wed, 13 Jan 2016 17:46:37 +0100
Subject: [PATCH] Workaround modello weirdness

The code generated by modello doesn't compile from some weird reason.
Use these pregenerated files for now.

[ERROR] /builddir/build/BUILD/apache-maven-3.3.9/maven-model/target/generated-sources/modello/org/apache/maven/model/Scm.java:[158,38] incompatible types
  required: org.apache.maven.model.InputLocation
  found:    java.lang.Object
---
 maven-compat/pom.xml                               |   26 +-
 .../org/apache/maven/profiles/Activation.java      |  178 +
 .../org/apache/maven/profiles/ActivationFile.java  |   89 +
 .../org/apache/maven/profiles/ActivationOS.java    |  136 +
 .../apache/maven/profiles/ActivationProperty.java  |   87 +
 .../modello/org/apache/maven/profiles/Profile.java |  233 ++
 .../org/apache/maven/profiles/ProfilesRoot.java    |  155 +
 .../org/apache/maven/profiles/Repository.java      |   91 +
 .../org/apache/maven/profiles/RepositoryBase.java  |  157 +
 .../apache/maven/profiles/RepositoryPolicy.java    |  119 +
 .../maven/profiles/io/xpp3/ProfilesXpp3Reader.java | 1199 ++++++
 .../maven/profiles/io/xpp3/ProfilesXpp3Writer.java |  389 ++
 .../apache/maven/usability/plugin/Expression.java  |  273 ++
 .../usability/plugin/ExpressionDocumentation.java  |  133 +
 .../plugin/io/xpp3/ParamdocXpp3Reader.java         |  832 ++++
 .../plugin/io/xpp3/ParamdocXpp3Writer.java         |  176 +
 maven-core/pom.xml                                 |   24 +-
 .../maven/toolchain/model/PersistedToolchains.java |  137 +
 .../maven/toolchain/model/ToolchainModel.java      |  262 ++
 .../maven/toolchain/model/TrackableBase.java       |   77 +
 .../model/io/xpp3/MavenToolchainsXpp3Reader.java   |  798 ++++
 .../model/io/xpp3/MavenToolchainsXpp3Writer.java   |  158 +
 maven-embedder/pom.xml                             |   25 +-
 .../internal/extension/model/CoreExtension.java    |  102 +
 .../internal/extension/model/CoreExtensions.java   |  102 +
 .../model/io/xpp3/CoreExtensionsXpp3Reader.java    |  756 ++++
 .../model/io/xpp3/CoreExtensionsXpp3Writer.java    |  134 +
 maven-model/pom.xml                                |   43 +-
 .../modello/org/apache/maven/model/Activation.java |  283 ++
 .../org/apache/maven/model/ActivationFile.java     |  152 +
 .../org/apache/maven/model/ActivationOS.java       |  223 +
 .../org/apache/maven/model/ActivationProperty.java |  145 +
 .../modello/org/apache/maven/model/Build.java      |  324 ++
 .../modello/org/apache/maven/model/BuildBase.java  |  353 ++
 .../org/apache/maven/model/CiManagement.java       |  217 +
 .../apache/maven/model/ConfigurationContainer.java |  259 ++
 .../org/apache/maven/model/Contributor.java        |  374 ++
 .../modello/org/apache/maven/model/Dependency.java |  615 +++
 .../apache/maven/model/DependencyManagement.java   |  151 +
 .../apache/maven/model/DeploymentRepository.java   |   84 +
 .../modello/org/apache/maven/model/Developer.java  |   73 +
 .../apache/maven/model/DistributionManagement.java |  348 ++
 .../modello/org/apache/maven/model/Exclusion.java  |  142 +
 .../modello/org/apache/maven/model/Extension.java  |  213 +
 .../modello/org/apache/maven/model/FileSet.java    |   90 +
 .../org/apache/maven/model/InputLocation.java      |  283 ++
 .../apache/maven/model/InputLocationTracker.java   |   40 +
 .../org/apache/maven/model/InputSource.java        |  118 +
 .../org/apache/maven/model/IssueManagement.java    |  138 +
 .../modello/org/apache/maven/model/License.java    |  223 +
 .../org/apache/maven/model/MailingList.java        |  341 ++
 .../modello/org/apache/maven/model/Model.java      | 1035 +++++
 .../modello/org/apache/maven/model/ModelBase.java  |  576 +++
 .../modello/org/apache/maven/model/Notifier.java   |  291 ++
 .../org/apache/maven/model/Organization.java       |  136 +
 .../modello/org/apache/maven/model/Parent.java     |  285 ++
 .../modello/org/apache/maven/model/PatternSet.java |  230 +
 .../modello/org/apache/maven/model/Plugin.java     |  462 ++
 .../apache/maven/model/PluginConfiguration.java    |   96 +
 .../org/apache/maven/model/PluginContainer.java    |  180 +
 .../org/apache/maven/model/PluginExecution.java    |  236 ++
 .../org/apache/maven/model/PluginManagement.java   |   45 +
 .../org/apache/maven/model/Prerequisites.java      |  141 +
 .../modello/org/apache/maven/model/Profile.java    |  180 +
 .../modello/org/apache/maven/model/Relocation.java |  191 +
 .../org/apache/maven/model/ReportPlugin.java       |  245 ++
 .../modello/org/apache/maven/model/ReportSet.java  |  147 +
 .../modello/org/apache/maven/model/Reporting.java  |  275 ++
 .../modello/org/apache/maven/model/Repository.java |  114 +
 .../org/apache/maven/model/RepositoryBase.java     |  286 ++
 .../org/apache/maven/model/RepositoryPolicy.java   |  245 ++
 .../modello/org/apache/maven/model/Resource.java   |  255 ++
 .../modello/org/apache/maven/model/Scm.java        |  264 ++
 .../modello/org/apache/maven/model/Site.java       |  187 +
 .../maven/model/io/xpp3/MavenXpp3Reader.java       | 3876 +++++++++++++++++
 .../maven/model/io/xpp3/MavenXpp3ReaderEx.java     | 4419 ++++++++++++++++++++
 .../maven/model/io/xpp3/MavenXpp3Writer.java       | 2003 +++++++++
 maven-plugin-api/pom.xml                           |   23 +-
 .../apache/maven/plugin/lifecycle/Execution.java   |  102 +
 .../apache/maven/plugin/lifecycle/Lifecycle.java   |  107 +
 .../plugin/lifecycle/LifecycleConfiguration.java   |  102 +
 .../org/apache/maven/plugin/lifecycle/Phase.java   |  127 +
 .../io/xpp3/LifecycleMappingsXpp3Reader.java       |  888 ++++
 .../io/xpp3/LifecycleMappingsXpp3Writer.java       |  201 +
 maven-repository-metadata/pom.xml                  |   25 +-
 .../artifact/repository/metadata/Metadata.java     |  386 ++
 .../maven/artifact/repository/metadata/Plugin.java |  125 +
 .../artifact/repository/metadata/Snapshot.java     |  125 +
 .../repository/metadata/SnapshotVersion.java       |  154 +
 .../artifact/repository/metadata/Versioning.java   |  293 ++
 .../metadata/io/xpp3/MetadataXpp3Reader.java       |  978 +++++
 .../metadata/io/xpp3/MetadataXpp3Writer.java       |  265 ++
 maven-settings/pom.xml                             |   25 +-
 .../org/apache/maven/settings/Activation.java      |  226 +
 .../org/apache/maven/settings/ActivationFile.java  |  119 +
 .../org/apache/maven/settings/ActivationOS.java    |  170 +
 .../apache/maven/settings/ActivationProperty.java  |  115 +
 .../apache/maven/settings/IdentifiableBase.java    |   78 +
 .../modello/org/apache/maven/settings/Mirror.java  |  210 +
 .../modello/org/apache/maven/settings/Profile.java |  267 ++
 .../modello/org/apache/maven/settings/Proxy.java   |  256 ++
 .../org/apache/maven/settings/Repository.java      |  133 +
 .../org/apache/maven/settings/RepositoryBase.java  |  193 +
 .../apache/maven/settings/RepositoryPolicy.java    |  153 +
 .../modello/org/apache/maven/settings/Server.java  |  267 ++
 .../org/apache/maven/settings/Settings.java        |  683 +++
 .../org/apache/maven/settings/TrackableBase.java   |   77 +
 .../maven/settings/io/xpp3/SettingsXpp3Reader.java | 1568 +++++++
 .../maven/settings/io/xpp3/SettingsXpp3Writer.java |  618 +++
 109 files changed, 37445 insertions(+), 94 deletions(-)
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Activation.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationFile.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationOS.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationProperty.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Profile.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ProfilesRoot.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Repository.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryBase.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryPolicy.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/Expression.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/ExpressionDocumentation.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java
 create mode 100644 maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java
 create mode 100644 maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/PersistedToolchains.java
 create mode 100644 maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/ToolchainModel.java
 create mode 100644 maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/TrackableBase.java
 create mode 100644 maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java
 create mode 100644 maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Writer.java
 create mode 100644 maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtension.java
 create mode 100644 maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtensions.java
 create mode 100644 maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Reader.java
 create mode 100644 maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Writer.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Activation.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationFile.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationOS.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationProperty.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Build.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/BuildBase.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/CiManagement.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ConfigurationContainer.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Contributor.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Dependency.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/DependencyManagement.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/DeploymentRepository.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Developer.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/DistributionManagement.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Exclusion.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Extension.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/FileSet.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocation.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocationTracker.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/InputSource.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/IssueManagement.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/License.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/MailingList.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Model.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ModelBase.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Notifier.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Organization.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Parent.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/PatternSet.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Plugin.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/PluginConfiguration.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/PluginContainer.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/PluginExecution.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/PluginManagement.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Prerequisites.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Profile.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Relocation.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ReportPlugin.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/ReportSet.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Reporting.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Repository.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryBase.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryPolicy.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Resource.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Scm.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/Site.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Reader.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java
 create mode 100644 maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Writer.java
 create mode 100644 maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Execution.java
 create mode 100644 maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Lifecycle.java
 create mode 100644 maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java
 create mode 100644 maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Phase.java
 create mode 100644 maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java
 create mode 100644 maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Metadata.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Plugin.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Snapshot.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/SnapshotVersion.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Versioning.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java
 create mode 100644 maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Activation.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationFile.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationOS.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationProperty.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/IdentifiableBase.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Mirror.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Profile.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Proxy.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Repository.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryBase.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryPolicy.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Server.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/Settings.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/TrackableBase.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java
 create mode 100644 maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java

diff --git a/maven-compat/pom.xml b/maven-compat/pom.xml
index 231fb92..24c2c79 100644
--- a/maven-compat/pom.xml
+++ b/maven-compat/pom.xml
@@ -94,15 +94,23 @@
         <artifactId>plexus-component-metadata</artifactId>
       </plugin>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <version>1.0.0</version>
-          <models>
-            <model>src/main/mdo/profiles.mdo</model>
-            <model>src/main/mdo/paramdoc.mdo</model>
-          </models>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
+        <executions>
+          <execution>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
+            <goals>
+              <goal>add-source</goal>
+            </goals>
+            <configuration>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Activation.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Activation.java
new file mode 100644
index 0000000..877962e
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Activation.java
@@ -0,0 +1,178 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *         The conditions within the build runtime environment
+ * which will trigger
+ *         the automatic inclusion of the parent build profile.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Activation
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Flag specifying whether this profile is active as a default.
+     */
+    private boolean activeByDefault = false;
+
+    /**
+     * 
+     *             Specifies that this profile will be activated
+     * when a matching JDK is detected.
+     *           
+     */
+    private String jdk;
+
+    /**
+     * 
+     *             Specifies that this profile will be activated
+     * when matching OS attributes are detected.
+     *           
+     */
+    private ActivationOS os;
+
+    /**
+     * 
+     *             Specifies that this profile will be activated
+     * when this System property is specified.
+     *           
+     */
+    private ActivationProperty property;
+
+    /**
+     * 
+     *              Specifies that this profile will be activated
+     * based on existence of a file.
+     *              
+     */
+    private ActivationFile file;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get specifies that this profile will be activated based on
+     * existence of a file.
+     * 
+     * @return ActivationFile
+     */
+    public ActivationFile getFile()
+    {
+        return this.file;
+    } //-- ActivationFile getFile()
+
+    /**
+     * Get specifies that this profile will be activated when a
+     * matching JDK is detected.
+     * 
+     * @return String
+     */
+    public String getJdk()
+    {
+        return this.jdk;
+    } //-- String getJdk()
+
+    /**
+     * Get specifies that this profile will be activated when
+     * matching OS attributes are detected.
+     * 
+     * @return ActivationOS
+     */
+    public ActivationOS getOs()
+    {
+        return this.os;
+    } //-- ActivationOS getOs()
+
+    /**
+     * Get specifies that this profile will be activated when this
+     * System property is specified.
+     * 
+     * @return ActivationProperty
+     */
+    public ActivationProperty getProperty()
+    {
+        return this.property;
+    } //-- ActivationProperty getProperty()
+
+    /**
+     * Get flag specifying whether this profile is active as a
+     * default.
+     * 
+     * @return boolean
+     */
+    public boolean isActiveByDefault()
+    {
+        return this.activeByDefault;
+    } //-- boolean isActiveByDefault()
+
+    /**
+     * Set flag specifying whether this profile is active as a
+     * default.
+     * 
+     * @param activeByDefault
+     */
+    public void setActiveByDefault( boolean activeByDefault )
+    {
+        this.activeByDefault = activeByDefault;
+    } //-- void setActiveByDefault( boolean )
+
+    /**
+     * Set specifies that this profile will be activated based on
+     * existence of a file.
+     * 
+     * @param file
+     */
+    public void setFile( ActivationFile file )
+    {
+        this.file = file;
+    } //-- void setFile( ActivationFile )
+
+    /**
+     * Set specifies that this profile will be activated when a
+     * matching JDK is detected.
+     * 
+     * @param jdk
+     */
+    public void setJdk( String jdk )
+    {
+        this.jdk = jdk;
+    } //-- void setJdk( String )
+
+    /**
+     * Set specifies that this profile will be activated when
+     * matching OS attributes are detected.
+     * 
+     * @param os
+     */
+    public void setOs( ActivationOS os )
+    {
+        this.os = os;
+    } //-- void setOs( ActivationOS )
+
+    /**
+     * Set specifies that this profile will be activated when this
+     * System property is specified.
+     * 
+     * @param property
+     */
+    public void setProperty( ActivationProperty property )
+    {
+        this.property = property;
+    } //-- void setProperty( ActivationProperty )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationFile.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationFile.java
new file mode 100644
index 0000000..8393b14
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationFile.java
@@ -0,0 +1,89 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *         This is the file specification used to activate a
+ * profile. The missing value will be a the location
+ *         of a file that needs to exist, and if it doesn't the
+ * profile must run.  On the other hand exists will test
+ *         for the existence of the file and if it is there will
+ * run the profile.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationFile
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name of the file that should be missing to activate a
+     * profile.
+     */
+    private String missing;
+
+    /**
+     * The name of the file that should exist to activate a profile.
+     */
+    private String exists;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get the name of the file that should exist to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getExists()
+    {
+        return this.exists;
+    } //-- String getExists()
+
+    /**
+     * Get the name of the file that should be missing to activate
+     * a profile.
+     * 
+     * @return String
+     */
+    public String getMissing()
+    {
+        return this.missing;
+    } //-- String getMissing()
+
+    /**
+     * Set the name of the file that should exist to activate a
+     * profile.
+     * 
+     * @param exists
+     */
+    public void setExists( String exists )
+    {
+        this.exists = exists;
+    } //-- void setExists( String )
+
+    /**
+     * Set the name of the file that should be missing to activate
+     * a profile.
+     * 
+     * @param missing
+     */
+    public void setMissing( String missing )
+    {
+        this.missing = missing;
+    } //-- void setMissing( String )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationOS.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationOS.java
new file mode 100644
index 0000000..c9b0c64
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationOS.java
@@ -0,0 +1,136 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *         This is an activator which will detect an operating
+ * system's attributes in order to activate
+ *         its profile.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationOS
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name of the OS to be used to activate a profile.
+     */
+    private String name;
+
+    /**
+     * The general family of the OS to be used to activate a
+     * profile (e.g. 'windows').
+     */
+    private String family;
+
+    /**
+     * The architecture of the OS to be used to activate a profile.
+     */
+    private String arch;
+
+    /**
+     * The version of the OS to be used to activate a profile.
+     */
+    private String version;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get the architecture of the OS to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getArch()
+    {
+        return this.arch;
+    } //-- String getArch()
+
+    /**
+     * Get the general family of the OS to be used to activate a
+     * profile (e.g. 'windows').
+     * 
+     * @return String
+     */
+    public String getFamily()
+    {
+        return this.family;
+    } //-- String getFamily()
+
+    /**
+     * Get the name of the OS to be used to activate a profile.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the version of the OS to be used to activate a profile.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the architecture of the OS to be used to activate a
+     * profile.
+     * 
+     * @param arch
+     */
+    public void setArch( String arch )
+    {
+        this.arch = arch;
+    } //-- void setArch( String )
+
+    /**
+     * Set the general family of the OS to be used to activate a
+     * profile (e.g. 'windows').
+     * 
+     * @param family
+     */
+    public void setFamily( String family )
+    {
+        this.family = family;
+    } //-- void setFamily( String )
+
+    /**
+     * Set the name of the OS to be used to activate a profile.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the version of the OS to be used to activate a profile.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationProperty.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationProperty.java
new file mode 100644
index 0000000..5696c54
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ActivationProperty.java
@@ -0,0 +1,87 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *         This is the property specification used to activate a
+ * profile. If the value field is empty,
+ *         then the existence of the named property will activate
+ * the profile, otherwise it does a case-sensitive
+ *         match against the property value as well.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationProperty
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name of the property to be used to activate a profile.
+     */
+    private String name;
+
+    /**
+     * The value of the property to be used to activate a profile.
+     */
+    private String value;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get the name of the property to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the value of the property to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getValue()
+    {
+        return this.value;
+    } //-- String getValue()
+
+    /**
+     * Set the name of the property to be used to activate a
+     * profile.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the value of the property to be used to activate a
+     * profile.
+     * 
+     * @param value
+     */
+    public void setValue( String value )
+    {
+        this.value = value;
+    } //-- void setValue( String )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Profile.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Profile.java
new file mode 100644
index 0000000..6761dce
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Profile.java
@@ -0,0 +1,233 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *         Modifications to the build process which is keyed on
+ * some
+ *         sort of environmental parameter.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Profile
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The ID of this build profile, for activation
+     *             purposes.
+     */
+    private String id;
+
+    /**
+     * The conditional logic which will automatically
+     *             trigger the inclusion of this profile.
+     */
+    private Activation activation;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Field repositories.
+     */
+    private java.util.List<Repository> repositories;
+
+    /**
+     *  This may be removed or relocated in the near
+     *             future. It is undecided whether plugins really
+     * need a remote
+     *             repository set of their own. 
+     */
+    private java.util.List<Repository> pluginRepositories;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addPluginRepository.
+     * 
+     * @param repository
+     */
+    public void addPluginRepository( Repository repository )
+    {
+        getPluginRepositories().add( repository );
+    } //-- void addPluginRepository( Repository )
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addRepository.
+     * 
+     * @param repository
+     */
+    public void addRepository( Repository repository )
+    {
+        getRepositories().add( repository );
+    } //-- void addRepository( Repository )
+
+    /**
+     * Get the conditional logic which will automatically
+     *             trigger the inclusion of this profile.
+     * 
+     * @return Activation
+     */
+    public Activation getActivation()
+    {
+        return this.activation;
+    } //-- Activation getActivation()
+
+    /**
+     * Get the ID of this build profile, for activation
+     *             purposes.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Method getPluginRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getPluginRepositories()
+    {
+        if ( this.pluginRepositories == null )
+        {
+            this.pluginRepositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.pluginRepositories;
+    } //-- java.util.List<Repository> getPluginRepositories()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Method getRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getRepositories()
+    {
+        if ( this.repositories == null )
+        {
+            this.repositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.repositories;
+    } //-- java.util.List<Repository> getRepositories()
+
+    /**
+     * Method removePluginRepository.
+     * 
+     * @param repository
+     */
+    public void removePluginRepository( Repository repository )
+    {
+        getPluginRepositories().remove( repository );
+    } //-- void removePluginRepository( Repository )
+
+    /**
+     * Method removeRepository.
+     * 
+     * @param repository
+     */
+    public void removeRepository( Repository repository )
+    {
+        getRepositories().remove( repository );
+    } //-- void removeRepository( Repository )
+
+    /**
+     * Set the conditional logic which will automatically
+     *             trigger the inclusion of this profile.
+     * 
+     * @param activation
+     */
+    public void setActivation( Activation activation )
+    {
+        this.activation = activation;
+    } //-- void setActivation( Activation )
+
+    /**
+     * Set the ID of this build profile, for activation
+     *             purposes.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the lists of the remote repositories for discovering
+     * plugins.
+     * 
+     * @param pluginRepositories
+     */
+    public void setPluginRepositories( java.util.List<Repository> pluginRepositories )
+    {
+        this.pluginRepositories = pluginRepositories;
+    } //-- void setPluginRepositories( java.util.List )
+
+    /**
+     * Set extended configuration specific to this profile goes
+     *             here.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set the lists of the remote repositories.
+     * 
+     * @param repositories
+     */
+    public void setRepositories( java.util.List<Repository> repositories )
+    {
+        this.repositories = repositories;
+    } //-- void setRepositories( java.util.List )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ProfilesRoot.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ProfilesRoot.java
new file mode 100644
index 0000000..52d73a0
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/ProfilesRoot.java
@@ -0,0 +1,155 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * Root element of the profiles.xml file.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ProfilesRoot
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field profiles.
+     */
+    private java.util.List<Profile> profiles;
+
+    /**
+     * Field activeProfiles.
+     */
+    private java.util.List<String> activeProfiles;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addActiveProfile.
+     * 
+     * @param string
+     */
+    public void addActiveProfile( String string )
+    {
+        getActiveProfiles().add( string );
+    } //-- void addActiveProfile( String )
+
+    /**
+     * Method addProfile.
+     * 
+     * @param profile
+     */
+    public void addProfile( Profile profile )
+    {
+        getProfiles().add( profile );
+    } //-- void addProfile( Profile )
+
+    /**
+     * Method getActiveProfiles.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getActiveProfiles()
+    {
+        if ( this.activeProfiles == null )
+        {
+            this.activeProfiles = new java.util.ArrayList<String>();
+        }
+
+        return this.activeProfiles;
+    } //-- java.util.List<String> getActiveProfiles()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method getProfiles.
+     * 
+     * @return List
+     */
+    public java.util.List<Profile> getProfiles()
+    {
+        if ( this.profiles == null )
+        {
+            this.profiles = new java.util.ArrayList<Profile>();
+        }
+
+        return this.profiles;
+    } //-- java.util.List<Profile> getProfiles()
+
+    /**
+     * Method removeActiveProfile.
+     * 
+     * @param string
+     */
+    public void removeActiveProfile( String string )
+    {
+        getActiveProfiles().remove( string );
+    } //-- void removeActiveProfile( String )
+
+    /**
+     * Method removeProfile.
+     * 
+     * @param profile
+     */
+    public void removeProfile( Profile profile )
+    {
+        getProfiles().remove( profile );
+    } //-- void removeProfile( Profile )
+
+    /**
+     * Set list of manually-activated build profiles, specified in
+     * the order in which
+     *             they should be applied.
+     * 
+     * @param activeProfiles
+     */
+    public void setActiveProfiles( java.util.List<String> activeProfiles )
+    {
+        this.activeProfiles = activeProfiles;
+    } //-- void setActiveProfiles( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set configuration of build profiles for adjusting the build
+     *             according to environmental parameters.
+     * 
+     * @param profiles
+     */
+    public void setProfiles( java.util.List<Profile> profiles )
+    {
+        this.profiles = profiles;
+    } //-- void setProfiles( java.util.List )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Repository.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Repository.java
new file mode 100644
index 0000000..e2a1938
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/Repository.java
@@ -0,0 +1,91 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *         Repository contains the information needed for
+ * establishing connections with remote repoistory
+ *       .
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Repository
+    extends RepositoryBase
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * How to handle downloading of releases from this repository.
+     */
+    private RepositoryPolicy releases;
+
+    /**
+     * How to handle downloading of snapshots from this repository.
+     */
+    private RepositoryPolicy snapshots;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get how to handle downloading of releases from this
+     * repository.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy getReleases()
+    {
+        return this.releases;
+    } //-- RepositoryPolicy getReleases()
+
+    /**
+     * Get how to handle downloading of snapshots from this
+     * repository.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy getSnapshots()
+    {
+        return this.snapshots;
+    } //-- RepositoryPolicy getSnapshots()
+
+    /**
+     * Set how to handle downloading of releases from this
+     * repository.
+     * 
+     * @param releases
+     */
+    public void setReleases( RepositoryPolicy releases )
+    {
+        this.releases = releases;
+    } //-- void setReleases( RepositoryPolicy )
+
+    /**
+     * Set how to handle downloading of snapshots from this
+     * repository.
+     * 
+     * @param snapshots
+     */
+    public void setSnapshots( RepositoryPolicy snapshots )
+    {
+        this.snapshots = snapshots;
+    } //-- void setSnapshots( RepositoryPolicy )
+
+    
+            public boolean equals( Object obj )
+            {
+                return super.equals( obj );
+            }
+          
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryBase.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryBase.java
new file mode 100644
index 0000000..2b1074b
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryBase.java
@@ -0,0 +1,157 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * 
+ *          Repository contains the information needed
+ *          for establishing connections with remote repoistory
+ *       .
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class RepositoryBase
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             A unique identifier for a repository.
+     *           
+     */
+    private String id;
+
+    /**
+     * 
+     *             Human readable name of the repository
+     *           .
+     */
+    private String name;
+
+    /**
+     * 
+     *              The url of the repository
+     *           .
+     */
+    private String url;
+
+    /**
+     * The type of layout this repository uses for locating and
+     * storing artifacts - can be "legacy" or
+     *             "default".
+     */
+    private String layout = "default";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get a unique identifier for a repository.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Get the type of layout this repository uses for locating and
+     * storing artifacts - can be "legacy" or
+     *             "default".
+     * 
+     * @return String
+     */
+    public String getLayout()
+    {
+        return this.layout;
+    } //-- String getLayout()
+
+    /**
+     * Get human readable name of the repository.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the url of the repository.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Set a unique identifier for a repository.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the type of layout this repository uses for locating and
+     * storing artifacts - can be "legacy" or
+     *             "default".
+     * 
+     * @param layout
+     */
+    public void setLayout( String layout )
+    {
+        this.layout = layout;
+    } //-- void setLayout( String )
+
+    /**
+     * Set human readable name of the repository.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the url of the repository.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+    
+            public boolean equals( Object obj )
+            {
+                RepositoryBase other =  (RepositoryBase) obj;
+
+                boolean retValue = false;
+
+                if ( id != null )
+                {
+                    retValue = id.equals( other.id );
+                }
+
+                return retValue;
+            }
+          
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryPolicy.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryPolicy.java
new file mode 100644
index 0000000..d9d520f
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/RepositoryPolicy.java
@@ -0,0 +1,119 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles;
+
+/**
+ * Download policy.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class RepositoryPolicy
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Whether to use this repository for downloading this type of
+     * artifact.
+     */
+    private boolean enabled = true;
+
+    /**
+     * 
+     *             The frequency for downloading updates - can be
+     * "always", "daily" (default), "interval:XXX" (in minutes) or
+     *             "never" (only if it doesn't exist locally).
+     *           
+     */
+    private String updatePolicy;
+
+    /**
+     * What to do when verification of an artifact checksum fails -
+     * warn, fail, etc. Valid values are
+     *             "fail" or "warn".
+     */
+    private String checksumPolicy;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get what to do when verification of an artifact checksum
+     * fails - warn, fail, etc. Valid values are
+     *             "fail" or "warn".
+     * 
+     * @return String
+     */
+    public String getChecksumPolicy()
+    {
+        return this.checksumPolicy;
+    } //-- String getChecksumPolicy()
+
+    /**
+     * Get the frequency for downloading updates - can be "always",
+     * "daily" (default), "interval:XXX" (in minutes) or
+     *             "never" (only if it doesn't exist locally).
+     * 
+     * @return String
+     */
+    public String getUpdatePolicy()
+    {
+        return this.updatePolicy;
+    } //-- String getUpdatePolicy()
+
+    /**
+     * Get whether to use this repository for downloading this type
+     * of artifact.
+     * 
+     * @return boolean
+     */
+    public boolean isEnabled()
+    {
+        return this.enabled;
+    } //-- boolean isEnabled()
+
+    /**
+     * Set what to do when verification of an artifact checksum
+     * fails - warn, fail, etc. Valid values are
+     *             "fail" or "warn".
+     * 
+     * @param checksumPolicy
+     */
+    public void setChecksumPolicy( String checksumPolicy )
+    {
+        this.checksumPolicy = checksumPolicy;
+    } //-- void setChecksumPolicy( String )
+
+    /**
+     * Set whether to use this repository for downloading this type
+     * of artifact.
+     * 
+     * @param enabled
+     */
+    public void setEnabled( boolean enabled )
+    {
+        this.enabled = enabled;
+    } //-- void setEnabled( boolean )
+
+    /**
+     * Set the frequency for downloading updates - can be "always",
+     * "daily" (default), "interval:XXX" (in minutes) or
+     *             "never" (only if it doesn't exist locally).
+     * 
+     * @param updatePolicy
+     */
+    public void setUpdatePolicy( String updatePolicy )
+    {
+        this.updatePolicy = updatePolicy;
+    } //-- void setUpdatePolicy( String )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java
new file mode 100644
index 0000000..c2de23e
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java
@@ -0,0 +1,1199 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.profiles.Activation;
+import org.apache.maven.profiles.ActivationFile;
+import org.apache.maven.profiles.ActivationOS;
+import org.apache.maven.profiles.ActivationProperty;
+import org.apache.maven.profiles.Profile;
+import org.apache.maven.profiles.ProfilesRoot;
+import org.apache.maven.profiles.Repository;
+import org.apache.maven.profiles.RepositoryBase;
+import org.apache.maven.profiles.RepositoryPolicy;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class ProfilesXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ProfilesXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ProfilesXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.profiles.io.xpp3.ProfilesXpp3Reader()
+
+    public ProfilesXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.profiles.io.xpp3.ProfilesXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ProfilesRoot
+     */
+    public ProfilesRoot read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- ProfilesRoot read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ProfilesRoot
+     */
+    public ProfilesRoot read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- ProfilesRoot read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ProfilesRoot
+     */
+    public ProfilesRoot read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- ProfilesRoot read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ProfilesRoot
+     */
+    public ProfilesRoot read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- ProfilesRoot read( InputStream )
+
+    /**
+     * Method parseActivation.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Activation
+     */
+    private Activation parseActivation( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Activation activation = new Activation();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "activeByDefault", null, parsed ) )
+            {
+                activation.setActiveByDefault( getBooleanValue( interpolatedTrimmed( parser.nextText(), "activeByDefault" ), "activeByDefault", parser, "false" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "jdk", null, parsed ) )
+            {
+                activation.setJdk( interpolatedTrimmed( parser.nextText(), "jdk" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "os", null, parsed ) )
+            {
+                activation.setOs( parseActivationOS( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "property", null, parsed ) )
+            {
+                activation.setProperty( parseActivationProperty( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "file", null, parsed ) )
+            {
+                activation.setFile( parseActivationFile( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activation;
+    } //-- Activation parseActivation( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationFile.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationFile
+     */
+    private ActivationFile parseActivationFile( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationFile activationFile = new ActivationFile();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "missing", null, parsed ) )
+            {
+                activationFile.setMissing( interpolatedTrimmed( parser.nextText(), "missing" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "exists", null, parsed ) )
+            {
+                activationFile.setExists( interpolatedTrimmed( parser.nextText(), "exists" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationFile;
+    } //-- ActivationFile parseActivationFile( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationOS.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationOS
+     */
+    private ActivationOS parseActivationOS( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationOS activationOS = new ActivationOS();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                activationOS.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "family", null, parsed ) )
+            {
+                activationOS.setFamily( interpolatedTrimmed( parser.nextText(), "family" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "arch", null, parsed ) )
+            {
+                activationOS.setArch( interpolatedTrimmed( parser.nextText(), "arch" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                activationOS.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationOS;
+    } //-- ActivationOS parseActivationOS( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationProperty.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationProperty
+     */
+    private ActivationProperty parseActivationProperty( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationProperty activationProperty = new ActivationProperty();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                activationProperty.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "value", null, parsed ) )
+            {
+                activationProperty.setValue( interpolatedTrimmed( parser.nextText(), "value" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationProperty;
+    } //-- ActivationProperty parseActivationProperty( XmlPullParser, boolean )
+
+    /**
+     * Method parseProfile.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Profile
+     */
+    private Profile parseProfile( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Profile profile = new Profile();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                profile.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "activation", null, parsed ) )
+            {
+                profile.setActivation( parseActivation( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    profile.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return profile;
+    } //-- Profile parseProfile( XmlPullParser, boolean )
+
+    /**
+     * Method parseProfilesRoot.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ProfilesRoot
+     */
+    private ProfilesRoot parseProfilesRoot( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ProfilesRoot profilesRoot = new ProfilesRoot();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "profiles", null, parsed ) )
+            {
+                java.util.List profiles = new java.util.ArrayList/*<Profile>*/();
+                profilesRoot.setProfiles( profiles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "profile".equals( parser.getName() ) )
+                    {
+                        profiles.add( parseProfile( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "activeProfiles", null, parsed ) )
+            {
+                java.util.List activeProfiles = new java.util.ArrayList/*<String>*/();
+                profilesRoot.setActiveProfiles( activeProfiles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "activeProfile".equals( parser.getName() ) )
+                    {
+                        activeProfiles.add( interpolatedTrimmed( parser.nextText(), "activeProfiles" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return profilesRoot;
+    } //-- ProfilesRoot parseProfilesRoot( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepository.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Repository
+     */
+    private Repository parseRepository( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Repository repository = new Repository();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
+            {
+                repository.setReleases( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
+            {
+                repository.setSnapshots( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                repository.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                repository.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                repository.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                repository.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repository;
+    } //-- Repository parseRepository( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepositoryBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryBase
+     */
+    private RepositoryBase parseRepositoryBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryBase repositoryBase = new RepositoryBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                repositoryBase.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                repositoryBase.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                repositoryBase.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                repositoryBase.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryBase;
+    } //-- RepositoryBase parseRepositoryBase( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepositoryPolicy.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryPolicy
+     */
+    private RepositoryPolicy parseRepositoryPolicy( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryPolicy repositoryPolicy = new RepositoryPolicy();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "enabled", null, parsed ) )
+            {
+                repositoryPolicy.setEnabled( getBooleanValue( interpolatedTrimmed( parser.nextText(), "enabled" ), "enabled", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "updatePolicy", null, parsed ) )
+            {
+                repositoryPolicy.setUpdatePolicy( interpolatedTrimmed( parser.nextText(), "updatePolicy" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "checksumPolicy", null, parsed ) )
+            {
+                repositoryPolicy.setChecksumPolicy( interpolatedTrimmed( parser.nextText(), "checksumPolicy" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryPolicy;
+    } //-- RepositoryPolicy parseRepositoryPolicy( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ProfilesRoot
+     */
+    private ProfilesRoot read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "profilesXml".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'profilesXml' but found '" + parser.getName() + "'", parser, null );
+                }
+                ProfilesRoot profilesRoot = parseProfilesRoot( parser, strict );
+                profilesRoot.setModelEncoding( parser.getInputEncoding() );
+                return profilesRoot;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'profilesXml' but found no element at all: invalid XML document", parser, null );
+    } //-- ProfilesRoot read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java
new file mode 100644
index 0000000..86118e0
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java
@@ -0,0 +1,389 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.profiles.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.profiles.Activation;
+import org.apache.maven.profiles.ActivationFile;
+import org.apache.maven.profiles.ActivationOS;
+import org.apache.maven.profiles.ActivationProperty;
+import org.apache.maven.profiles.Profile;
+import org.apache.maven.profiles.ProfilesRoot;
+import org.apache.maven.profiles.Repository;
+import org.apache.maven.profiles.RepositoryBase;
+import org.apache.maven.profiles.RepositoryPolicy;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class ProfilesXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ProfilesXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param profilesRoot
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, ProfilesRoot profilesRoot )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( profilesRoot.getModelEncoding(), null );
+        writeProfilesRoot( profilesRoot, "profilesXml", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, ProfilesRoot )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param profilesRoot
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, ProfilesRoot profilesRoot )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, profilesRoot.getModelEncoding() );
+        serializer.startDocument( profilesRoot.getModelEncoding(), null );
+        writeProfilesRoot( profilesRoot, "profilesXml", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, ProfilesRoot )
+
+    /**
+     * Method writeActivation.
+     * 
+     * @param activation
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivation( Activation activation, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activation.isActiveByDefault() != false )
+        {
+            serializer.startTag( NAMESPACE, "activeByDefault" ).text( String.valueOf( activation.isActiveByDefault() ) ).endTag( NAMESPACE, "activeByDefault" );
+        }
+        if ( activation.getJdk() != null )
+        {
+            serializer.startTag( NAMESPACE, "jdk" ).text( activation.getJdk() ).endTag( NAMESPACE, "jdk" );
+        }
+        if ( activation.getOs() != null )
+        {
+            writeActivationOS( (ActivationOS) activation.getOs(), "os", serializer );
+        }
+        if ( activation.getProperty() != null )
+        {
+            writeActivationProperty( (ActivationProperty) activation.getProperty(), "property", serializer );
+        }
+        if ( activation.getFile() != null )
+        {
+            writeActivationFile( (ActivationFile) activation.getFile(), "file", serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivation( Activation, String, XmlSerializer )
+
+    /**
+     * Method writeActivationFile.
+     * 
+     * @param activationFile
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationFile( ActivationFile activationFile, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationFile.getMissing() != null )
+        {
+            serializer.startTag( NAMESPACE, "missing" ).text( activationFile.getMissing() ).endTag( NAMESPACE, "missing" );
+        }
+        if ( activationFile.getExists() != null )
+        {
+            serializer.startTag( NAMESPACE, "exists" ).text( activationFile.getExists() ).endTag( NAMESPACE, "exists" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationFile( ActivationFile, String, XmlSerializer )
+
+    /**
+     * Method writeActivationOS.
+     * 
+     * @param activationOS
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationOS( ActivationOS activationOS, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationOS.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( activationOS.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( activationOS.getFamily() != null )
+        {
+            serializer.startTag( NAMESPACE, "family" ).text( activationOS.getFamily() ).endTag( NAMESPACE, "family" );
+        }
+        if ( activationOS.getArch() != null )
+        {
+            serializer.startTag( NAMESPACE, "arch" ).text( activationOS.getArch() ).endTag( NAMESPACE, "arch" );
+        }
+        if ( activationOS.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( activationOS.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationOS( ActivationOS, String, XmlSerializer )
+
+    /**
+     * Method writeActivationProperty.
+     * 
+     * @param activationProperty
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationProperty( ActivationProperty activationProperty, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationProperty.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( activationProperty.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( activationProperty.getValue() != null )
+        {
+            serializer.startTag( NAMESPACE, "value" ).text( activationProperty.getValue() ).endTag( NAMESPACE, "value" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationProperty( ActivationProperty, String, XmlSerializer )
+
+    /**
+     * Method writeProfile.
+     * 
+     * @param profile
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeProfile( Profile profile, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( profile.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( profile.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( profile.getActivation() != null )
+        {
+            writeActivation( (Activation) profile.getActivation(), "activation", serializer );
+        }
+        if ( ( profile.getProperties() != null ) && ( profile.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = profile.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) profile.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        if ( ( profile.getRepositories() != null ) && ( profile.getRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "repositories" );
+            for ( Iterator iter = profile.getRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "repository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "repositories" );
+        }
+        if ( ( profile.getPluginRepositories() != null ) && ( profile.getPluginRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "pluginRepositories" );
+            for ( Iterator iter = profile.getPluginRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "pluginRepository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "pluginRepositories" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeProfile( Profile, String, XmlSerializer )
+
+    /**
+     * Method writeProfilesRoot.
+     * 
+     * @param profilesRoot
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeProfilesRoot( ProfilesRoot profilesRoot, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/PROFILES/1.0.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/PROFILES/1.0.0 http://maven.apache.org/xsd/profiles-1.0.0.xsd" );
+        if ( ( profilesRoot.getProfiles() != null ) && ( profilesRoot.getProfiles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "profiles" );
+            for ( Iterator iter = profilesRoot.getProfiles().iterator(); iter.hasNext(); )
+            {
+                Profile o = (Profile) iter.next();
+                writeProfile( o, "profile", serializer );
+            }
+            serializer.endTag( NAMESPACE, "profiles" );
+        }
+        if ( ( profilesRoot.getActiveProfiles() != null ) && ( profilesRoot.getActiveProfiles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "activeProfiles" );
+            for ( Iterator iter = profilesRoot.getActiveProfiles().iterator(); iter.hasNext(); )
+            {
+                String activeProfile = (String) iter.next();
+                serializer.startTag( NAMESPACE, "activeProfile" ).text( activeProfile ).endTag( NAMESPACE, "activeProfile" );
+            }
+            serializer.endTag( NAMESPACE, "activeProfiles" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeProfilesRoot( ProfilesRoot, String, XmlSerializer )
+
+    /**
+     * Method writeRepository.
+     * 
+     * @param repository
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepository( Repository repository, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repository.getReleases() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) repository.getReleases(), "releases", serializer );
+        }
+        if ( repository.getSnapshots() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) repository.getSnapshots(), "snapshots", serializer );
+        }
+        if ( repository.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( repository.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( repository.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( repository.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( repository.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( repository.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( repository.getLayout() != null ) && !repository.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( repository.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepository( Repository, String, XmlSerializer )
+
+    /**
+     * Method writeRepositoryBase.
+     * 
+     * @param repositoryBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepositoryBase( RepositoryBase repositoryBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repositoryBase.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( repositoryBase.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( repositoryBase.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( repositoryBase.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( repositoryBase.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( repositoryBase.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( repositoryBase.getLayout() != null ) && !repositoryBase.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( repositoryBase.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepositoryBase( RepositoryBase, String, XmlSerializer )
+
+    /**
+     * Method writeRepositoryPolicy.
+     * 
+     * @param repositoryPolicy
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepositoryPolicy( RepositoryPolicy repositoryPolicy, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repositoryPolicy.isEnabled() != true )
+        {
+            serializer.startTag( NAMESPACE, "enabled" ).text( String.valueOf( repositoryPolicy.isEnabled() ) ).endTag( NAMESPACE, "enabled" );
+        }
+        if ( repositoryPolicy.getUpdatePolicy() != null )
+        {
+            serializer.startTag( NAMESPACE, "updatePolicy" ).text( repositoryPolicy.getUpdatePolicy() ).endTag( NAMESPACE, "updatePolicy" );
+        }
+        if ( repositoryPolicy.getChecksumPolicy() != null )
+        {
+            serializer.startTag( NAMESPACE, "checksumPolicy" ).text( repositoryPolicy.getChecksumPolicy() ).endTag( NAMESPACE, "checksumPolicy" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepositoryPolicy( RepositoryPolicy, String, XmlSerializer )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/Expression.java b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/Expression.java
new file mode 100644
index 0000000..8bc2e09
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/Expression.java
@@ -0,0 +1,273 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.usability.plugin;
+
+/**
+ * A plugin parameter expression supported by Maven.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Expression
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The syntax of the expression.
+     */
+    private String syntax;
+
+    /**
+     * The description of what this expression references, and what
+     * it's generally used for.
+     */
+    private String description;
+
+    /**
+     * The place and syntax used to change the value of this
+     * expression.
+     */
+    private String configuration;
+
+    /**
+     * Field cliOptions.
+     */
+    private java.util.Properties cliOptions;
+
+    /**
+     * Field apiMethods.
+     */
+    private java.util.Properties apiMethods;
+
+    /**
+     * A preferred alternative to this expression, in the case
+     * where it's deprecated.
+     */
+    private String deprecation;
+
+    /**
+     * A preferred alternative to this expression, in the case
+     * where it's banned from use.
+     */
+    private String ban;
+
+    /**
+     * Whether the value of this expression can be changed.
+     */
+    private boolean editable = true;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addApiMethod.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addApiMethod( String key, String value )
+    {
+        getApiMethods().put( key, value );
+    } //-- void addApiMethod( String, String )
+
+    /**
+     * Method addCliOption.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addCliOption( String key, String value )
+    {
+        getCliOptions().put( key, value );
+    } //-- void addCliOption( String, String )
+
+    /**
+     * Method getApiMethods.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getApiMethods()
+    {
+        if ( this.apiMethods == null )
+        {
+            this.apiMethods = new java.util.Properties();
+        }
+
+        return this.apiMethods;
+    } //-- java.util.Properties getApiMethods()
+
+    /**
+     * Get a preferred alternative to this expression, in the case
+     * where it's banned from use.
+     * 
+     * @return String
+     */
+    public String getBan()
+    {
+        return this.ban;
+    } //-- String getBan()
+
+    /**
+     * Method getCliOptions.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getCliOptions()
+    {
+        if ( this.cliOptions == null )
+        {
+            this.cliOptions = new java.util.Properties();
+        }
+
+        return this.cliOptions;
+    } //-- java.util.Properties getCliOptions()
+
+    /**
+     * Get the place and syntax used to change the value of this
+     * expression.
+     * 
+     * @return String
+     */
+    public String getConfiguration()
+    {
+        return this.configuration;
+    } //-- String getConfiguration()
+
+    /**
+     * Get a preferred alternative to this expression, in the case
+     * where it's deprecated.
+     * 
+     * @return String
+     */
+    public String getDeprecation()
+    {
+        return this.deprecation;
+    } //-- String getDeprecation()
+
+    /**
+     * Get the description of what this expression references, and
+     * what it's generally used for.
+     * 
+     * @return String
+     */
+    public String getDescription()
+    {
+        return this.description;
+    } //-- String getDescription()
+
+    /**
+     * Get the syntax of the expression.
+     * 
+     * @return String
+     */
+    public String getSyntax()
+    {
+        return this.syntax;
+    } //-- String getSyntax()
+
+    /**
+     * Get whether the value of this expression can be changed.
+     * 
+     * @return boolean
+     */
+    public boolean isEditable()
+    {
+        return this.editable;
+    } //-- boolean isEditable()
+
+    /**
+     * Set the programmatic methods used to change the value of
+     * this expression.
+     * 
+     * @param apiMethods
+     */
+    public void setApiMethods( java.util.Properties apiMethods )
+    {
+        this.apiMethods = apiMethods;
+    } //-- void setApiMethods( java.util.Properties )
+
+    /**
+     * Set a preferred alternative to this expression, in the case
+     * where it's banned from use.
+     * 
+     * @param ban
+     */
+    public void setBan( String ban )
+    {
+        this.ban = ban;
+    } //-- void setBan( String )
+
+    /**
+     * Set the command-line switches used to change the value of
+     * this expression.
+     * 
+     * @param cliOptions
+     */
+    public void setCliOptions( java.util.Properties cliOptions )
+    {
+        this.cliOptions = cliOptions;
+    } //-- void setCliOptions( java.util.Properties )
+
+    /**
+     * Set the place and syntax used to change the value of this
+     * expression.
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( String configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( String )
+
+    /**
+     * Set a preferred alternative to this expression, in the case
+     * where it's deprecated.
+     * 
+     * @param deprecation
+     */
+    public void setDeprecation( String deprecation )
+    {
+        this.deprecation = deprecation;
+    } //-- void setDeprecation( String )
+
+    /**
+     * Set the description of what this expression references, and
+     * what it's generally used for.
+     * 
+     * @param description
+     */
+    public void setDescription( String description )
+    {
+        this.description = description;
+    } //-- void setDescription( String )
+
+    /**
+     * Set whether the value of this expression can be changed.
+     * 
+     * @param editable
+     */
+    public void setEditable( boolean editable )
+    {
+        this.editable = editable;
+    } //-- void setEditable( boolean )
+
+    /**
+     * Set the syntax of the expression.
+     * 
+     * @param syntax
+     */
+    public void setSyntax( String syntax )
+    {
+        this.syntax = syntax;
+    } //-- void setSyntax( String )
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/ExpressionDocumentation.java b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/ExpressionDocumentation.java
new file mode 100644
index 0000000..204ac15
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/ExpressionDocumentation.java
@@ -0,0 +1,133 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.usability.plugin;
+
+/**
+ * The root of a parameter plugin expression document.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ExpressionDocumentation
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field expressions.
+     */
+    private java.util.List<Expression> expressions;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExpression.
+     * 
+     * @param expression
+     */
+    public void addExpression( Expression expression )
+    {
+        getExpressions().add( expression );
+    } //-- void addExpression( Expression )
+
+    /**
+     * Method getExpressions.
+     * 
+     * @return List
+     */
+    public java.util.List<Expression> getExpressions()
+    {
+        if ( this.expressions == null )
+        {
+            this.expressions = new java.util.ArrayList<Expression>();
+        }
+
+        return this.expressions;
+    } //-- java.util.List<Expression> getExpressions()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method removeExpression.
+     * 
+     * @param expression
+     */
+    public void removeExpression( Expression expression )
+    {
+        getExpressions().remove( expression );
+    } //-- void removeExpression( Expression )
+
+    /**
+     * Set the list of plugin parameter expressions described by
+     * this
+     *             document.
+     * 
+     * @param expressions
+     */
+    public void setExpressions( java.util.List<Expression> expressions )
+    {
+        this.expressions = expressions;
+    } //-- void setExpressions( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+        private java.util.Map expressionsBySyntax;
+
+    public java.util.Map getExpressionsBySyntax()
+    {
+        if ( expressionsBySyntax == null )
+        {
+            expressionsBySyntax = new java.util.HashMap();
+
+            java.util.List expressions = getExpressions();
+
+            if ( expressions != null && !expressions.isEmpty() )
+            {
+                for ( java.util.Iterator it = expressions.iterator(); it.hasNext(); )
+                {
+                    Expression expr = (Expression) it.next();
+
+                    expressionsBySyntax.put( expr.getSyntax(), expr );
+                }
+            }
+        }
+
+        return expressionsBySyntax;
+    }
+
+    public void flushExpressionsBySyntax()
+    {
+        expressionsBySyntax = null;
+    }
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java
new file mode 100644
index 0000000..be6e48c
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java
@@ -0,0 +1,832 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.usability.plugin.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.usability.plugin.Expression;
+import org.apache.maven.usability.plugin.ExpressionDocumentation;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class ParamdocXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ParamdocXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ParamdocXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.usability.plugin.io.xpp3.ParamdocXpp3Reader()
+
+    public ParamdocXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.usability.plugin.io.xpp3.ParamdocXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ExpressionDocumentation
+     */
+    public ExpressionDocumentation read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- ExpressionDocumentation read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ExpressionDocumentation
+     */
+    public ExpressionDocumentation read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- ExpressionDocumentation read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ExpressionDocumentation
+     */
+    public ExpressionDocumentation read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- ExpressionDocumentation read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ExpressionDocumentation
+     */
+    public ExpressionDocumentation read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- ExpressionDocumentation read( InputStream )
+
+    /**
+     * Method parseExpression.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Expression
+     */
+    private Expression parseExpression( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Expression expression = new Expression();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "syntax", null, parsed ) )
+            {
+                expression.setSyntax( interpolatedTrimmed( parser.nextText(), "syntax" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "description", null, parsed ) )
+            {
+                expression.setDescription( interpolatedTrimmed( parser.nextText(), "description" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                expression.setConfiguration( interpolatedTrimmed( parser.nextText(), "configuration" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "cliOptions", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "cliOption".equals( parser.getName() ) )
+                    {
+                        String key = null;
+                        String value = null;
+                        // explode mode.
+                        while ( parser.nextTag() == XmlPullParser.START_TAG )
+                        {
+                            if ( "key".equals( parser.getName() ) )
+                            {
+                                key = parser.nextText();
+                            }
+                            else if ( "value".equals( parser.getName() ) )
+                            {
+                                value = parser.nextText().trim();
+                            }
+                            else
+                            {
+                                parser.nextText();
+                            }
+                        }
+                        expression.addCliOption( key, value );
+                    }
+                    parser.next();
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "apiMethods", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "apiMethod".equals( parser.getName() ) )
+                    {
+                        String key = null;
+                        String value = null;
+                        // explode mode.
+                        while ( parser.nextTag() == XmlPullParser.START_TAG )
+                        {
+                            if ( "key".equals( parser.getName() ) )
+                            {
+                                key = parser.nextText();
+                            }
+                            else if ( "value".equals( parser.getName() ) )
+                            {
+                                value = parser.nextText().trim();
+                            }
+                            else
+                            {
+                                parser.nextText();
+                            }
+                        }
+                        expression.addApiMethod( key, value );
+                    }
+                    parser.next();
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "deprecation", null, parsed ) )
+            {
+                expression.setDeprecation( interpolatedTrimmed( parser.nextText(), "deprecation" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "ban", null, parsed ) )
+            {
+                expression.setBan( interpolatedTrimmed( parser.nextText(), "ban" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "editable", null, parsed ) )
+            {
+                expression.setEditable( getBooleanValue( interpolatedTrimmed( parser.nextText(), "editable" ), "editable", parser, "true" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return expression;
+    } //-- Expression parseExpression( XmlPullParser, boolean )
+
+    /**
+     * Method parseExpressionDocumentation.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ExpressionDocumentation
+     */
+    private ExpressionDocumentation parseExpressionDocumentation( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ExpressionDocumentation expressionDocumentation = new ExpressionDocumentation();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "expressions", null, parsed ) )
+            {
+                java.util.List expressions = new java.util.ArrayList/*<Expression>*/();
+                expressionDocumentation.setExpressions( expressions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "expression".equals( parser.getName() ) )
+                    {
+                        expressions.add( parseExpression( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return expressionDocumentation;
+    } //-- ExpressionDocumentation parseExpressionDocumentation( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ExpressionDocumentation
+     */
+    private ExpressionDocumentation read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "paramdoc".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'paramdoc' but found '" + parser.getName() + "'", parser, null );
+                }
+                ExpressionDocumentation expressionDocumentation = parseExpressionDocumentation( parser, strict );
+                expressionDocumentation.setModelEncoding( parser.getInputEncoding() );
+                return expressionDocumentation;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'paramdoc' but found no element at all: invalid XML document", parser, null );
+    } //-- ExpressionDocumentation read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java
new file mode 100644
index 0000000..4d2d562
--- /dev/null
+++ b/maven-compat/target/generated-sources/modello/org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java
@@ -0,0 +1,176 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.usability.plugin.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.usability.plugin.Expression;
+import org.apache.maven.usability.plugin.ExpressionDocumentation;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class ParamdocXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ParamdocXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param expressionDocumentation
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, ExpressionDocumentation expressionDocumentation )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( expressionDocumentation.getModelEncoding(), null );
+        writeExpressionDocumentation( expressionDocumentation, "paramdoc", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, ExpressionDocumentation )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param expressionDocumentation
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, ExpressionDocumentation expressionDocumentation )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, expressionDocumentation.getModelEncoding() );
+        serializer.startDocument( expressionDocumentation.getModelEncoding(), null );
+        writeExpressionDocumentation( expressionDocumentation, "paramdoc", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, ExpressionDocumentation )
+
+    /**
+     * Method writeExpression.
+     * 
+     * @param expression
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeExpression( Expression expression, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( expression.getSyntax() != null )
+        {
+            serializer.startTag( NAMESPACE, "syntax" ).text( expression.getSyntax() ).endTag( NAMESPACE, "syntax" );
+        }
+        if ( expression.getDescription() != null )
+        {
+            serializer.startTag( NAMESPACE, "description" ).text( expression.getDescription() ).endTag( NAMESPACE, "description" );
+        }
+        if ( expression.getConfiguration() != null )
+        {
+            serializer.startTag( NAMESPACE, "configuration" ).text( expression.getConfiguration() ).endTag( NAMESPACE, "configuration" );
+        }
+        if ( ( expression.getCliOptions() != null ) && ( expression.getCliOptions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "cliOptions" );
+            for ( Iterator iter = expression.getCliOptions().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) expression.getCliOptions().get( key );
+                serializer.startTag( NAMESPACE, "cliOption" );
+                serializer.startTag( NAMESPACE, "key" ).text( key ).endTag( NAMESPACE, "key" );
+                serializer.startTag( NAMESPACE, "value" ).text( value ).endTag( NAMESPACE, "value" );
+                serializer.endTag( NAMESPACE, "cliOption" );
+            }
+            serializer.endTag( NAMESPACE, "cliOptions" );
+        }
+        if ( ( expression.getApiMethods() != null ) && ( expression.getApiMethods().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "apiMethods" );
+            for ( Iterator iter = expression.getApiMethods().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) expression.getApiMethods().get( key );
+                serializer.startTag( NAMESPACE, "apiMethod" );
+                serializer.startTag( NAMESPACE, "key" ).text( key ).endTag( NAMESPACE, "key" );
+                serializer.startTag( NAMESPACE, "value" ).text( value ).endTag( NAMESPACE, "value" );
+                serializer.endTag( NAMESPACE, "apiMethod" );
+            }
+            serializer.endTag( NAMESPACE, "apiMethods" );
+        }
+        if ( expression.getDeprecation() != null )
+        {
+            serializer.startTag( NAMESPACE, "deprecation" ).text( expression.getDeprecation() ).endTag( NAMESPACE, "deprecation" );
+        }
+        if ( expression.getBan() != null )
+        {
+            serializer.startTag( NAMESPACE, "ban" ).text( expression.getBan() ).endTag( NAMESPACE, "ban" );
+        }
+        if ( expression.isEditable() != true )
+        {
+            serializer.startTag( NAMESPACE, "editable" ).text( String.valueOf( expression.isEditable() ) ).endTag( NAMESPACE, "editable" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeExpression( Expression, String, XmlSerializer )
+
+    /**
+     * Method writeExpressionDocumentation.
+     * 
+     * @param expressionDocumentation
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeExpressionDocumentation( ExpressionDocumentation expressionDocumentation, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/PARAMDOC/1.0.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/PARAMDOC/1.0.0 http://maven.apache.org/xsd/paramdoc-1.0.0.xsd" );
+        if ( ( expressionDocumentation.getExpressions() != null ) && ( expressionDocumentation.getExpressions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "expressions" );
+            for ( Iterator iter = expressionDocumentation.getExpressions().iterator(); iter.hasNext(); )
+            {
+                Expression o = (Expression) iter.next();
+                writeExpression( o, "expression", serializer );
+            }
+            serializer.endTag( NAMESPACE, "expressions" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeExpressionDocumentation( ExpressionDocumentation, String, XmlSerializer )
+
+}
diff --git a/maven-core/pom.xml b/maven-core/pom.xml
index 531b924..68aeeee 100644
--- a/maven-core/pom.xml
+++ b/maven-core/pom.xml
@@ -180,26 +180,20 @@
         <artifactId>sisu-maven-plugin</artifactId>
       </plugin>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <version>1.1.0</version>
-          <models>
-            <model>src/main/mdo/toolchains.mdo</model>
-          </models>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
         <executions>
           <execution>
-            <id>plugin-site-doc</id>
-            <phase>pre-site</phase>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
             <goals>
-              <goal>xdoc</goal>
+              <goal>add-source</goal>
             </goals>
             <configuration>
-              <version>1.0.0</version>
-              <models>
-                <model>src/main/mdo/extension.mdo</model>
-              </models>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
             </configuration>
           </execution>
         </executions>
diff --git a/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/PersistedToolchains.java b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/PersistedToolchains.java
new file mode 100644
index 0000000..1334e53
--- /dev/null
+++ b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/PersistedToolchains.java
@@ -0,0 +1,137 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.toolchain.model;
+
+/**
+ * 
+ *          The <code>&lt;toolchains&gt;</code> element is the root
+ * of the descriptor.
+ *          The following table lists all of the possible child
+ * elements.
+ *             
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PersistedToolchains
+    extends TrackableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field toolchains.
+     */
+    private java.util.List<ToolchainModel> toolchains;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addToolchain.
+     * 
+     * @param toolchainModel
+     */
+    public void addToolchain( ToolchainModel toolchainModel )
+    {
+        getToolchains().add( toolchainModel );
+    } //-- void addToolchain( ToolchainModel )
+
+    /**
+     * Method clone.
+     * 
+     * @return PersistedToolchains
+     */
+    public PersistedToolchains clone()
+    {
+        try
+        {
+            PersistedToolchains copy = (PersistedToolchains) super.clone();
+
+            if ( this.toolchains != null )
+            {
+                copy.toolchains = new java.util.ArrayList<ToolchainModel>();
+                for ( ToolchainModel item : this.toolchains )
+                {
+                    copy.toolchains.add( ( (ToolchainModel) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PersistedToolchains clone()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method getToolchains.
+     * 
+     * @return List
+     */
+    public java.util.List<ToolchainModel> getToolchains()
+    {
+        if ( this.toolchains == null )
+        {
+            this.toolchains = new java.util.ArrayList<ToolchainModel>();
+        }
+
+        return this.toolchains;
+    } //-- java.util.List<ToolchainModel> getToolchains()
+
+    /**
+     * Method removeToolchain.
+     * 
+     * @param toolchainModel
+     */
+    public void removeToolchain( ToolchainModel toolchainModel )
+    {
+        getToolchains().remove( toolchainModel );
+    } //-- void removeToolchain( ToolchainModel )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set the toolchain instance definition.
+     * 
+     * @param toolchains
+     */
+    public void setToolchains( java.util.List<ToolchainModel> toolchains )
+    {
+        this.toolchains = toolchains;
+    } //-- void setToolchains( java.util.List )
+
+}
diff --git a/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/ToolchainModel.java b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/ToolchainModel.java
new file mode 100644
index 0000000..9ba9c59
--- /dev/null
+++ b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/ToolchainModel.java
@@ -0,0 +1,262 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.toolchain.model;
+
+/**
+ * Definition of a toolchain instance.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ToolchainModel
+    extends TrackableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *                     Type of toolchain:<ul>
+     *                     <li><code>jdk</code> for
+     *                     <a
+     * href="http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html">JDK
+     * Standard Toolchain</a>,</li>
+     *                     <li>other value for
+     *                     <a
+     * href="http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/custom.html">Custom
+     * Toolchain</a></li>
+     *                     </ul>
+     *                     
+     */
+    private String type;
+
+    /**
+     * Field provides.
+     */
+    private java.util.Properties provides;
+
+    /**
+     * 
+     *                     
+     *                     <p>Toolchain configuration information,
+     * like location or any information that is to be
+     * retrieved.</p>
+     *                     <p>Actual content structure is
+     * completely open: each toochain type will define its own
+     * format and semantics.</p>
+     *                     <p>In general, this is a properties
+     * format: <code>&lt;name&gt;value&lt;/name&gt;</code> with
+     *                     per-toolchain defined properties
+     * names.</p>
+     *                     
+     */
+    private Object configuration;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addProvide.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProvide( String key, String value )
+    {
+        getProvides().put( key, value );
+    } //-- void addProvide( String, String )
+
+    /**
+     * Method clone.
+     * 
+     * @return ToolchainModel
+     */
+    public ToolchainModel clone()
+    {
+        try
+        {
+            ToolchainModel copy = (ToolchainModel) super.clone();
+
+            if ( this.provides != null )
+            {
+                copy.provides = (java.util.Properties) this.provides.clone();
+            }
+
+            if ( this.configuration != null )
+            {
+                copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ToolchainModel clone()
+
+    /**
+     * Get <p>Toolchain configuration information, like location or
+     * any information that is to be retrieved.</p>
+     *                     <p>Actual content structure is
+     * completely open: each toochain type will define its own
+     * format and semantics.</p>
+     *                     <p>In general, this is a properties
+     * format: <code>&lt;name&gt;value&lt;/name&gt;</code> with
+     *                     per-toolchain defined properties
+     * names.</p>
+     * 
+     * @return Object
+     */
+    public Object getConfiguration()
+    {
+        return this.configuration;
+    } //-- Object getConfiguration()
+
+    /**
+     * Method getProvides.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProvides()
+    {
+        if ( this.provides == null )
+        {
+            this.provides = new java.util.Properties();
+        }
+
+        return this.provides;
+    } //-- java.util.Properties getProvides()
+
+    /**
+     * Get type of toolchain:<ul>
+     *                     <li><code>jdk</code> for
+     *                     <a
+     * href="http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html">JDK
+     * Standard Toolchain</a>,</li>
+     *                     <li>other value for
+     *                     <a
+     * href="http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/custom.html">Custom
+     * Toolchain</a></li>
+     *                     </ul>
+     * 
+     * @return String
+     */
+    public String getType()
+    {
+        return this.type;
+    } //-- String getType()
+
+    /**
+     * Set <p>Toolchain configuration information, like location or
+     * any information that is to be retrieved.</p>
+     *                     <p>Actual content structure is
+     * completely open: each toochain type will define its own
+     * format and semantics.</p>
+     *                     <p>In general, this is a properties
+     * format: <code>&lt;name&gt;value&lt;/name&gt;</code> with
+     *                     per-toolchain defined properties
+     * names.</p>
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( Object configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( Object )
+
+    /**
+     * Set <p>Toolchain identification information, which will be
+     * matched against project requirements.</p>
+     *                     <p>For Maven 2.0.9 to 3.2.3, the actual
+     * content structure was completely open: each toolchain type
+     * would define its own format and semantics.
+     *                     In general, this was a properties
+     * format.</p>
+     *                     <p>Since Maven 3.2.4, the type for this
+     * field has been changed to Properties to match the de-facto
+     * format.</p>
+     *                     <p>Each toolchain defines its own
+     * properties names and semantics.</p>
+     * 
+     * @param provides
+     */
+    public void setProvides( java.util.Properties provides )
+    {
+        this.provides = provides;
+    } //-- void setProvides( java.util.Properties )
+
+    /**
+     * Set type of toolchain:<ul>
+     *                     <li><code>jdk</code> for
+     *                     <a
+     * href="http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html">JDK
+     * Standard Toolchain</a>,</li>
+     *                     <li>other value for
+     *                     <a
+     * href="http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/custom.html">Custom
+     * Toolchain</a></li>
+     *                     </ul>
+     * 
+     * @param type
+     */
+    public void setType( String type )
+    {
+        this.type = type;
+    } //-- void setType( String )
+
+    
+                
+    /**
+     * Method hashCode.
+     * 
+     * @return int
+     */
+    public int hashCode()
+    {
+        int result = 17;
+
+        result = 37 * result + ( type != null ? type.hashCode() : 0 );
+        result = 37 * result + ( provides != null ? provides.hashCode() : 0 );
+
+        return result;
+    } //-- int hashCode()
+    
+    /**
+     * Method equals.
+     * 
+     * @param other
+     * @return boolean
+     */
+    public boolean equals( Object other )
+    {
+        if ( this == other )
+        {
+            return true;
+        }
+
+        if ( !( other instanceof ToolchainModel ) )
+        {
+            return false;
+        }
+
+        ToolchainModel that = (ToolchainModel) other;
+        boolean result = true;
+
+        result = result && ( getType() == null ? that.getType() == null : getType().equals( that.getType() ) );
+        result = result && ( getProvides() == null ? that.getProvides() == null : getProvides().equals( that.getProvides() ) );
+
+        return result;
+    } //-- boolean equals( Object )    
+                
+              
+}
diff --git a/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/TrackableBase.java b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/TrackableBase.java
new file mode 100644
index 0000000..9a5805e
--- /dev/null
+++ b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/TrackableBase.java
@@ -0,0 +1,77 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.toolchain.model;
+
+/**
+ * 
+ *             common base class that contains code to track the
+ * source for
+ *             this instance (USER|GLOBAL)
+ *           .
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class TrackableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return TrackableBase
+     */
+    public TrackableBase clone()
+    {
+        try
+        {
+            TrackableBase copy = (TrackableBase) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- TrackableBase clone()
+
+    
+                
+        public static final String USER_LEVEL = "user-level";
+        public static final String GLOBAL_LEVEL = "global-level";
+
+        private String sourceLevel = USER_LEVEL;
+        private boolean sourceLevelSet = false;
+
+        public void setSourceLevel( String sourceLevel )
+        {
+            if ( sourceLevelSet )
+            {
+                throw new IllegalStateException( "Cannot reset sourceLevel attribute; it is already set to: " + sourceLevel );
+            }
+            else if ( !( USER_LEVEL.equals( sourceLevel ) || GLOBAL_LEVEL.equals( sourceLevel ) ) )
+            {
+                throw new IllegalArgumentException( "sourceLevel must be one of: {" + USER_LEVEL + "," + GLOBAL_LEVEL + "}" );
+            }
+            else
+            {
+                this.sourceLevel = sourceLevel;
+                this.sourceLevelSet = true;
+            }
+        }
+
+        public String getSourceLevel()
+        {
+            return sourceLevel;
+        }
+                
+              
+}
diff --git a/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java
new file mode 100644
index 0000000..5f22ae4
--- /dev/null
+++ b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java
@@ -0,0 +1,798 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.toolchain.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.toolchain.model.PersistedToolchains;
+import org.apache.maven.toolchain.model.ToolchainModel;
+import org.apache.maven.toolchain.model.TrackableBase;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class MavenToolchainsXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MavenToolchainsXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MavenToolchainsXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.toolchain.model.io.xpp3.MavenToolchainsXpp3Reader()
+
+    public MavenToolchainsXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.toolchain.model.io.xpp3.MavenToolchainsXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PersistedToolchains
+     */
+    public PersistedToolchains read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- PersistedToolchains read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PersistedToolchains
+     */
+    public PersistedToolchains read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- PersistedToolchains read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PersistedToolchains
+     */
+    public PersistedToolchains read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- PersistedToolchains read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PersistedToolchains
+     */
+    public PersistedToolchains read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- PersistedToolchains read( InputStream )
+
+    /**
+     * Method parsePersistedToolchains.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PersistedToolchains
+     */
+    private PersistedToolchains parsePersistedToolchains( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PersistedToolchains persistedToolchains = new PersistedToolchains();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( "toolchain".equals( parser.getName() ) )
+            {
+                java.util.List toolchains = persistedToolchains.getToolchains();
+                if ( toolchains == null )
+                {
+                    toolchains = new java.util.ArrayList/*<ToolchainModel>*/();
+                    persistedToolchains.setToolchains( toolchains );
+                }
+                toolchains.add( parseToolchainModel( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return persistedToolchains;
+    } //-- PersistedToolchains parsePersistedToolchains( XmlPullParser, boolean )
+
+    /**
+     * Method parseToolchainModel.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ToolchainModel
+     */
+    private ToolchainModel parseToolchainModel( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ToolchainModel toolchainModel = new ToolchainModel();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
+            {
+                toolchainModel.setType( interpolatedTrimmed( parser.nextText(), "type" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "provides", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    toolchainModel.addProvide( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                toolchainModel.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return toolchainModel;
+    } //-- ToolchainModel parseToolchainModel( XmlPullParser, boolean )
+
+    /**
+     * Method parseTrackableBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return TrackableBase
+     */
+    private TrackableBase parseTrackableBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        TrackableBase trackableBase = new TrackableBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            checkUnknownElement( parser, strict );
+        }
+        return trackableBase;
+    } //-- TrackableBase parseTrackableBase( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PersistedToolchains
+     */
+    private PersistedToolchains read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "toolchains".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'toolchains' but found '" + parser.getName() + "'", parser, null );
+                }
+                PersistedToolchains persistedToolchains = parsePersistedToolchains( parser, strict );
+                persistedToolchains.setModelEncoding( parser.getInputEncoding() );
+                return persistedToolchains;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'toolchains' but found no element at all: invalid XML document", parser, null );
+    } //-- PersistedToolchains read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Writer.java b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Writer.java
new file mode 100644
index 0000000..53fdabb
--- /dev/null
+++ b/maven-core/target/generated-sources/modello/org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Writer.java
@@ -0,0 +1,158 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.toolchain.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.toolchain.model.PersistedToolchains;
+import org.apache.maven.toolchain.model.ToolchainModel;
+import org.apache.maven.toolchain.model.TrackableBase;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class MavenToolchainsXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MavenToolchainsXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param persistedToolchains
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, PersistedToolchains persistedToolchains )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( persistedToolchains.getModelEncoding(), null );
+        writePersistedToolchains( persistedToolchains, "toolchains", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, PersistedToolchains )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param persistedToolchains
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, PersistedToolchains persistedToolchains )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, persistedToolchains.getModelEncoding() );
+        serializer.startDocument( persistedToolchains.getModelEncoding(), null );
+        writePersistedToolchains( persistedToolchains, "toolchains", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, PersistedToolchains )
+
+    /**
+     * Method writePersistedToolchains.
+     * 
+     * @param persistedToolchains
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePersistedToolchains( PersistedToolchains persistedToolchains, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/TOOLCHAINS/1.1.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/TOOLCHAINS/1.1.0 http://maven.apache.org/xsd/toolchains-1.1.0.xsd" );
+        if ( ( persistedToolchains.getToolchains() != null ) && ( persistedToolchains.getToolchains().size() > 0 ) )
+        {
+            for ( Iterator iter = persistedToolchains.getToolchains().iterator(); iter.hasNext(); )
+            {
+                ToolchainModel o = (ToolchainModel) iter.next();
+                writeToolchainModel( o, "toolchain", serializer );
+            }
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePersistedToolchains( PersistedToolchains, String, XmlSerializer )
+
+    /**
+     * Method writeToolchainModel.
+     * 
+     * @param toolchainModel
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeToolchainModel( ToolchainModel toolchainModel, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( toolchainModel.getType() != null )
+        {
+            serializer.startTag( NAMESPACE, "type" ).text( toolchainModel.getType() ).endTag( NAMESPACE, "type" );
+        }
+        if ( ( toolchainModel.getProvides() != null ) && ( toolchainModel.getProvides().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "provides" );
+            for ( Iterator iter = toolchainModel.getProvides().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) toolchainModel.getProvides().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "provides" );
+        }
+        if ( toolchainModel.getConfiguration() != null )
+        {
+            ((Xpp3Dom) toolchainModel.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeToolchainModel( ToolchainModel, String, XmlSerializer )
+
+    /**
+     * Method writeTrackableBase.
+     * 
+     * @param trackableBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeTrackableBase( TrackableBase trackableBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeTrackableBase( TrackableBase, String, XmlSerializer )
+
+}
diff --git a/maven-embedder/pom.xml b/maven-embedder/pom.xml
index beb84c2..72acc7f 100644
--- a/maven-embedder/pom.xml
+++ b/maven-embedder/pom.xml
@@ -128,14 +128,23 @@
         <artifactId>plexus-component-metadata</artifactId>
       </plugin>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <version>1.0.0</version>
-          <models>
-            <model>src/main/mdo/core-extensions.mdo</model>
-          </models>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
+        <executions>
+          <execution>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
+            <goals>
+              <goal>add-source</goal>
+            </goals>
+            <configuration>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtension.java b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtension.java
new file mode 100644
index 0000000..1c7d5fd
--- /dev/null
+++ b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtension.java
@@ -0,0 +1,102 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.cli.internal.extension.model;
+
+/**
+ * Describes a build extension to utilise.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class CoreExtension
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The group ID of the extension's artifact.
+     */
+    private String groupId;
+
+    /**
+     * The artifact ID of the extension.
+     */
+    private String artifactId;
+
+    /**
+     * The version of the extension.
+     */
+    private String version;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Get the artifact ID of the extension.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the group ID of the extension's artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get the version of the extension.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the artifact ID of the extension.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the group ID of the extension's artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set the version of the extension.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtensions.java b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtensions.java
new file mode 100644
index 0000000..824556a
--- /dev/null
+++ b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/CoreExtensions.java
@@ -0,0 +1,102 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.cli.internal.extension.model;
+
+/**
+ * Extensions to load.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class CoreExtensions
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field extensions.
+     */
+    private java.util.List<CoreExtension> extensions;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExtension.
+     * 
+     * @param coreExtension
+     */
+    public void addExtension( CoreExtension coreExtension )
+    {
+        getExtensions().add( coreExtension );
+    } //-- void addExtension( CoreExtension )
+
+    /**
+     * Method getExtensions.
+     * 
+     * @return List
+     */
+    public java.util.List<CoreExtension> getExtensions()
+    {
+        if ( this.extensions == null )
+        {
+            this.extensions = new java.util.ArrayList<CoreExtension>();
+        }
+
+        return this.extensions;
+    } //-- java.util.List<CoreExtension> getExtensions()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method removeExtension.
+     * 
+     * @param coreExtension
+     */
+    public void removeExtension( CoreExtension coreExtension )
+    {
+        getExtensions().remove( coreExtension );
+    } //-- void removeExtension( CoreExtension )
+
+    /**
+     * Set a set of build extensions to use from this project.
+     * 
+     * @param extensions
+     */
+    public void setExtensions( java.util.List<CoreExtension> extensions )
+    {
+        this.extensions = extensions;
+    } //-- void setExtensions( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+}
diff --git a/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Reader.java b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Reader.java
new file mode 100644
index 0000000..28419a3
--- /dev/null
+++ b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Reader.java
@@ -0,0 +1,756 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.cli.internal.extension.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.cli.internal.extension.model.CoreExtension;
+import org.apache.maven.cli.internal.extension.model.CoreExtensions;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class CoreExtensionsXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class CoreExtensionsXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public CoreExtensionsXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.cli.internal.extension.model.io.xpp3.CoreExtensionsXpp3Reader()
+
+    public CoreExtensionsXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.cli.internal.extension.model.io.xpp3.CoreExtensionsXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtensions
+     */
+    public CoreExtensions read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- CoreExtensions read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtensions
+     */
+    public CoreExtensions read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- CoreExtensions read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtensions
+     */
+    public CoreExtensions read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- CoreExtensions read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtensions
+     */
+    public CoreExtensions read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- CoreExtensions read( InputStream )
+
+    /**
+     * Method parseCoreExtension.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtension
+     */
+    private CoreExtension parseCoreExtension( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        CoreExtension coreExtension = new CoreExtension();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                coreExtension.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                coreExtension.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                coreExtension.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return coreExtension;
+    } //-- CoreExtension parseCoreExtension( XmlPullParser, boolean )
+
+    /**
+     * Method parseCoreExtensions.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtensions
+     */
+    private CoreExtensions parseCoreExtensions( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        CoreExtensions coreExtensions = new CoreExtensions();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( "extension".equals( parser.getName() ) )
+            {
+                java.util.List extensions = coreExtensions.getExtensions();
+                if ( extensions == null )
+                {
+                    extensions = new java.util.ArrayList/*<CoreExtension>*/();
+                    coreExtensions.setExtensions( extensions );
+                }
+                extensions.add( parseCoreExtension( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return coreExtensions;
+    } //-- CoreExtensions parseCoreExtensions( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CoreExtensions
+     */
+    private CoreExtensions read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "extensions".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'extensions' but found '" + parser.getName() + "'", parser, null );
+                }
+                CoreExtensions coreExtensions = parseCoreExtensions( parser, strict );
+                coreExtensions.setModelEncoding( parser.getInputEncoding() );
+                return coreExtensions;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'extensions' but found no element at all: invalid XML document", parser, null );
+    } //-- CoreExtensions read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Writer.java b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Writer.java
new file mode 100644
index 0000000..9c10676
--- /dev/null
+++ b/maven-embedder/target/generated-sources/modello/org/apache/maven/cli/internal/extension/model/io/xpp3/CoreExtensionsXpp3Writer.java
@@ -0,0 +1,134 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.cli.internal.extension.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.cli.internal.extension.model.CoreExtension;
+import org.apache.maven.cli.internal.extension.model.CoreExtensions;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class CoreExtensionsXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class CoreExtensionsXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param coreExtensions
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, CoreExtensions coreExtensions )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( coreExtensions.getModelEncoding(), null );
+        writeCoreExtensions( coreExtensions, "extensions", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, CoreExtensions )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param coreExtensions
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, CoreExtensions coreExtensions )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, coreExtensions.getModelEncoding() );
+        serializer.startDocument( coreExtensions.getModelEncoding(), null );
+        writeCoreExtensions( coreExtensions, "extensions", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, CoreExtensions )
+
+    /**
+     * Method writeCoreExtension.
+     * 
+     * @param coreExtension
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeCoreExtension( CoreExtension coreExtension, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( coreExtension.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( coreExtension.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( coreExtension.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( coreExtension.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( coreExtension.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( coreExtension.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeCoreExtension( CoreExtension, String, XmlSerializer )
+
+    /**
+     * Method writeCoreExtensions.
+     * 
+     * @param coreExtensions
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeCoreExtensions( CoreExtensions coreExtensions, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/EXTENSIONS/1.0.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/EXTENSIONS/1.0.0 http://maven.apache.org/xsd/core-extensions-1.0.0.xsd" );
+        if ( ( coreExtensions.getExtensions() != null ) && ( coreExtensions.getExtensions().size() > 0 ) )
+        {
+            for ( Iterator iter = coreExtensions.getExtensions().iterator(); iter.hasNext(); )
+            {
+                CoreExtension o = (CoreExtension) iter.next();
+                writeCoreExtension( o, "extension", serializer );
+            }
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeCoreExtensions( CoreExtensions, String, XmlSerializer )
+
+}
diff --git a/maven-model/pom.xml b/maven-model/pom.xml
index 7d8a864..ec3be19 100644
--- a/maven-model/pom.xml
+++ b/maven-model/pom.xml
@@ -51,23 +51,21 @@ under the License.
   <build>
     <plugins>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <version>4.0.0</version>
-          <models>
-            <model>src/main/mdo/maven.mdo</model>
-          </models>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
         <executions>
           <execution>
-            <id>standard</id>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
             <goals>
-              <goal>java</goal>
-              <goal>xpp3-reader</goal>
-              <goal>xpp3-extended-reader</goal>
-              <goal>xpp3-writer</goal>
+              <goal>add-source</goal>
             </goals>
+            <configuration>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
+            </configuration>
           </execution>
         </executions>
       </plugin>
@@ -91,25 +89,6 @@ under the License.
       <build>
         <plugins>
           <plugin>
-            <groupId>org.codehaus.modello</groupId>
-            <artifactId>modello-maven-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>v3</id>
-                <goals>
-                  <goal>java</goal>
-                  <goal>xpp3-writer</goal>
-                  <goal>xpp3-reader</goal>
-                  <goal>xsd</goal>
-                </goals>
-                <configuration>
-                  <version>3.0.0</version>
-                  <packageWithVersion>true</packageWithVersion>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-          <plugin>
             <artifactId>maven-jar-plugin</artifactId>
             <executions>
               <execution>
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Activation.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Activation.java
new file mode 100644
index 0000000..def52f6
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Activation.java
@@ -0,0 +1,283 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * The conditions within the build runtime environment which will
+ * trigger the
+ *         automatic inclusion of the build profile. Multiple
+ * conditions can be defined, which must
+ *         be all satisfied to activate the profile.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Activation
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set to true, this profile will be active unless another
+     * profile in this
+     *             pom is activated using the command line -P
+     * option or by one of that profile's
+     *             activators.
+     */
+    private boolean activeByDefault = false;
+
+    /**
+     * 
+     *             
+     *             Specifies that this profile will be activated
+     * when a matching JDK is detected.
+     *             For example, <code>1.4</code> only activates on
+     * JDKs versioned 1.4,
+     *             while <code>!1.4</code> matches any JDK that is
+     * not version 1.4. Ranges are supported too:
+     *             <code>[1.5,)</code> activates when the JDK is
+     * 1.5 minimum.
+     *             
+     *           
+     */
+    private String jdk;
+
+    /**
+     * Specifies that this profile will be activated when matching
+     * operating system
+     *             attributes are detected.
+     */
+    private ActivationOS os;
+
+    /**
+     * Specifies that this profile will be activated when this
+     * system property is
+     *             specified.
+     */
+    private ActivationProperty property;
+
+    /**
+     * Specifies that this profile will be activated based on
+     * existence of a file.
+     */
+    private ActivationFile file;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Activation
+     */
+    public Activation clone()
+    {
+        try
+        {
+            Activation copy = (Activation) super.clone();
+
+            if ( this.os != null )
+            {
+                copy.os = (ActivationOS) this.os.clone();
+            }
+
+            if ( this.property != null )
+            {
+                copy.property = (ActivationProperty) this.property.clone();
+            }
+
+            if ( this.file != null )
+            {
+                copy.file = (ActivationFile) this.file.clone();
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Activation clone()
+
+    /**
+     * Get specifies that this profile will be activated based on
+     * existence of a file.
+     * 
+     * @return ActivationFile
+     */
+    public ActivationFile getFile()
+    {
+        return this.file;
+    } //-- ActivationFile getFile()
+
+    /**
+     * Get specifies that this profile will be activated when a
+     * matching JDK is detected.
+     *             For example, <code>1.4</code> only activates on
+     * JDKs versioned 1.4,
+     *             while <code>!1.4</code> matches any JDK that is
+     * not version 1.4. Ranges are supported too:
+     *             <code>[1.5,)</code> activates when the JDK is
+     * 1.5 minimum.
+     * 
+     * @return String
+     */
+    public String getJdk()
+    {
+        return this.jdk;
+    } //-- String getJdk()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get specifies that this profile will be activated when
+     * matching operating system
+     *             attributes are detected.
+     * 
+     * @return ActivationOS
+     */
+    public ActivationOS getOs()
+    {
+        return this.os;
+    } //-- ActivationOS getOs()
+
+    /**
+     * Get specifies that this profile will be activated when this
+     * system property is
+     *             specified.
+     * 
+     * @return ActivationProperty
+     */
+    public ActivationProperty getProperty()
+    {
+        return this.property;
+    } //-- ActivationProperty getProperty()
+
+    /**
+     * Get if set to true, this profile will be active unless
+     * another profile in this
+     *             pom is activated using the command line -P
+     * option or by one of that profile's
+     *             activators.
+     * 
+     * @return boolean
+     */
+    public boolean isActiveByDefault()
+    {
+        return this.activeByDefault;
+    } //-- boolean isActiveByDefault()
+
+    /**
+     * Set if set to true, this profile will be active unless
+     * another profile in this
+     *             pom is activated using the command line -P
+     * option or by one of that profile's
+     *             activators.
+     * 
+     * @param activeByDefault
+     */
+    public void setActiveByDefault( boolean activeByDefault )
+    {
+        this.activeByDefault = activeByDefault;
+    } //-- void setActiveByDefault( boolean )
+
+    /**
+     * Set specifies that this profile will be activated based on
+     * existence of a file.
+     * 
+     * @param file
+     */
+    public void setFile( ActivationFile file )
+    {
+        this.file = file;
+    } //-- void setFile( ActivationFile )
+
+    /**
+     * Set specifies that this profile will be activated when a
+     * matching JDK is detected.
+     *             For example, <code>1.4</code> only activates on
+     * JDKs versioned 1.4,
+     *             while <code>!1.4</code> matches any JDK that is
+     * not version 1.4. Ranges are supported too:
+     *             <code>[1.5,)</code> activates when the JDK is
+     * 1.5 minimum.
+     * 
+     * @param jdk
+     */
+    public void setJdk( String jdk )
+    {
+        this.jdk = jdk;
+    } //-- void setJdk( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set specifies that this profile will be activated when
+     * matching operating system
+     *             attributes are detected.
+     * 
+     * @param os
+     */
+    public void setOs( ActivationOS os )
+    {
+        this.os = os;
+    } //-- void setOs( ActivationOS )
+
+    /**
+     * Set specifies that this profile will be activated when this
+     * system property is
+     *             specified.
+     * 
+     * @param property
+     */
+    public void setProperty( ActivationProperty property )
+    {
+        this.property = property;
+    } //-- void setProperty( ActivationProperty )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationFile.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationFile.java
new file mode 100644
index 0000000..363661b
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationFile.java
@@ -0,0 +1,152 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * This is the file specification used to activate the profile. The
+ * <code>missing</code> value
+ *         is the location of a file that needs to exist, and if it
+ * doesn't, the profile will be
+ *         activated. On the other hand, <code>exists</code> will
+ * test for the existence of the file and if it is
+ *         there, the profile will be activated.<br/>
+ *         Variable interpolation for these file specifications is
+ * limited to <code>${basedir}</code>,
+ *         System properties and request properties.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationFile
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name of the file that must be missing to activate the
+     *           profile.
+     */
+    private String missing;
+
+    /**
+     * The name of the file that must exist to activate the profile.
+     */
+    private String exists;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ActivationFile
+     */
+    public ActivationFile clone()
+    {
+        try
+        {
+            ActivationFile copy = (ActivationFile) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ActivationFile clone()
+
+    /**
+     * Get the name of the file that must exist to activate the
+     * profile.
+     * 
+     * @return String
+     */
+    public String getExists()
+    {
+        return this.exists;
+    } //-- String getExists()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the name of the file that must be missing to activate
+     * the
+     *           profile.
+     * 
+     * @return String
+     */
+    public String getMissing()
+    {
+        return this.missing;
+    } //-- String getMissing()
+
+    /**
+     * Set the name of the file that must exist to activate the
+     * profile.
+     * 
+     * @param exists
+     */
+    public void setExists( String exists )
+    {
+        this.exists = exists;
+    } //-- void setExists( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the name of the file that must be missing to activate
+     * the
+     *           profile.
+     * 
+     * @param missing
+     */
+    public void setMissing( String missing )
+    {
+        this.missing = missing;
+    } //-- void setMissing( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationOS.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationOS.java
new file mode 100644
index 0000000..16faad8
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationOS.java
@@ -0,0 +1,223 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * This is an activator which will detect an operating system's
+ * attributes in order
+ *         to activate its profile.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationOS
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The name of the operating system to be used to
+     * activate the profile. This must be an exact match
+     *             of the <code>${os.name}</code> Java property,
+     * such as <code>Windows XP</code>.
+     *             
+     *           
+     */
+    private String name;
+
+    /**
+     * 
+     *             
+     *             The general family of the OS to be used to
+     * activate the profile, such as
+     *             <code>windows</code> or <code>unix</code>.
+     *             
+     *           
+     */
+    private String family;
+
+    /**
+     * The architecture of the operating system to be used to
+     * activate the
+     *           profile.
+     */
+    private String arch;
+
+    /**
+     * The version of the operating system to be used to activate
+     * the
+     *           profile.
+     */
+    private String version;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ActivationOS
+     */
+    public ActivationOS clone()
+    {
+        try
+        {
+            ActivationOS copy = (ActivationOS) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ActivationOS clone()
+
+    /**
+     * Get the architecture of the operating system to be used to
+     * activate the
+     *           profile.
+     * 
+     * @return String
+     */
+    public String getArch()
+    {
+        return this.arch;
+    } //-- String getArch()
+
+    /**
+     * Get the general family of the OS to be used to activate the
+     * profile, such as
+     *             <code>windows</code> or <code>unix</code>.
+     * 
+     * @return String
+     */
+    public String getFamily()
+    {
+        return this.family;
+    } //-- String getFamily()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the name of the operating system to be used to activate
+     * the profile. This must be an exact match
+     *             of the <code>${os.name}</code> Java property,
+     * such as <code>Windows XP</code>.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the version of the operating system to be used to
+     * activate the
+     *           profile.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the architecture of the operating system to be used to
+     * activate the
+     *           profile.
+     * 
+     * @param arch
+     */
+    public void setArch( String arch )
+    {
+        this.arch = arch;
+    } //-- void setArch( String )
+
+    /**
+     * Set the general family of the OS to be used to activate the
+     * profile, such as
+     *             <code>windows</code> or <code>unix</code>.
+     * 
+     * @param family
+     */
+    public void setFamily( String family )
+    {
+        this.family = family;
+    } //-- void setFamily( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the name of the operating system to be used to activate
+     * the profile. This must be an exact match
+     *             of the <code>${os.name}</code> Java property,
+     * such as <code>Windows XP</code>.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the version of the operating system to be used to
+     * activate the
+     *           profile.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationProperty.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationProperty.java
new file mode 100644
index 0000000..e20a58a
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ActivationProperty.java
@@ -0,0 +1,145 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * This is the property specification used to activate a profile.
+ * If the value field
+ *         is empty, then the existence of the named property will
+ * activate the profile, otherwise it
+ *         does a case-sensitive match against the property value
+ * as well.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationProperty
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name of the property to be used to activate a profile.
+     */
+    private String name;
+
+    /**
+     * The value of the property required to activate a profile.
+     */
+    private String value;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ActivationProperty
+     */
+    public ActivationProperty clone()
+    {
+        try
+        {
+            ActivationProperty copy = (ActivationProperty) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ActivationProperty clone()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the name of the property to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the value of the property required to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getValue()
+    {
+        return this.value;
+    } //-- String getValue()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the name of the property to be used to activate a
+     * profile.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the value of the property required to activate a
+     * profile.
+     * 
+     * @param value
+     */
+    public void setValue( String value )
+    {
+        this.value = value;
+    } //-- void setValue( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Build.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Build.java
new file mode 100644
index 0000000..fd37f3d
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Build.java
@@ -0,0 +1,324 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;build&gt;</code> element contains
+ * informations required to build the project.
+ *         Default values are defined in Super POM.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Build
+    extends BuildBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             This element specifies a directory containing
+     * the source of the project. The
+     *             generated build system will compile the sources
+     * from this directory when the project is
+     *             built. The path given is relative to the project
+     * descriptor.
+     *             The default value is <code>src/main/java</code>.
+     *           
+     */
+    private String sourceDirectory;
+
+    /**
+     * 
+     *             This element specifies a directory containing
+     * the script sources of the
+     *             project. This directory is meant to be different
+     * from the sourceDirectory, in that its
+     *             contents will be copied to the output directory
+     * in most cases (since scripts are
+     *             interpreted rather than compiled).
+     *             The default value is
+     * <code>src/main/scripts</code>.
+     *           
+     */
+    private String scriptSourceDirectory;
+
+    /**
+     * 
+     *             This element specifies a directory containing
+     * the unit test source of the
+     *             project. The generated build system will compile
+     * these directories when the project is
+     *             being tested. The path given is relative to the
+     * project descriptor.
+     *             The default value is <code>src/test/java</code>.
+     *           
+     */
+    private String testSourceDirectory;
+
+    /**
+     * 
+     *             The directory where compiled application classes
+     * are placed.
+     *             The default value is
+     * <code>target/classes</code>.
+     *           
+     */
+    private String outputDirectory;
+
+    /**
+     * 
+     *             The directory where compiled test classes are
+     * placed.
+     *             The default value is
+     * <code>target/test-classes</code>.
+     *           
+     */
+    private String testOutputDirectory;
+
+    /**
+     * Field extensions.
+     */
+    private java.util.List<Extension> extensions;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExtension.
+     * 
+     * @param extension
+     */
+    public void addExtension( Extension extension )
+    {
+        getExtensions().add( extension );
+    } //-- void addExtension( Extension )
+
+    /**
+     * Method clone.
+     * 
+     * @return Build
+     */
+    public Build clone()
+    {
+        try
+        {
+            Build copy = (Build) super.clone();
+
+            if ( this.extensions != null )
+            {
+                copy.extensions = new java.util.ArrayList<Extension>();
+                for ( Extension item : this.extensions )
+                {
+                    copy.extensions.add( ( (Extension) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Build clone()
+
+    /**
+     * Method getExtensions.
+     * 
+     * @return List
+     */
+    public java.util.List<Extension> getExtensions()
+    {
+        if ( this.extensions == null )
+        {
+            this.extensions = new java.util.ArrayList<Extension>();
+        }
+
+        return this.extensions;
+    } //-- java.util.List<Extension> getExtensions()
+
+    /**
+     * Get the directory where compiled application classes are
+     * placed.
+     *             The default value is
+     * <code>target/classes</code>.
+     * 
+     * @return String
+     */
+    public String getOutputDirectory()
+    {
+        return this.outputDirectory;
+    } //-- String getOutputDirectory()
+
+    /**
+     * Get this element specifies a directory containing the script
+     * sources of the
+     *             project. This directory is meant to be different
+     * from the sourceDirectory, in that its
+     *             contents will be copied to the output directory
+     * in most cases (since scripts are
+     *             interpreted rather than compiled).
+     *             The default value is
+     * <code>src/main/scripts</code>.
+     * 
+     * @return String
+     */
+    public String getScriptSourceDirectory()
+    {
+        return this.scriptSourceDirectory;
+    } //-- String getScriptSourceDirectory()
+
+    /**
+     * Get this element specifies a directory containing the source
+     * of the project. The
+     *             generated build system will compile the sources
+     * from this directory when the project is
+     *             built. The path given is relative to the project
+     * descriptor.
+     *             The default value is <code>src/main/java</code>.
+     * 
+     * @return String
+     */
+    public String getSourceDirectory()
+    {
+        return this.sourceDirectory;
+    } //-- String getSourceDirectory()
+
+    /**
+     * Get the directory where compiled test classes are placed.
+     *             The default value is
+     * <code>target/test-classes</code>.
+     * 
+     * @return String
+     */
+    public String getTestOutputDirectory()
+    {
+        return this.testOutputDirectory;
+    } //-- String getTestOutputDirectory()
+
+    /**
+     * Get this element specifies a directory containing the unit
+     * test source of the
+     *             project. The generated build system will compile
+     * these directories when the project is
+     *             being tested. The path given is relative to the
+     * project descriptor.
+     *             The default value is <code>src/test/java</code>.
+     * 
+     * @return String
+     */
+    public String getTestSourceDirectory()
+    {
+        return this.testSourceDirectory;
+    } //-- String getTestSourceDirectory()
+
+    /**
+     * Method removeExtension.
+     * 
+     * @param extension
+     */
+    public void removeExtension( Extension extension )
+    {
+        getExtensions().remove( extension );
+    } //-- void removeExtension( Extension )
+
+    /**
+     * Set a set of build extensions to use from this project.
+     * 
+     * @param extensions
+     */
+    public void setExtensions( java.util.List<Extension> extensions )
+    {
+        this.extensions = extensions;
+    } //-- void setExtensions( java.util.List )
+
+    /**
+     * Set the directory where compiled application classes are
+     * placed.
+     *             The default value is
+     * <code>target/classes</code>.
+     * 
+     * @param outputDirectory
+     */
+    public void setOutputDirectory( String outputDirectory )
+    {
+        this.outputDirectory = outputDirectory;
+    } //-- void setOutputDirectory( String )
+
+    /**
+     * Set this element specifies a directory containing the script
+     * sources of the
+     *             project. This directory is meant to be different
+     * from the sourceDirectory, in that its
+     *             contents will be copied to the output directory
+     * in most cases (since scripts are
+     *             interpreted rather than compiled).
+     *             The default value is
+     * <code>src/main/scripts</code>.
+     * 
+     * @param scriptSourceDirectory
+     */
+    public void setScriptSourceDirectory( String scriptSourceDirectory )
+    {
+        this.scriptSourceDirectory = scriptSourceDirectory;
+    } //-- void setScriptSourceDirectory( String )
+
+    /**
+     * Set this element specifies a directory containing the source
+     * of the project. The
+     *             generated build system will compile the sources
+     * from this directory when the project is
+     *             built. The path given is relative to the project
+     * descriptor.
+     *             The default value is <code>src/main/java</code>.
+     * 
+     * @param sourceDirectory
+     */
+    public void setSourceDirectory( String sourceDirectory )
+    {
+        this.sourceDirectory = sourceDirectory;
+    } //-- void setSourceDirectory( String )
+
+    /**
+     * Set the directory where compiled test classes are placed.
+     *             The default value is
+     * <code>target/test-classes</code>.
+     * 
+     * @param testOutputDirectory
+     */
+    public void setTestOutputDirectory( String testOutputDirectory )
+    {
+        this.testOutputDirectory = testOutputDirectory;
+    } //-- void setTestOutputDirectory( String )
+
+    /**
+     * Set this element specifies a directory containing the unit
+     * test source of the
+     *             project. The generated build system will compile
+     * these directories when the project is
+     *             being tested. The path given is relative to the
+     * project descriptor.
+     *             The default value is <code>src/test/java</code>.
+     * 
+     * @param testSourceDirectory
+     */
+    public void setTestSourceDirectory( String testSourceDirectory )
+    {
+        this.testSourceDirectory = testSourceDirectory;
+    } //-- void setTestSourceDirectory( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/BuildBase.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/BuildBase.java
new file mode 100644
index 0000000..d88c920
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/BuildBase.java
@@ -0,0 +1,353 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Generic informations for a build.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class BuildBase
+    extends PluginConfiguration
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The default goal (or phase in Maven 2) to execute when none
+     * is specified for
+     *             the project. Note that in case of a multi-module
+     * build, only the default goal of the top-level
+     *             project is relevant, i.e. the default goals of
+     * child modules are ignored. Since Maven 3,
+     *             multiple goals/phases can be separated by
+     * whitespace.
+     */
+    private String defaultGoal;
+
+    /**
+     * Field resources.
+     */
+    private java.util.List<Resource> resources;
+
+    /**
+     * Field testResources.
+     */
+    private java.util.List<Resource> testResources;
+
+    /**
+     * 
+     *             The directory where all files generated by the
+     * build are placed.
+     *             The default value is <code>target</code>.
+     *           
+     */
+    private String directory;
+
+    /**
+     * 
+     *             
+     *             The filename (excluding the extension, and with
+     * no path information) that
+     *             the produced artifact will be called.
+     *             The default value is
+     * <code>${artifactId}-${version}</code>.
+     *             
+     *           
+     */
+    private String finalName;
+
+    /**
+     * Field filters.
+     */
+    private java.util.List<String> filters;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addFilter.
+     * 
+     * @param string
+     */
+    public void addFilter( String string )
+    {
+        getFilters().add( string );
+    } //-- void addFilter( String )
+
+    /**
+     * Method addResource.
+     * 
+     * @param resource
+     */
+    public void addResource( Resource resource )
+    {
+        getResources().add( resource );
+    } //-- void addResource( Resource )
+
+    /**
+     * Method addTestResource.
+     * 
+     * @param resource
+     */
+    public void addTestResource( Resource resource )
+    {
+        getTestResources().add( resource );
+    } //-- void addTestResource( Resource )
+
+    /**
+     * Method clone.
+     * 
+     * @return BuildBase
+     */
+    public BuildBase clone()
+    {
+        try
+        {
+            BuildBase copy = (BuildBase) super.clone();
+
+            if ( this.resources != null )
+            {
+                copy.resources = new java.util.ArrayList<Resource>();
+                for ( Resource item : this.resources )
+                {
+                    copy.resources.add( ( (Resource) item).clone() );
+                }
+            }
+
+            if ( this.testResources != null )
+            {
+                copy.testResources = new java.util.ArrayList<Resource>();
+                for ( Resource item : this.testResources )
+                {
+                    copy.testResources.add( ( (Resource) item).clone() );
+                }
+            }
+
+            if ( this.filters != null )
+            {
+                copy.filters = new java.util.ArrayList<String>();
+                copy.filters.addAll( this.filters );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- BuildBase clone()
+
+    /**
+     * Get the default goal (or phase in Maven 2) to execute when
+     * none is specified for
+     *             the project. Note that in case of a multi-module
+     * build, only the default goal of the top-level
+     *             project is relevant, i.e. the default goals of
+     * child modules are ignored. Since Maven 3,
+     *             multiple goals/phases can be separated by
+     * whitespace.
+     * 
+     * @return String
+     */
+    public String getDefaultGoal()
+    {
+        return this.defaultGoal;
+    } //-- String getDefaultGoal()
+
+    /**
+     * Get the directory where all files generated by the build are
+     * placed.
+     *             The default value is <code>target</code>.
+     * 
+     * @return String
+     */
+    public String getDirectory()
+    {
+        return this.directory;
+    } //-- String getDirectory()
+
+    /**
+     * Method getFilters.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getFilters()
+    {
+        if ( this.filters == null )
+        {
+            this.filters = new java.util.ArrayList<String>();
+        }
+
+        return this.filters;
+    } //-- java.util.List<String> getFilters()
+
+    /**
+     * Get the filename (excluding the extension, and with no path
+     * information) that
+     *             the produced artifact will be called.
+     *             The default value is
+     * <code>${artifactId}-${version}</code>.
+     * 
+     * @return String
+     */
+    public String getFinalName()
+    {
+        return this.finalName;
+    } //-- String getFinalName()
+
+    /**
+     * Method getResources.
+     * 
+     * @return List
+     */
+    public java.util.List<Resource> getResources()
+    {
+        if ( this.resources == null )
+        {
+            this.resources = new java.util.ArrayList<Resource>();
+        }
+
+        return this.resources;
+    } //-- java.util.List<Resource> getResources()
+
+    /**
+     * Method getTestResources.
+     * 
+     * @return List
+     */
+    public java.util.List<Resource> getTestResources()
+    {
+        if ( this.testResources == null )
+        {
+            this.testResources = new java.util.ArrayList<Resource>();
+        }
+
+        return this.testResources;
+    } //-- java.util.List<Resource> getTestResources()
+
+    /**
+     * Method removeFilter.
+     * 
+     * @param string
+     */
+    public void removeFilter( String string )
+    {
+        getFilters().remove( string );
+    } //-- void removeFilter( String )
+
+    /**
+     * Method removeResource.
+     * 
+     * @param resource
+     */
+    public void removeResource( Resource resource )
+    {
+        getResources().remove( resource );
+    } //-- void removeResource( Resource )
+
+    /**
+     * Method removeTestResource.
+     * 
+     * @param resource
+     */
+    public void removeTestResource( Resource resource )
+    {
+        getTestResources().remove( resource );
+    } //-- void removeTestResource( Resource )
+
+    /**
+     * Set the default goal (or phase in Maven 2) to execute when
+     * none is specified for
+     *             the project. Note that in case of a multi-module
+     * build, only the default goal of the top-level
+     *             project is relevant, i.e. the default goals of
+     * child modules are ignored. Since Maven 3,
+     *             multiple goals/phases can be separated by
+     * whitespace.
+     * 
+     * @param defaultGoal
+     */
+    public void setDefaultGoal( String defaultGoal )
+    {
+        this.defaultGoal = defaultGoal;
+    } //-- void setDefaultGoal( String )
+
+    /**
+     * Set the directory where all files generated by the build are
+     * placed.
+     *             The default value is <code>target</code>.
+     * 
+     * @param directory
+     */
+    public void setDirectory( String directory )
+    {
+        this.directory = directory;
+    } //-- void setDirectory( String )
+
+    /**
+     * Set the list of filter properties files that are used when
+     * filtering is enabled.
+     * 
+     * @param filters
+     */
+    public void setFilters( java.util.List<String> filters )
+    {
+        this.filters = filters;
+    } //-- void setFilters( java.util.List )
+
+    /**
+     * Set the filename (excluding the extension, and with no path
+     * information) that
+     *             the produced artifact will be called.
+     *             The default value is
+     * <code>${artifactId}-${version}</code>.
+     * 
+     * @param finalName
+     */
+    public void setFinalName( String finalName )
+    {
+        this.finalName = finalName;
+    } //-- void setFinalName( String )
+
+    /**
+     * Set this element describes all of the classpath resources
+     * such as properties
+     *             files associated with a project. These resources
+     * are often included in the final
+     *             package.
+     *             The default value is
+     * <code>src/main/resources</code>.
+     * 
+     * @param resources
+     */
+    public void setResources( java.util.List<Resource> resources )
+    {
+        this.resources = resources;
+    } //-- void setResources( java.util.List )
+
+    /**
+     * Set this element describes all of the classpath resources
+     * such as properties
+     *             files associated with a project's unit tests.
+     *             The default value is
+     * <code>src/test/resources</code>.
+     * 
+     * @param testResources
+     */
+    public void setTestResources( java.util.List<Resource> testResources )
+    {
+        this.testResources = testResources;
+    } //-- void setTestResources( java.util.List )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/CiManagement.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/CiManagement.java
new file mode 100644
index 0000000..9326e6a
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/CiManagement.java
@@ -0,0 +1,217 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;CiManagement&gt;</code> element contains
+ * informations required to the
+ *         continuous integration system of the project.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class CiManagement
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The name of the continuous integration system,
+     * e.g. <code>continuum</code>.
+     *             
+     *           
+     */
+    private String system;
+
+    /**
+     * URL for the continuous integration system used by the
+     * project if it has a web
+     *             interface.
+     */
+    private String url;
+
+    /**
+     * Field notifiers.
+     */
+    private java.util.List<Notifier> notifiers;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addNotifier.
+     * 
+     * @param notifier
+     */
+    public void addNotifier( Notifier notifier )
+    {
+        getNotifiers().add( notifier );
+    } //-- void addNotifier( Notifier )
+
+    /**
+     * Method clone.
+     * 
+     * @return CiManagement
+     */
+    public CiManagement clone()
+    {
+        try
+        {
+            CiManagement copy = (CiManagement) super.clone();
+
+            if ( this.notifiers != null )
+            {
+                copy.notifiers = new java.util.ArrayList<Notifier>();
+                for ( Notifier item : this.notifiers )
+                {
+                    copy.notifiers.add( ( (Notifier) item).clone() );
+                }
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- CiManagement clone()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Method getNotifiers.
+     * 
+     * @return List
+     */
+    public java.util.List<Notifier> getNotifiers()
+    {
+        if ( this.notifiers == null )
+        {
+            this.notifiers = new java.util.ArrayList<Notifier>();
+        }
+
+        return this.notifiers;
+    } //-- java.util.List<Notifier> getNotifiers()
+
+    /**
+     * Get the name of the continuous integration system, e.g.
+     * <code>continuum</code>.
+     * 
+     * @return String
+     */
+    public String getSystem()
+    {
+        return this.system;
+    } //-- String getSystem()
+
+    /**
+     * Get uRL for the continuous integration system used by the
+     * project if it has a web
+     *             interface.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Method removeNotifier.
+     * 
+     * @param notifier
+     */
+    public void removeNotifier( Notifier notifier )
+    {
+        getNotifiers().remove( notifier );
+    } //-- void removeNotifier( Notifier )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set configuration for notifying developers/users when a
+     * build is unsuccessful,
+     *             including user information and notification
+     * mode.
+     * 
+     * @param notifiers
+     */
+    public void setNotifiers( java.util.List<Notifier> notifiers )
+    {
+        this.notifiers = notifiers;
+    } //-- void setNotifiers( java.util.List )
+
+    /**
+     * Set the name of the continuous integration system, e.g.
+     * <code>continuum</code>.
+     * 
+     * @param system
+     */
+    public void setSystem( String system )
+    {
+        this.system = system;
+    } //-- void setSystem( String )
+
+    /**
+     * Set uRL for the continuous integration system used by the
+     * project if it has a web
+     *             interface.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ConfigurationContainer.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ConfigurationContainer.java
new file mode 100644
index 0000000..9e501d7
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ConfigurationContainer.java
@@ -0,0 +1,259 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Contains the configuration information of the container like
+ * Plugin.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ConfigurationContainer
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             Whether any configuration should be propagated
+     * to child POMs. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>true</code>.
+     *             
+     *           
+     */
+    private String inherited;
+
+    /**
+     * 
+     *             
+     *             <p>The configuration as DOM object.</p>
+     *             <p>By default, every element content is trimmed,
+     * but starting with Maven 3.1.0, you can add
+     *             <code>xml:space="preserve"</code> to elements
+     * you want to preserve whitespace.</p>
+     *             <p>You can control how child POMs inherit
+     * configuration from parent POMs by adding
+     * <code>combine.children</code>
+     *             or <code>combine.self</code> attributes to the
+     * children of the configuration element:</p>
+     *             <ul>
+     *             <li><code>combine.children</code>: available
+     * values are <code>merge</code> (default) and
+     * <code>append</code>,</li>
+     *             <li><code>combine.self</code>: available values
+     * are <code>merge</code> (default) and
+     * <code>override</code>.</li>
+     *             </ul>
+     *             <p>See <a
+     * href="http://maven.apache.org/pom.html#Plugins">POM
+     * Reference documentation</a> and
+     *             <a
+     * href="http://plexus.codehaus.org/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
+     *             for more information.</p>
+     *             
+     *           
+     */
+    private Object configuration;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ConfigurationContainer
+     */
+    public ConfigurationContainer clone()
+    {
+        try
+        {
+            ConfigurationContainer copy = (ConfigurationContainer) super.clone();
+
+            if ( this.configuration != null )
+            {
+                copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ConfigurationContainer clone()
+
+    /**
+     * Get <p>The configuration as DOM object.</p>
+     *             <p>By default, every element content is trimmed,
+     * but starting with Maven 3.1.0, you can add
+     *             <code>xml:space="preserve"</code> to elements
+     * you want to preserve whitespace.</p>
+     *             <p>You can control how child POMs inherit
+     * configuration from parent POMs by adding
+     * <code>combine.children</code>
+     *             or <code>combine.self</code> attributes to the
+     * children of the configuration element:</p>
+     *             <ul>
+     *             <li><code>combine.children</code>: available
+     * values are <code>merge</code> (default) and
+     * <code>append</code>,</li>
+     *             <li><code>combine.self</code>: available values
+     * are <code>merge</code> (default) and
+     * <code>override</code>.</li>
+     *             </ul>
+     *             <p>See <a
+     * href="http://maven.apache.org/pom.html#Plugins">POM
+     * Reference documentation</a> and
+     *             <a
+     * href="http://plexus.codehaus.org/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
+     *             for more information.</p>
+     * 
+     * @return Object
+     */
+    public Object getConfiguration()
+    {
+        return this.configuration;
+    } //-- Object getConfiguration()
+
+    /**
+     * Get whether any configuration should be propagated to child
+     * POMs. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>true</code>.
+     * 
+     * @return String
+     */
+    public String getInherited()
+    {
+        return this.inherited;
+    } //-- String getInherited()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Set <p>The configuration as DOM object.</p>
+     *             <p>By default, every element content is trimmed,
+     * but starting with Maven 3.1.0, you can add
+     *             <code>xml:space="preserve"</code> to elements
+     * you want to preserve whitespace.</p>
+     *             <p>You can control how child POMs inherit
+     * configuration from parent POMs by adding
+     * <code>combine.children</code>
+     *             or <code>combine.self</code> attributes to the
+     * children of the configuration element:</p>
+     *             <ul>
+     *             <li><code>combine.children</code>: available
+     * values are <code>merge</code> (default) and
+     * <code>append</code>,</li>
+     *             <li><code>combine.self</code>: available values
+     * are <code>merge</code> (default) and
+     * <code>override</code>.</li>
+     *             </ul>
+     *             <p>See <a
+     * href="http://maven.apache.org/pom.html#Plugins">POM
+     * Reference documentation</a> and
+     *             <a
+     * href="http://plexus.codehaus.org/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
+     *             for more information.</p>
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( Object configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( Object )
+
+    /**
+     * Set whether any configuration should be propagated to child
+     * POMs. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>true</code>.
+     * 
+     * @param inherited
+     */
+    public void setInherited( String inherited )
+    {
+        this.inherited = inherited;
+    } //-- void setInherited( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    
+            
+    public boolean isInherited()
+    {
+        return ( inherited != null ) ? Boolean.parseBoolean( inherited ) : true;
+    }
+
+    public void setInherited( boolean inherited )
+    {
+        this.inherited = String.valueOf( inherited );
+    }
+
+    private boolean inheritanceApplied = true;
+
+    public void unsetInheritanceApplied()
+    {
+        this.inheritanceApplied = false;
+    }
+
+    public boolean isInheritanceApplied()
+    {
+        return inheritanceApplied;
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Contributor.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Contributor.java
new file mode 100644
index 0000000..78c1c63
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Contributor.java
@@ -0,0 +1,374 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Description of a person who has contributed to the project, but
+ * who does not have
+ *         commit privileges. Usually, these contributions come in
+ * the form of patches submitted.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Contributor
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The full name of the contributor.
+     */
+    private String name;
+
+    /**
+     * The email address of the contributor.
+     */
+    private String email;
+
+    /**
+     * The URL for the homepage of the contributor.
+     */
+    private String url;
+
+    /**
+     * The organization to which the contributor belongs.
+     */
+    private String organization;
+
+    /**
+     * The URL of the organization.
+     */
+    private String organizationUrl;
+
+    /**
+     * Field roles.
+     */
+    private java.util.List<String> roles;
+
+    /**
+     * 
+     *             
+     *               The timezone the contributor is in. Typically,
+     * this is a number in the range
+     *               <a
+     * href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a>
+     * to <a
+     * href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>
+     *               or a valid time zone id like
+     * "America/Montreal" (UTC-05:00) or "Europe/Paris"
+     * (UTC+01:00).
+     *             
+     *           
+     */
+    private String timezone;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addRole.
+     * 
+     * @param string
+     */
+    public void addRole( String string )
+    {
+        getRoles().add( string );
+    } //-- void addRole( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return Contributor
+     */
+    public Contributor clone()
+    {
+        try
+        {
+            Contributor copy = (Contributor) super.clone();
+
+            if ( this.roles != null )
+            {
+                copy.roles = new java.util.ArrayList<String>();
+                copy.roles.addAll( this.roles );
+            }
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Contributor clone()
+
+    /**
+     * Get the email address of the contributor.
+     * 
+     * @return String
+     */
+    public String getEmail()
+    {
+        return this.email;
+    } //-- String getEmail()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the full name of the contributor.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the organization to which the contributor belongs.
+     * 
+     * @return String
+     */
+    public String getOrganization()
+    {
+        return this.organization;
+    } //-- String getOrganization()
+
+    /**
+     * Get the URL of the organization.
+     * 
+     * @return String
+     */
+    public String getOrganizationUrl()
+    {
+        return this.organizationUrl;
+    } //-- String getOrganizationUrl()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Method getRoles.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getRoles()
+    {
+        if ( this.roles == null )
+        {
+            this.roles = new java.util.ArrayList<String>();
+        }
+
+        return this.roles;
+    } //-- java.util.List<String> getRoles()
+
+    /**
+     * Get the timezone the contributor is in. Typically, this is a
+     * number in the range
+     *               <a
+     * href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a>
+     * to <a
+     * href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>
+     *               or a valid time zone id like
+     * "America/Montreal" (UTC-05:00) or "Europe/Paris"
+     * (UTC+01:00).
+     * 
+     * @return String
+     */
+    public String getTimezone()
+    {
+        return this.timezone;
+    } //-- String getTimezone()
+
+    /**
+     * Get the URL for the homepage of the contributor.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Method removeRole.
+     * 
+     * @param string
+     */
+    public void removeRole( String string )
+    {
+        getRoles().remove( string );
+    } //-- void removeRole( String )
+
+    /**
+     * Set the email address of the contributor.
+     * 
+     * @param email
+     */
+    public void setEmail( String email )
+    {
+        this.email = email;
+    } //-- void setEmail( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the full name of the contributor.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the organization to which the contributor belongs.
+     * 
+     * @param organization
+     */
+    public void setOrganization( String organization )
+    {
+        this.organization = organization;
+    } //-- void setOrganization( String )
+
+    /**
+     * Set the URL of the organization.
+     * 
+     * @param organizationUrl
+     */
+    public void setOrganizationUrl( String organizationUrl )
+    {
+        this.organizationUrl = organizationUrl;
+    } //-- void setOrganizationUrl( String )
+
+    /**
+     * Set properties about the contributor, such as an instant
+     * messenger handle.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set the roles the contributor plays in the project. Each
+     * role is described by a
+     *             <code>role</code> element, the body of which is
+     * a role name. This can also be used to
+     *             describe the contribution.
+     * 
+     * @param roles
+     */
+    public void setRoles( java.util.List<String> roles )
+    {
+        this.roles = roles;
+    } //-- void setRoles( java.util.List )
+
+    /**
+     * Set the timezone the contributor is in. Typically, this is a
+     * number in the range
+     *               <a
+     * href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a>
+     * to <a
+     * href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>
+     *               or a valid time zone id like
+     * "America/Montreal" (UTC-05:00) or "Europe/Paris"
+     * (UTC+01:00).
+     * 
+     * @param timezone
+     */
+    public void setTimezone( String timezone )
+    {
+        this.timezone = timezone;
+    } //-- void setTimezone( String )
+
+    /**
+     * Set the URL for the homepage of the contributor.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Dependency.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Dependency.java
new file mode 100644
index 0000000..82bc549
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Dependency.java
@@ -0,0 +1,615 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;dependency&gt;</code> element contains
+ * information about a dependency
+ *         of the project.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Dependency
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The project group that produced the dependency,
+     * e.g.
+     *             <code>org.apache.maven</code>.
+     *             
+     *           
+     */
+    private String groupId;
+
+    /**
+     * 
+     *             
+     *             The unique id for an artifact produced by the
+     * project group, e.g.
+     *             <code>maven-artifact</code>.
+     *             
+     *           
+     */
+    private String artifactId;
+
+    /**
+     * 
+     *             
+     *             The version of the dependency, e.g.
+     * <code>3.2.1</code>. In Maven 2, this can also be
+     *             specified as a range of versions.
+     *             
+     *           
+     */
+    private String version;
+
+    /**
+     * 
+     *             
+     *             The type of dependency. While it
+     *             usually represents the extension on the filename
+     * of the dependency,
+     *             that is not always the case. A type can be
+     * mapped to a different
+     *             extension and a classifier.
+     *             The type often corresponds to the packaging
+     * used, though this is also
+     *             not always the case.
+     *             Some examples are <code>jar</code>,
+     * <code>war</code>, <code>ejb-client</code>
+     *             and <code>test-jar</code>: see <a
+     * href="../maven-core/artifact-handlers.html">default
+     *             artifact handlers</a> for a list.
+     *             New types can be defined by plugins that set
+     *             <code>extensions</code> to <code>true</code>, so
+     * this is not a complete list.
+     *             
+     *           
+     */
+    private String type = "jar";
+
+    /**
+     * 
+     *             
+     *             The classifier of the dependency. It is appended
+     * to
+     *             the filename after the version. This allows:
+     *             <ul>
+     *             <li>refering to attached artifact, for example
+     * <code>sources</code> and <code>javadoc</code>:
+     *             see <a
+     * href="../maven-core/artifact-handlers.html">default artifact
+     * handlers</a> for a list,</li>
+     *             <li>distinguishing two artifacts
+     *             that belong to the same POM but were built
+     * differently.
+     *             For example, <code>jdk14</code> and
+     * <code>jdk15</code>.</li>
+     *             </ul>
+     *             
+     *           
+     */
+    private String classifier;
+
+    /**
+     * 
+     *             
+     *             The scope of the dependency -
+     * <code>compile</code>, <code>runtime</code>,
+     *             <code>test</code>, <code>system</code>, and
+     * <code>provided</code>. Used to
+     *             calculate the various classpaths used for
+     * compilation, testing, and so on.
+     *             It also assists in determining which artifacts
+     * to include in a distribution of
+     *             this project. For more information, see
+     *             <a
+     * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
+     *             dependency mechanism</a>.
+     *             
+     *           
+     */
+    private String scope;
+
+    /**
+     * 
+     *             
+     *             FOR SYSTEM SCOPE ONLY. Note that use of this
+     * property is <b>discouraged</b>
+     *             and may be replaced in later versions. This
+     * specifies the path on the filesystem
+     *             for this dependency.
+     *             Requires an absolute path for the value, not
+     * relative.
+     *             Use a property that gives the machine specific
+     * absolute path,
+     *             e.g. <code>${java.home}</code>.
+     *             
+     *           
+     */
+    private String systemPath;
+
+    /**
+     * Field exclusions.
+     */
+    private java.util.List<Exclusion> exclusions;
+
+    /**
+     * 
+     *             
+     *             Indicates the dependency is optional for use of
+     * this library. While the
+     *             version of the dependency will be taken into
+     * account for dependency calculation if the
+     *             library is used elsewhere, it will not be passed
+     * on transitively. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     *             
+     *           
+     */
+    private String optional;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExclusion.
+     * 
+     * @param exclusion
+     */
+    public void addExclusion( Exclusion exclusion )
+    {
+        getExclusions().add( exclusion );
+    } //-- void addExclusion( Exclusion )
+
+    /**
+     * Method clone.
+     * 
+     * @return Dependency
+     */
+    public Dependency clone()
+    {
+        try
+        {
+            Dependency copy = (Dependency) super.clone();
+
+            if ( this.exclusions != null )
+            {
+                copy.exclusions = new java.util.ArrayList<Exclusion>();
+                for ( Exclusion item : this.exclusions )
+                {
+                    copy.exclusions.add( ( (Exclusion) item).clone() );
+                }
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Dependency clone()
+
+    /**
+     * Get the unique id for an artifact produced by the project
+     * group, e.g.
+     *             <code>maven-artifact</code>.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the classifier of the dependency. It is appended to
+     *             the filename after the version. This allows:
+     *             <ul>
+     *             <li>refering to attached artifact, for example
+     * <code>sources</code> and <code>javadoc</code>:
+     *             see <a
+     * href="../maven-core/artifact-handlers.html">default artifact
+     * handlers</a> for a list,</li>
+     *             <li>distinguishing two artifacts
+     *             that belong to the same POM but were built
+     * differently.
+     *             For example, <code>jdk14</code> and
+     * <code>jdk15</code>.</li>
+     *             </ul>
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Method getExclusions.
+     * 
+     * @return List
+     */
+    public java.util.List<Exclusion> getExclusions()
+    {
+        if ( this.exclusions == null )
+        {
+            this.exclusions = new java.util.ArrayList<Exclusion>();
+        }
+
+        return this.exclusions;
+    } //-- java.util.List<Exclusion> getExclusions()
+
+    /**
+     * Get the project group that produced the dependency, e.g.
+     *             <code>org.apache.maven</code>.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get indicates the dependency is optional for use of this
+     * library. While the
+     *             version of the dependency will be taken into
+     * account for dependency calculation if the
+     *             library is used elsewhere, it will not be passed
+     * on transitively. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @return String
+     */
+    public String getOptional()
+    {
+        return this.optional;
+    } //-- String getOptional()
+
+    /**
+     * Get the scope of the dependency - <code>compile</code>,
+     * <code>runtime</code>,
+     *             <code>test</code>, <code>system</code>, and
+     * <code>provided</code>. Used to
+     *             calculate the various classpaths used for
+     * compilation, testing, and so on.
+     *             It also assists in determining which artifacts
+     * to include in a distribution of
+     *             this project. For more information, see
+     *             <a
+     * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
+     *             dependency mechanism</a>.
+     * 
+     * @return String
+     */
+    public String getScope()
+    {
+        return this.scope;
+    } //-- String getScope()
+
+    /**
+     * Get fOR SYSTEM SCOPE ONLY. Note that use of this property is
+     * <b>discouraged</b>
+     *             and may be replaced in later versions. This
+     * specifies the path on the filesystem
+     *             for this dependency.
+     *             Requires an absolute path for the value, not
+     * relative.
+     *             Use a property that gives the machine specific
+     * absolute path,
+     *             e.g. <code>${java.home}</code>.
+     * 
+     * @return String
+     */
+    public String getSystemPath()
+    {
+        return this.systemPath;
+    } //-- String getSystemPath()
+
+    /**
+     * Get the type of dependency. While it
+     *             usually represents the extension on the filename
+     * of the dependency,
+     *             that is not always the case. A type can be
+     * mapped to a different
+     *             extension and a classifier.
+     *             The type often corresponds to the packaging
+     * used, though this is also
+     *             not always the case.
+     *             Some examples are <code>jar</code>,
+     * <code>war</code>, <code>ejb-client</code>
+     *             and <code>test-jar</code>: see <a
+     * href="../maven-core/artifact-handlers.html">default
+     *             artifact handlers</a> for a list.
+     *             New types can be defined by plugins that set
+     *             <code>extensions</code> to <code>true</code>, so
+     * this is not a complete list.
+     * 
+     * @return String
+     */
+    public String getType()
+    {
+        return this.type;
+    } //-- String getType()
+
+    /**
+     * Get the version of the dependency, e.g. <code>3.2.1</code>.
+     * In Maven 2, this can also be
+     *             specified as a range of versions.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Method removeExclusion.
+     * 
+     * @param exclusion
+     */
+    public void removeExclusion( Exclusion exclusion )
+    {
+        getExclusions().remove( exclusion );
+    } //-- void removeExclusion( Exclusion )
+
+    /**
+     * Set the unique id for an artifact produced by the project
+     * group, e.g.
+     *             <code>maven-artifact</code>.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the classifier of the dependency. It is appended to
+     *             the filename after the version. This allows:
+     *             <ul>
+     *             <li>refering to attached artifact, for example
+     * <code>sources</code> and <code>javadoc</code>:
+     *             see <a
+     * href="../maven-core/artifact-handlers.html">default artifact
+     * handlers</a> for a list,</li>
+     *             <li>distinguishing two artifacts
+     *             that belong to the same POM but were built
+     * differently.
+     *             For example, <code>jdk14</code> and
+     * <code>jdk15</code>.</li>
+     *             </ul>
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set lists a set of artifacts that should be excluded from
+     * this dependency's
+     *             artifact list when it comes to calculating
+     * transitive dependencies.
+     * 
+     * @param exclusions
+     */
+    public void setExclusions( java.util.List<Exclusion> exclusions )
+    {
+        this.exclusions = exclusions;
+    } //-- void setExclusions( java.util.List )
+
+    /**
+     * Set the project group that produced the dependency, e.g.
+     *             <code>org.apache.maven</code>.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set indicates the dependency is optional for use of this
+     * library. While the
+     *             version of the dependency will be taken into
+     * account for dependency calculation if the
+     *             library is used elsewhere, it will not be passed
+     * on transitively. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @param optional
+     */
+    public void setOptional( String optional )
+    {
+        this.optional = optional;
+    } //-- void setOptional( String )
+
+    /**
+     * Set the scope of the dependency - <code>compile</code>,
+     * <code>runtime</code>,
+     *             <code>test</code>, <code>system</code>, and
+     * <code>provided</code>. Used to
+     *             calculate the various classpaths used for
+     * compilation, testing, and so on.
+     *             It also assists in determining which artifacts
+     * to include in a distribution of
+     *             this project. For more information, see
+     *             <a
+     * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
+     *             dependency mechanism</a>.
+     * 
+     * @param scope
+     */
+    public void setScope( String scope )
+    {
+        this.scope = scope;
+    } //-- void setScope( String )
+
+    /**
+     * Set fOR SYSTEM SCOPE ONLY. Note that use of this property is
+     * <b>discouraged</b>
+     *             and may be replaced in later versions. This
+     * specifies the path on the filesystem
+     *             for this dependency.
+     *             Requires an absolute path for the value, not
+     * relative.
+     *             Use a property that gives the machine specific
+     * absolute path,
+     *             e.g. <code>${java.home}</code>.
+     * 
+     * @param systemPath
+     */
+    public void setSystemPath( String systemPath )
+    {
+        this.systemPath = systemPath;
+    } //-- void setSystemPath( String )
+
+    /**
+     * Set the type of dependency. While it
+     *             usually represents the extension on the filename
+     * of the dependency,
+     *             that is not always the case. A type can be
+     * mapped to a different
+     *             extension and a classifier.
+     *             The type often corresponds to the packaging
+     * used, though this is also
+     *             not always the case.
+     *             Some examples are <code>jar</code>,
+     * <code>war</code>, <code>ejb-client</code>
+     *             and <code>test-jar</code>: see <a
+     * href="../maven-core/artifact-handlers.html">default
+     *             artifact handlers</a> for a list.
+     *             New types can be defined by plugins that set
+     *             <code>extensions</code> to <code>true</code>, so
+     * this is not a complete list.
+     * 
+     * @param type
+     */
+    public void setType( String type )
+    {
+        this.type = type;
+    } //-- void setType( String )
+
+    /**
+     * Set the version of the dependency, e.g. <code>3.2.1</code>.
+     * In Maven 2, this can also be
+     *             specified as a range of versions.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    public boolean isOptional()
+    {
+        return ( optional != null ) ? Boolean.parseBoolean( optional ) : false;
+    }
+
+    public void setOptional( boolean optional )
+    {
+        this.optional = String.valueOf( optional );
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString()
+    {
+        return "Dependency {groupId=" + groupId + ", artifactId=" + artifactId + ", version=" + version + ", type=" + type + "}";
+    }
+            
+          
+    
+            
+    private String managementKey;
+
+    /**
+     * @return the management key as <code>groupId:artifactId:type</code>
+     */
+    public String getManagementKey()
+    {
+        if ( managementKey == null )
+        {
+            managementKey = groupId + ":" + artifactId + ":" + type + ( classifier != null ? ":" + classifier : "" );
+        }
+        return managementKey;
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/DependencyManagement.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/DependencyManagement.java
new file mode 100644
index 0000000..2d6df85
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/DependencyManagement.java
@@ -0,0 +1,151 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Section for management of default dependency information for use
+ * in a group of
+ *         POMs.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class DependencyManagement
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field dependencies.
+     */
+    private java.util.List<Dependency> dependencies;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addDependency.
+     * 
+     * @param dependency
+     */
+    public void addDependency( Dependency dependency )
+    {
+        getDependencies().add( dependency );
+    } //-- void addDependency( Dependency )
+
+    /**
+     * Method clone.
+     * 
+     * @return DependencyManagement
+     */
+    public DependencyManagement clone()
+    {
+        try
+        {
+            DependencyManagement copy = (DependencyManagement) super.clone();
+
+            if ( this.dependencies != null )
+            {
+                copy.dependencies = new java.util.ArrayList<Dependency>();
+                for ( Dependency item : this.dependencies )
+                {
+                    copy.dependencies.add( ( (Dependency) item).clone() );
+                }
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- DependencyManagement clone()
+
+    /**
+     * Method getDependencies.
+     * 
+     * @return List
+     */
+    public java.util.List<Dependency> getDependencies()
+    {
+        if ( this.dependencies == null )
+        {
+            this.dependencies = new java.util.ArrayList<Dependency>();
+        }
+
+        return this.dependencies;
+    } //-- java.util.List<Dependency> getDependencies()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Method removeDependency.
+     * 
+     * @param dependency
+     */
+    public void removeDependency( Dependency dependency )
+    {
+        getDependencies().remove( dependency );
+    } //-- void removeDependency( Dependency )
+
+    /**
+     * Set the dependencies specified here are not used until they
+     * are referenced in a
+     *             POM within the group. This allows the
+     * specification of a "standard" version for a
+     *             particular dependency.
+     * 
+     * @param dependencies
+     */
+    public void setDependencies( java.util.List<Dependency> dependencies )
+    {
+        this.dependencies = dependencies;
+    } //-- void setDependencies( java.util.List )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/DeploymentRepository.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/DeploymentRepository.java
new file mode 100644
index 0000000..76c2ec4
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/DeploymentRepository.java
@@ -0,0 +1,84 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Repository contains the information needed for deploying to the
+ * remote
+ *         repository.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class DeploymentRepository
+    extends Repository
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Whether to assign snapshots a unique version comprised of
+     * the timestamp and
+     *             build number, or to use the same version each
+     * time.
+     */
+    private boolean uniqueVersion = true;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return DeploymentRepository
+     */
+    public DeploymentRepository clone()
+    {
+        try
+        {
+            DeploymentRepository copy = (DeploymentRepository) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- DeploymentRepository clone()
+
+    /**
+     * Get whether to assign snapshots a unique version comprised
+     * of the timestamp and
+     *             build number, or to use the same version each
+     * time.
+     * 
+     * @return boolean
+     */
+    public boolean isUniqueVersion()
+    {
+        return this.uniqueVersion;
+    } //-- boolean isUniqueVersion()
+
+    /**
+     * Set whether to assign snapshots a unique version comprised
+     * of the timestamp and
+     *             build number, or to use the same version each
+     * time.
+     * 
+     * @param uniqueVersion
+     */
+    public void setUniqueVersion( boolean uniqueVersion )
+    {
+        this.uniqueVersion = uniqueVersion;
+    } //-- void setUniqueVersion( boolean )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Developer.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Developer.java
new file mode 100644
index 0000000..b2a5577
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Developer.java
@@ -0,0 +1,73 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Information about one of the committers on this project.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Developer
+    extends Contributor
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The unique ID of the developer in the SCM.
+     */
+    private String id;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Developer
+     */
+    public Developer clone()
+    {
+        try
+        {
+            Developer copy = (Developer) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Developer clone()
+
+    /**
+     * Get the unique ID of the developer in the SCM.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Set the unique ID of the developer in the SCM.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/DistributionManagement.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/DistributionManagement.java
new file mode 100644
index 0000000..9169a95
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/DistributionManagement.java
@@ -0,0 +1,348 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * This elements describes all that pertains to distribution for a
+ * project. It is
+ *         primarily used for deployment of artifacts and the site
+ * produced by the build.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class DistributionManagement
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Information needed to deploy the artifacts generated by the
+     * project to a
+     *             remote repository.
+     */
+    private DeploymentRepository repository;
+
+    /**
+     * 
+     *             
+     *             Where to deploy snapshots of artifacts to. If
+     * not given, it defaults to the
+     *             <code>repository</code> element.
+     *             
+     *           
+     */
+    private DeploymentRepository snapshotRepository;
+
+    /**
+     * Information needed for deploying the web site of the project.
+     */
+    private Site site;
+
+    /**
+     * 
+     *             
+     *             The URL of the project's download page. If not
+     * given users will be
+     *             referred to the homepage given by
+     * <code>url</code>.
+     *             This is given to assist in locating artifacts
+     * that are not in the repository due to
+     *             licensing restrictions.
+     *             
+     *           
+     */
+    private String downloadUrl;
+
+    /**
+     * Relocation information of the artifact if it has been moved
+     * to a new group ID
+     *             and/or artifact ID.
+     */
+    private Relocation relocation;
+
+    /**
+     * 
+     *             
+     *             Gives the status of this artifact in the remote
+     * repository.
+     *             This must not be set in your local project, as
+     * it is updated by
+     *             tools placing it in the reposiory. Valid values
+     * are: <code>none</code> (default),
+     *             <code>converted</code> (repository manager
+     * converted this from an Maven 1 POM),
+     *             <code>partner</code>
+     *             (directly synced from a partner Maven 2
+     * repository), <code>deployed</code> (was deployed from a
+     * Maven 2
+     *             instance), <code>verified</code> (has been hand
+     * verified as correct and final).
+     *             
+     *           
+     */
+    private String status;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return DistributionManagement
+     */
+    public DistributionManagement clone()
+    {
+        try
+        {
+            DistributionManagement copy = (DistributionManagement) super.clone();
+
+            if ( this.repository != null )
+            {
+                copy.repository = (DeploymentRepository) this.repository.clone();
+            }
+
+            if ( this.snapshotRepository != null )
+            {
+                copy.snapshotRepository = (DeploymentRepository) this.snapshotRepository.clone();
+            }
+
+            if ( this.site != null )
+            {
+                copy.site = (Site) this.site.clone();
+            }
+
+            if ( this.relocation != null )
+            {
+                copy.relocation = (Relocation) this.relocation.clone();
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- DistributionManagement clone()
+
+    /**
+     * Get the URL of the project's download page. If not given
+     * users will be
+     *             referred to the homepage given by
+     * <code>url</code>.
+     *             This is given to assist in locating artifacts
+     * that are not in the repository due to
+     *             licensing restrictions.
+     * 
+     * @return String
+     */
+    public String getDownloadUrl()
+    {
+        return this.downloadUrl;
+    } //-- String getDownloadUrl()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get relocation information of the artifact if it has been
+     * moved to a new group ID
+     *             and/or artifact ID.
+     * 
+     * @return Relocation
+     */
+    public Relocation getRelocation()
+    {
+        return this.relocation;
+    } //-- Relocation getRelocation()
+
+    /**
+     * Get information needed to deploy the artifacts generated by
+     * the project to a
+     *             remote repository.
+     * 
+     * @return DeploymentRepository
+     */
+    public DeploymentRepository getRepository()
+    {
+        return this.repository;
+    } //-- DeploymentRepository getRepository()
+
+    /**
+     * Get information needed for deploying the web site of the
+     * project.
+     * 
+     * @return Site
+     */
+    public Site getSite()
+    {
+        return this.site;
+    } //-- Site getSite()
+
+    /**
+     * Get where to deploy snapshots of artifacts to. If not given,
+     * it defaults to the
+     *             <code>repository</code> element.
+     * 
+     * @return DeploymentRepository
+     */
+    public DeploymentRepository getSnapshotRepository()
+    {
+        return this.snapshotRepository;
+    } //-- DeploymentRepository getSnapshotRepository()
+
+    /**
+     * Get gives the status of this artifact in the remote
+     * repository.
+     *             This must not be set in your local project, as
+     * it is updated by
+     *             tools placing it in the reposiory. Valid values
+     * are: <code>none</code> (default),
+     *             <code>converted</code> (repository manager
+     * converted this from an Maven 1 POM),
+     *             <code>partner</code>
+     *             (directly synced from a partner Maven 2
+     * repository), <code>deployed</code> (was deployed from a
+     * Maven 2
+     *             instance), <code>verified</code> (has been hand
+     * verified as correct and final).
+     * 
+     * @return String
+     */
+    public String getStatus()
+    {
+        return this.status;
+    } //-- String getStatus()
+
+    /**
+     * Set the URL of the project's download page. If not given
+     * users will be
+     *             referred to the homepage given by
+     * <code>url</code>.
+     *             This is given to assist in locating artifacts
+     * that are not in the repository due to
+     *             licensing restrictions.
+     * 
+     * @param downloadUrl
+     */
+    public void setDownloadUrl( String downloadUrl )
+    {
+        this.downloadUrl = downloadUrl;
+    } //-- void setDownloadUrl( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set relocation information of the artifact if it has been
+     * moved to a new group ID
+     *             and/or artifact ID.
+     * 
+     * @param relocation
+     */
+    public void setRelocation( Relocation relocation )
+    {
+        this.relocation = relocation;
+    } //-- void setRelocation( Relocation )
+
+    /**
+     * Set information needed to deploy the artifacts generated by
+     * the project to a
+     *             remote repository.
+     * 
+     * @param repository
+     */
+    public void setRepository( DeploymentRepository repository )
+    {
+        this.repository = repository;
+    } //-- void setRepository( DeploymentRepository )
+
+    /**
+     * Set information needed for deploying the web site of the
+     * project.
+     * 
+     * @param site
+     */
+    public void setSite( Site site )
+    {
+        this.site = site;
+    } //-- void setSite( Site )
+
+    /**
+     * Set where to deploy snapshots of artifacts to. If not given,
+     * it defaults to the
+     *             <code>repository</code> element.
+     * 
+     * @param snapshotRepository
+     */
+    public void setSnapshotRepository( DeploymentRepository snapshotRepository )
+    {
+        this.snapshotRepository = snapshotRepository;
+    } //-- void setSnapshotRepository( DeploymentRepository )
+
+    /**
+     * Set gives the status of this artifact in the remote
+     * repository.
+     *             This must not be set in your local project, as
+     * it is updated by
+     *             tools placing it in the reposiory. Valid values
+     * are: <code>none</code> (default),
+     *             <code>converted</code> (repository manager
+     * converted this from an Maven 1 POM),
+     *             <code>partner</code>
+     *             (directly synced from a partner Maven 2
+     * repository), <code>deployed</code> (was deployed from a
+     * Maven 2
+     *             instance), <code>verified</code> (has been hand
+     * verified as correct and final).
+     * 
+     * @param status
+     */
+    public void setStatus( String status )
+    {
+        this.status = status;
+    } //-- void setStatus( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Exclusion.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Exclusion.java
new file mode 100644
index 0000000..72b5aab
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Exclusion.java
@@ -0,0 +1,142 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;exclusion&gt;</code> element contains
+ * informations required to exclude
+ *         an artifact to the project.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Exclusion
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The artifact ID of the project to exclude.
+     */
+    private String artifactId;
+
+    /**
+     * The group ID of the project to exclude.
+     */
+    private String groupId;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Exclusion
+     */
+    public Exclusion clone()
+    {
+        try
+        {
+            Exclusion copy = (Exclusion) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Exclusion clone()
+
+    /**
+     * Get the artifact ID of the project to exclude.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the group ID of the project to exclude.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Set the artifact ID of the project to exclude.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the group ID of the project to exclude.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Extension.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Extension.java
new file mode 100644
index 0000000..478c7a4
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Extension.java
@@ -0,0 +1,213 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Describes a build extension to utilise.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Extension
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The group ID of the extension's artifact.
+     */
+    private String groupId;
+
+    /**
+     * The artifact ID of the extension.
+     */
+    private String artifactId;
+
+    /**
+     * The version of the extension.
+     */
+    private String version;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Extension
+     */
+    public Extension clone()
+    {
+        try
+        {
+            Extension copy = (Extension) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Extension clone()
+
+    /**
+     * Get the artifact ID of the extension.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the group ID of the extension's artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the version of the extension.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the artifact ID of the extension.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the group ID of the extension's artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the version of the extension.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals( Object o )
+    {
+        if ( this == o )
+        {
+            return true;
+        }
+
+        if ( !( o instanceof Extension ) )
+        {
+            return false;
+        }
+
+        Extension e = (Extension) o;
+
+        if ( !equal( e.getArtifactId(), getArtifactId() ) )
+        {
+            return false;
+        }
+        else if ( !equal( e.getGroupId(), getGroupId() ) )
+        {
+            return false;
+        }
+        else if ( !equal( e.getVersion(), getVersion() ) )
+        {
+            return false;
+        }
+        return true;
+    }
+
+    private static <T> boolean equal( T obj1, T obj2 )
+    {
+        return ( obj1 != null ) ? obj1.equals( obj2 ) : obj2 == null;
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode()
+    {
+        int result = 17;
+        result = 37 * result + ( getArtifactId() != null ? getArtifactId().hashCode() : 0 );
+        result = 37 * result + ( getGroupId() != null ? getGroupId().hashCode() : 0 );
+        result = 37 * result + ( getVersion() != null ? getVersion().hashCode() : 0 );
+        return result;
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/FileSet.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/FileSet.java
new file mode 100644
index 0000000..4aac499
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/FileSet.java
@@ -0,0 +1,90 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * A PatternSet for files.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class FileSet
+    extends PatternSet
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Describe the directory where the resources are stored. The
+     * path is relative
+     *             to the POM.
+     */
+    private String directory;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return FileSet
+     */
+    public FileSet clone()
+    {
+        try
+        {
+            FileSet copy = (FileSet) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- FileSet clone()
+
+    /**
+     * Get describe the directory where the resources are stored.
+     * The path is relative
+     *             to the POM.
+     * 
+     * @return String
+     */
+    public String getDirectory()
+    {
+        return this.directory;
+    } //-- String getDirectory()
+
+    /**
+     * Set describe the directory where the resources are stored.
+     * The path is relative
+     *             to the POM.
+     * 
+     * @param directory
+     */
+    public void setDirectory( String directory )
+    {
+        this.directory = directory;
+    } //-- void setDirectory( String )
+
+    
+            
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString()
+    {
+        return "FileSet {directory: " + getDirectory() + ", " + super.toString() + "}";
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocation.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocation.java
new file mode 100644
index 0000000..742a8a8
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocation.java
@@ -0,0 +1,283 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Class InputLocation.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public final class InputLocation
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The one-based line number. The value will be non-positive if
+     * unknown.
+     */
+    private int lineNumber = -1;
+
+    /**
+     * The one-based column number. The value will be non-positive
+     * if unknown.
+     */
+    private int columnNumber = -1;
+
+    /**
+     * Field source.
+     */
+    private InputSource source;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public InputLocation(int lineNumber, int columnNumber)
+    {
+        this.lineNumber = lineNumber;
+        this.columnNumber = columnNumber;
+    } //-- org.apache.maven.model.InputLocation(int, int)
+
+    public InputLocation(int lineNumber, int columnNumber, InputSource source)
+    {
+        this.lineNumber = lineNumber;
+        this.columnNumber = columnNumber;
+        this.source = source;
+    } //-- org.apache.maven.model.InputLocation(int, int, InputSource)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return InputLocation
+     */
+    public InputLocation clone()
+    {
+        try
+        {
+            InputLocation copy = (InputLocation) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- InputLocation clone()
+
+    /**
+     * Get the one-based column number. The value will be
+     * non-positive if unknown.
+     * 
+     * @return int
+     */
+    public int getColumnNumber()
+    {
+        return this.columnNumber;
+    } //-- int getColumnNumber()
+
+    /**
+     * Get the one-based line number. The value will be
+     * non-positive if unknown.
+     * 
+     * @return int
+     */
+    public int getLineNumber()
+    {
+        return this.lineNumber;
+    } //-- int getLineNumber()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * 
+     * 
+     * @return Map<Object, InputLocation>
+     */
+    public java.util.Map<Object, InputLocation> getLocations()
+    {
+        return locations;
+    } //-- java.util.Map<Object, InputLocation> getLocations()
+
+    /**
+     * Get the source field.
+     * 
+     * @return InputSource
+     */
+    public InputSource getSource()
+    {
+        return this.source;
+    } //-- InputSource getSource()
+
+    /**
+     * Method merge.
+     * 
+     * @param target
+     * @param sourceDominant
+     * @param source
+     * @return InputLocation
+     */
+    public static InputLocation merge( InputLocation target, InputLocation source, boolean sourceDominant )
+    {
+        if ( source == null )
+        {
+            return target;
+        }
+        else if ( target == null )
+        {
+            return source;
+        }
+
+        InputLocation result =
+            new InputLocation( target.getLineNumber(), target.getColumnNumber(), target.getSource() );
+
+        java.util.Map<Object, InputLocation> locations;
+        java.util.Map<Object, InputLocation> sourceLocations = source.getLocations();
+        java.util.Map<Object, InputLocation> targetLocations = target.getLocations();
+        if ( sourceLocations == null )
+        {
+            locations = targetLocations;
+        }
+        else if ( targetLocations == null )
+        {
+            locations = sourceLocations;
+        }
+        else
+        {
+            locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            locations.putAll( sourceDominant ? targetLocations : sourceLocations );
+            locations.putAll( sourceDominant ? sourceLocations : targetLocations );
+        }
+        result.setLocations( locations );
+
+        return result;
+    } //-- InputLocation merge( InputLocation, InputLocation, boolean )
+
+    /**
+     * Method merge.
+     * 
+     * @param target
+     * @param indices
+     * @param source
+     * @return InputLocation
+     */
+    public static InputLocation merge( InputLocation target, InputLocation source, java.util.Collection<Integer> indices )
+    {
+        if ( source == null )
+        {
+            return target;
+        }
+        else if ( target == null )
+        {
+            return source;
+        }
+
+        InputLocation result =
+            new InputLocation( target.getLineNumber(), target.getColumnNumber(), target.getSource() );
+
+        java.util.Map<Object, InputLocation> locations;
+        java.util.Map<Object, InputLocation> sourceLocations = source.getLocations();
+        java.util.Map<Object, InputLocation> targetLocations = target.getLocations();
+        if ( sourceLocations == null )
+        {
+            locations = targetLocations;
+        }
+        else if ( targetLocations == null )
+        {
+            locations = sourceLocations;
+        }
+        else
+        {
+            locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            for ( java.util.Iterator<Integer> it = indices.iterator(); it.hasNext(); )
+            {
+                InputLocation location;
+                Integer index = it.next();
+                if ( index.intValue() < 0 )
+                {
+                    location = sourceLocations.get( Integer.valueOf( ~index.intValue() ) );
+                }
+                else
+                {
+                    location = targetLocations.get( index );
+                }
+                locations.put( Integer.valueOf( locations.size() ), location );
+            }
+        }
+        result.setLocations( locations );
+
+        return result;
+    } //-- InputLocation merge( InputLocation, InputLocation, java.util.Collection )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * 
+     * 
+     * @param locations
+     */
+    public void setLocations( java.util.Map<Object, InputLocation> locations )
+    {
+        this.locations = locations;
+    } //-- void setLocations( java.util.Map<Object, InputLocation> )
+
+    
+            
+
+    @Override
+    public String toString()
+    {
+        return getLineNumber() + " : " + getColumnNumber() + ", " + getSource();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocationTracker.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocationTracker.java
new file mode 100644
index 0000000..09ef0f8
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/InputLocationTracker.java
@@ -0,0 +1,40 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Interface InputLocationTracker.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public interface InputLocationTracker
+{
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Gets the location of the specified field in the input
+     * source.
+     * 
+     * @param field The key of the field, must not be
+     * <code>null</code>.
+     * @return The location of the field in the input source or
+     * <code>null</code> if unknown.
+     */
+    public InputLocation getLocation( Object field );
+    /**
+     * Sets the location of the specified field.
+     * 
+     * @param field The key of the field, must not be
+     * <code>null</code>.
+     * @param location The location of the field, may be
+     * <code>null</code>.
+     */
+    public void setLocation( Object field, InputLocation location );
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/InputSource.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/InputSource.java
new file mode 100644
index 0000000..4ca1aa0
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/InputSource.java
@@ -0,0 +1,118 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Class InputSource.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class InputSource
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The identifier of the POM in the format {@code
+     * <groupId>:<artifactId>:<version>}.
+     *             
+     *           
+     */
+    private String modelId;
+
+    /**
+     * 
+     *             
+     *             The path/URL of the POM or {@code null} if
+     * unknown.
+     *             
+     *           
+     */
+    private String location;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return InputSource
+     */
+    public InputSource clone()
+    {
+        try
+        {
+            InputSource copy = (InputSource) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- InputSource clone()
+
+    /**
+     * Get the path/URL of the POM or {@code null} if unknown.
+     * 
+     * @return String
+     */
+    public String getLocation()
+    {
+        return this.location;
+    } //-- String getLocation()
+
+    /**
+     * Get the identifier of the POM in the format {@code
+     * <groupId>:<artifactId>:<version>}.
+     * 
+     * @return String
+     */
+    public String getModelId()
+    {
+        return this.modelId;
+    } //-- String getModelId()
+
+    /**
+     * Set the path/URL of the POM or {@code null} if unknown.
+     * 
+     * @param location
+     */
+    public void setLocation( String location )
+    {
+        this.location = location;
+    } //-- void setLocation( String )
+
+    /**
+     * Set the identifier of the POM in the format {@code
+     * <groupId>:<artifactId>:<version>}.
+     * 
+     * @param modelId
+     */
+    public void setModelId( String modelId )
+    {
+        this.modelId = modelId;
+    } //-- void setModelId( String )
+
+    
+            
+    @Override
+    public String toString()
+    {
+        return getModelId() + " " + getLocation();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/IssueManagement.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/IssueManagement.java
new file mode 100644
index 0000000..2912c4c
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/IssueManagement.java
@@ -0,0 +1,138 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Information about the issue tracking (or bug tracking) system
+ * used to manage this
+ *         project.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class IssueManagement
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name of the issue management system, e.g. Bugzilla.
+     */
+    private String system;
+
+    /**
+     * URL for the issue management system used by the project.
+     */
+    private String url;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return IssueManagement
+     */
+    public IssueManagement clone()
+    {
+        try
+        {
+            IssueManagement copy = (IssueManagement) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- IssueManagement clone()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the name of the issue management system, e.g. Bugzilla.
+     * 
+     * @return String
+     */
+    public String getSystem()
+    {
+        return this.system;
+    } //-- String getSystem()
+
+    /**
+     * Get uRL for the issue management system used by the project.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the name of the issue management system, e.g. Bugzilla.
+     * 
+     * @param system
+     */
+    public void setSystem( String system )
+    {
+        this.system = system;
+    } //-- void setSystem( String )
+
+    /**
+     * Set uRL for the issue management system used by the project.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/License.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/License.java
new file mode 100644
index 0000000..284ce6c
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/License.java
@@ -0,0 +1,223 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Describes the licenses for this project. This is used to
+ * generate the license
+ *         page of the project's web site, as well as being taken
+ * into consideration in other reporting
+ *         and validation. The licenses listed for the project are
+ * that of the project itself, and not
+ *         of dependencies.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class License
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The full legal name of the license.
+     */
+    private String name;
+
+    /**
+     * The official url for the license text.
+     */
+    private String url;
+
+    /**
+     * 
+     *             
+     *             The primary method by which this project may be
+     * distributed.
+     *             <dl>
+     *               <dt>repo</dt>
+     *               <dd>may be downloaded from the Maven
+     * repository</dd>
+     *               <dt>manual</dt>
+     *               <dd>user must manually download and install
+     * the dependency.</dd>
+     *             </dl>
+     *             
+     *           
+     */
+    private String distribution;
+
+    /**
+     * Addendum information pertaining to this license.
+     */
+    private String comments;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return License
+     */
+    public License clone()
+    {
+        try
+        {
+            License copy = (License) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- License clone()
+
+    /**
+     * Get addendum information pertaining to this license.
+     * 
+     * @return String
+     */
+    public String getComments()
+    {
+        return this.comments;
+    } //-- String getComments()
+
+    /**
+     * Get the primary method by which this project may be
+     * distributed.
+     *             <dl>
+     *               <dt>repo</dt>
+     *               <dd>may be downloaded from the Maven
+     * repository</dd>
+     *               <dt>manual</dt>
+     *               <dd>user must manually download and install
+     * the dependency.</dd>
+     *             </dl>
+     * 
+     * @return String
+     */
+    public String getDistribution()
+    {
+        return this.distribution;
+    } //-- String getDistribution()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the full legal name of the license.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the official url for the license text.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Set addendum information pertaining to this license.
+     * 
+     * @param comments
+     */
+    public void setComments( String comments )
+    {
+        this.comments = comments;
+    } //-- void setComments( String )
+
+    /**
+     * Set the primary method by which this project may be
+     * distributed.
+     *             <dl>
+     *               <dt>repo</dt>
+     *               <dd>may be downloaded from the Maven
+     * repository</dd>
+     *               <dt>manual</dt>
+     *               <dd>user must manually download and install
+     * the dependency.</dd>
+     *             </dl>
+     * 
+     * @param distribution
+     */
+    public void setDistribution( String distribution )
+    {
+        this.distribution = distribution;
+    } //-- void setDistribution( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the full legal name of the license.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the official url for the license text.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/MailingList.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/MailingList.java
new file mode 100644
index 0000000..9c0cb9f
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/MailingList.java
@@ -0,0 +1,341 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * This element describes all of the mailing lists associated with
+ * a project. The
+ *         auto-generated site references this information.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MailingList
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The name of the mailing list.
+     *             
+     *           
+     */
+    private String name;
+
+    /**
+     * 
+     *             
+     *             The email address or link that can be used to
+     * subscribe to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     *             
+     *           
+     */
+    private String subscribe;
+
+    /**
+     * 
+     *             
+     *             The email address or link that can be used to
+     * unsubscribe to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     *             
+     *           
+     */
+    private String unsubscribe;
+
+    /**
+     * 
+     *             
+     *             The email address or link that can be used to
+     * post to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     *             
+     *           
+     */
+    private String post;
+
+    /**
+     * The link to a URL where you can browse the mailing list
+     * archive.
+     */
+    private String archive;
+
+    /**
+     * Field otherArchives.
+     */
+    private java.util.List<String> otherArchives;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addOtherArchive.
+     * 
+     * @param string
+     */
+    public void addOtherArchive( String string )
+    {
+        getOtherArchives().add( string );
+    } //-- void addOtherArchive( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return MailingList
+     */
+    public MailingList clone()
+    {
+        try
+        {
+            MailingList copy = (MailingList) super.clone();
+
+            if ( this.otherArchives != null )
+            {
+                copy.otherArchives = new java.util.ArrayList<String>();
+                copy.otherArchives.addAll( this.otherArchives );
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- MailingList clone()
+
+    /**
+     * Get the link to a URL where you can browse the mailing list
+     * archive.
+     * 
+     * @return String
+     */
+    public String getArchive()
+    {
+        return this.archive;
+    } //-- String getArchive()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the name of the mailing list.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Method getOtherArchives.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getOtherArchives()
+    {
+        if ( this.otherArchives == null )
+        {
+            this.otherArchives = new java.util.ArrayList<String>();
+        }
+
+        return this.otherArchives;
+    } //-- java.util.List<String> getOtherArchives()
+
+    /**
+     * Get the email address or link that can be used to post to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     * 
+     * @return String
+     */
+    public String getPost()
+    {
+        return this.post;
+    } //-- String getPost()
+
+    /**
+     * Get the email address or link that can be used to subscribe
+     * to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     * 
+     * @return String
+     */
+    public String getSubscribe()
+    {
+        return this.subscribe;
+    } //-- String getSubscribe()
+
+    /**
+     * Get the email address or link that can be used to
+     * unsubscribe to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     * 
+     * @return String
+     */
+    public String getUnsubscribe()
+    {
+        return this.unsubscribe;
+    } //-- String getUnsubscribe()
+
+    /**
+     * Method removeOtherArchive.
+     * 
+     * @param string
+     */
+    public void removeOtherArchive( String string )
+    {
+        getOtherArchives().remove( string );
+    } //-- void removeOtherArchive( String )
+
+    /**
+     * Set the link to a URL where you can browse the mailing list
+     * archive.
+     * 
+     * @param archive
+     */
+    public void setArchive( String archive )
+    {
+        this.archive = archive;
+    } //-- void setArchive( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the name of the mailing list.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the link to alternate URLs where you can browse the list
+     * archive.
+     * 
+     * @param otherArchives
+     */
+    public void setOtherArchives( java.util.List<String> otherArchives )
+    {
+        this.otherArchives = otherArchives;
+    } //-- void setOtherArchives( java.util.List )
+
+    /**
+     * Set the email address or link that can be used to post to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     * 
+     * @param post
+     */
+    public void setPost( String post )
+    {
+        this.post = post;
+    } //-- void setPost( String )
+
+    /**
+     * Set the email address or link that can be used to subscribe
+     * to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     * 
+     * @param subscribe
+     */
+    public void setSubscribe( String subscribe )
+    {
+        this.subscribe = subscribe;
+    } //-- void setSubscribe( String )
+
+    /**
+     * Set the email address or link that can be used to
+     * unsubscribe to
+     *             the mailing list.  If this is an email address,
+     * a
+     *             <code>mailto:</code> link will automatically be
+     * created
+     *             when the documentation is created.
+     * 
+     * @param unsubscribe
+     */
+    public void setUnsubscribe( String unsubscribe )
+    {
+        this.unsubscribe = unsubscribe;
+    } //-- void setUnsubscribe( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Model.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Model.java
new file mode 100644
index 0000000..8a2391a
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Model.java
@@ -0,0 +1,1035 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;project&gt;</code> element is the root of
+ * the descriptor.
+ *         The following table lists all of the possible child
+ * elements.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Model
+    extends ModelBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Declares to which version of project descriptor this POM
+     * conforms.
+     */
+    private String modelVersion;
+
+    /**
+     * The location of the parent project, if one exists. Values
+     * from the parent
+     *             project will be the default for this project if
+     * they are left unspecified. The location
+     *             is given as a group ID, artifact ID and version.
+     */
+    private Parent parent;
+
+    /**
+     * 
+     *             
+     *             A universally unique identifier for a project.
+     * It is normal to
+     *             use a fully-qualified package name to
+     * distinguish it from other
+     *             projects with a similar name (eg.
+     * <code>org.apache.maven</code>).
+     *             
+     *           
+     */
+    private String groupId;
+
+    /**
+     * The identifier for this artifact that is unique within the
+     * group given by the
+     *             group ID. An artifact is something that is
+     * either produced or used by a project.
+     *             Examples of artifacts produced by Maven for a
+     * project include: JARs, source and binary
+     *             distributions, and WARs.
+     */
+    private String artifactId;
+
+    /**
+     * The current version of the artifact produced by this project.
+     */
+    private String version;
+
+    /**
+     * 
+     *             
+     *             The type of artifact this project produces, for
+     * example <code>jar</code>
+     *               <code>war</code>
+     *               <code>ear</code>
+     *               <code>pom</code>.
+     *             Plugins can create their own packaging, and
+     *             therefore their own packaging types,
+     *             so this list does not contain all possible
+     * types.
+     *             
+     *           
+     */
+    private String packaging = "jar";
+
+    /**
+     * The full name of the project.
+     */
+    private String name;
+
+    /**
+     * A detailed description of the project, used by Maven
+     * whenever it needs to
+     *             describe the project, such as on the web site.
+     * While this element can be specified as
+     *             CDATA to enable the use of HTML tags within the
+     * description, it is discouraged to allow
+     *             plain text representation. If you need to modify
+     * the index page of the generated web
+     *             site, you are able to specify your own instead
+     * of adjusting this text.
+     */
+    private String description;
+
+    /**
+     * 
+     *             
+     *             The URL to the project's homepage.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId
+     *             
+     *           .
+     */
+    private String url;
+
+    /**
+     * The year of the project's inception, specified with 4
+     * digits. This value is
+     *             used when generating copyright notices as well
+     * as being informational.
+     */
+    private String inceptionYear;
+
+    /**
+     * This element describes various attributes of the
+     * organization to which the
+     *             project belongs. These attributes are utilized
+     * when documentation is created (for
+     *             copyright notices and links).
+     */
+    private Organization organization;
+
+    /**
+     * Field licenses.
+     */
+    private java.util.List<License> licenses;
+
+    /**
+     * Field developers.
+     */
+    private java.util.List<Developer> developers;
+
+    /**
+     * Field contributors.
+     */
+    private java.util.List<Contributor> contributors;
+
+    /**
+     * Field mailingLists.
+     */
+    private java.util.List<MailingList> mailingLists;
+
+    /**
+     * Describes the prerequisites in the build environment for
+     * this project.
+     */
+    private Prerequisites prerequisites;
+
+    /**
+     * Specification for the SCM used by the project, such as CVS,
+     * Subversion, etc.
+     */
+    private Scm scm;
+
+    /**
+     * The project's issue management system information.
+     */
+    private IssueManagement issueManagement;
+
+    /**
+     * The project's continuous integration information.
+     */
+    private CiManagement ciManagement;
+
+    /**
+     * Information required to build the project.
+     */
+    private Build build;
+
+    /**
+     * Field profiles.
+     */
+    private java.util.List<Profile> profiles;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addContributor.
+     * 
+     * @param contributor
+     */
+    public void addContributor( Contributor contributor )
+    {
+        getContributors().add( contributor );
+    } //-- void addContributor( Contributor )
+
+    /**
+     * Method addDeveloper.
+     * 
+     * @param developer
+     */
+    public void addDeveloper( Developer developer )
+    {
+        getDevelopers().add( developer );
+    } //-- void addDeveloper( Developer )
+
+    /**
+     * Method addLicense.
+     * 
+     * @param license
+     */
+    public void addLicense( License license )
+    {
+        getLicenses().add( license );
+    } //-- void addLicense( License )
+
+    /**
+     * Method addMailingList.
+     * 
+     * @param mailingList
+     */
+    public void addMailingList( MailingList mailingList )
+    {
+        getMailingLists().add( mailingList );
+    } //-- void addMailingList( MailingList )
+
+    /**
+     * Method addProfile.
+     * 
+     * @param profile
+     */
+    public void addProfile( Profile profile )
+    {
+        getProfiles().add( profile );
+    } //-- void addProfile( Profile )
+
+    /**
+     * Method clone.
+     * 
+     * @return Model
+     */
+    public Model clone()
+    {
+        try
+        {
+            Model copy = (Model) super.clone();
+
+            if ( this.parent != null )
+            {
+                copy.parent = (Parent) this.parent.clone();
+            }
+
+            if ( this.organization != null )
+            {
+                copy.organization = (Organization) this.organization.clone();
+            }
+
+            if ( this.licenses != null )
+            {
+                copy.licenses = new java.util.ArrayList<License>();
+                for ( License item : this.licenses )
+                {
+                    copy.licenses.add( ( (License) item).clone() );
+                }
+            }
+
+            if ( this.developers != null )
+            {
+                copy.developers = new java.util.ArrayList<Developer>();
+                for ( Developer item : this.developers )
+                {
+                    copy.developers.add( ( (Developer) item).clone() );
+                }
+            }
+
+            if ( this.contributors != null )
+            {
+                copy.contributors = new java.util.ArrayList<Contributor>();
+                for ( Contributor item : this.contributors )
+                {
+                    copy.contributors.add( ( (Contributor) item).clone() );
+                }
+            }
+
+            if ( this.mailingLists != null )
+            {
+                copy.mailingLists = new java.util.ArrayList<MailingList>();
+                for ( MailingList item : this.mailingLists )
+                {
+                    copy.mailingLists.add( ( (MailingList) item).clone() );
+                }
+            }
+
+            if ( this.prerequisites != null )
+            {
+                copy.prerequisites = (Prerequisites) this.prerequisites.clone();
+            }
+
+            if ( this.scm != null )
+            {
+                copy.scm = (Scm) this.scm.clone();
+            }
+
+            if ( this.issueManagement != null )
+            {
+                copy.issueManagement = (IssueManagement) this.issueManagement.clone();
+            }
+
+            if ( this.ciManagement != null )
+            {
+                copy.ciManagement = (CiManagement) this.ciManagement.clone();
+            }
+
+            if ( this.build != null )
+            {
+                copy.build = (Build) this.build.clone();
+            }
+
+            if ( this.profiles != null )
+            {
+                copy.profiles = new java.util.ArrayList<Profile>();
+                for ( Profile item : this.profiles )
+                {
+                    copy.profiles.add( ( (Profile) item).clone() );
+                }
+            }
+
+            cloneHook( copy );
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Model clone()
+
+    /**
+     * Get the identifier for this artifact that is unique within
+     * the group given by the
+     *             group ID. An artifact is something that is
+     * either produced or used by a project.
+     *             Examples of artifacts produced by Maven for a
+     * project include: JARs, source and binary
+     *             distributions, and WARs.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get information required to build the project.
+     * 
+     * @return Build
+     */
+    public Build getBuild()
+    {
+        return this.build;
+    } //-- Build getBuild()
+
+    /**
+     * Get the project's continuous integration information.
+     * 
+     * @return CiManagement
+     */
+    public CiManagement getCiManagement()
+    {
+        return this.ciManagement;
+    } //-- CiManagement getCiManagement()
+
+    /**
+     * Method getContributors.
+     * 
+     * @return List
+     */
+    public java.util.List<Contributor> getContributors()
+    {
+        if ( this.contributors == null )
+        {
+            this.contributors = new java.util.ArrayList<Contributor>();
+        }
+
+        return this.contributors;
+    } //-- java.util.List<Contributor> getContributors()
+
+    /**
+     * Get a detailed description of the project, used by Maven
+     * whenever it needs to
+     *             describe the project, such as on the web site.
+     * While this element can be specified as
+     *             CDATA to enable the use of HTML tags within the
+     * description, it is discouraged to allow
+     *             plain text representation. If you need to modify
+     * the index page of the generated web
+     *             site, you are able to specify your own instead
+     * of adjusting this text.
+     * 
+     * @return String
+     */
+    public String getDescription()
+    {
+        return this.description;
+    } //-- String getDescription()
+
+    /**
+     * Method getDevelopers.
+     * 
+     * @return List
+     */
+    public java.util.List<Developer> getDevelopers()
+    {
+        if ( this.developers == null )
+        {
+            this.developers = new java.util.ArrayList<Developer>();
+        }
+
+        return this.developers;
+    } //-- java.util.List<Developer> getDevelopers()
+
+    /**
+     * Get a universally unique identifier for a project. It is
+     * normal to
+     *             use a fully-qualified package name to
+     * distinguish it from other
+     *             projects with a similar name (eg.
+     * <code>org.apache.maven</code>).
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get the year of the project's inception, specified with 4
+     * digits. This value is
+     *             used when generating copyright notices as well
+     * as being informational.
+     * 
+     * @return String
+     */
+    public String getInceptionYear()
+    {
+        return this.inceptionYear;
+    } //-- String getInceptionYear()
+
+    /**
+     * Get the project's issue management system information.
+     * 
+     * @return IssueManagement
+     */
+    public IssueManagement getIssueManagement()
+    {
+        return this.issueManagement;
+    } //-- IssueManagement getIssueManagement()
+
+    /**
+     * Method getLicenses.
+     * 
+     * @return List
+     */
+    public java.util.List<License> getLicenses()
+    {
+        if ( this.licenses == null )
+        {
+            this.licenses = new java.util.ArrayList<License>();
+        }
+
+        return this.licenses;
+    } //-- java.util.List<License> getLicenses()
+
+    /**
+     * Method getMailingLists.
+     * 
+     * @return List
+     */
+    public java.util.List<MailingList> getMailingLists()
+    {
+        if ( this.mailingLists == null )
+        {
+            this.mailingLists = new java.util.ArrayList<MailingList>();
+        }
+
+        return this.mailingLists;
+    } //-- java.util.List<MailingList> getMailingLists()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Get declares to which version of project descriptor this POM
+     * conforms.
+     * 
+     * @return String
+     */
+    public String getModelVersion()
+    {
+        return this.modelVersion;
+    } //-- String getModelVersion()
+
+    /**
+     * Get the full name of the project.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get this element describes various attributes of the
+     * organization to which the
+     *             project belongs. These attributes are utilized
+     * when documentation is created (for
+     *             copyright notices and links).
+     * 
+     * @return Organization
+     */
+    public Organization getOrganization()
+    {
+        return this.organization;
+    } //-- Organization getOrganization()
+
+    /**
+     * Get the type of artifact this project produces, for example
+     * <code>jar</code>
+     *               <code>war</code>
+     *               <code>ear</code>
+     *               <code>pom</code>.
+     *             Plugins can create their own packaging, and
+     *             therefore their own packaging types,
+     *             so this list does not contain all possible
+     * types.
+     * 
+     * @return String
+     */
+    public String getPackaging()
+    {
+        return this.packaging;
+    } //-- String getPackaging()
+
+    /**
+     * Get the location of the parent project, if one exists.
+     * Values from the parent
+     *             project will be the default for this project if
+     * they are left unspecified. The location
+     *             is given as a group ID, artifact ID and version.
+     * 
+     * @return Parent
+     */
+    public Parent getParent()
+    {
+        return this.parent;
+    } //-- Parent getParent()
+
+    /**
+     * Get describes the prerequisites in the build environment for
+     * this project.
+     * 
+     * @return Prerequisites
+     */
+    public Prerequisites getPrerequisites()
+    {
+        return this.prerequisites;
+    } //-- Prerequisites getPrerequisites()
+
+    /**
+     * Method getProfiles.
+     * 
+     * @return List
+     */
+    public java.util.List<Profile> getProfiles()
+    {
+        if ( this.profiles == null )
+        {
+            this.profiles = new java.util.ArrayList<Profile>();
+        }
+
+        return this.profiles;
+    } //-- java.util.List<Profile> getProfiles()
+
+    /**
+     * Get specification for the SCM used by the project, such as
+     * CVS, Subversion, etc.
+     * 
+     * @return Scm
+     */
+    public Scm getScm()
+    {
+        return this.scm;
+    } //-- Scm getScm()
+
+    /**
+     * Get the URL to the project's homepage.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Get the current version of the artifact produced by this
+     * project.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Method removeContributor.
+     * 
+     * @param contributor
+     */
+    public void removeContributor( Contributor contributor )
+    {
+        getContributors().remove( contributor );
+    } //-- void removeContributor( Contributor )
+
+    /**
+     * Method removeDeveloper.
+     * 
+     * @param developer
+     */
+    public void removeDeveloper( Developer developer )
+    {
+        getDevelopers().remove( developer );
+    } //-- void removeDeveloper( Developer )
+
+    /**
+     * Method removeLicense.
+     * 
+     * @param license
+     */
+    public void removeLicense( License license )
+    {
+        getLicenses().remove( license );
+    } //-- void removeLicense( License )
+
+    /**
+     * Method removeMailingList.
+     * 
+     * @param mailingList
+     */
+    public void removeMailingList( MailingList mailingList )
+    {
+        getMailingLists().remove( mailingList );
+    } //-- void removeMailingList( MailingList )
+
+    /**
+     * Method removeProfile.
+     * 
+     * @param profile
+     */
+    public void removeProfile( Profile profile )
+    {
+        getProfiles().remove( profile );
+    } //-- void removeProfile( Profile )
+
+    /**
+     * Set the identifier for this artifact that is unique within
+     * the group given by the
+     *             group ID. An artifact is something that is
+     * either produced or used by a project.
+     *             Examples of artifacts produced by Maven for a
+     * project include: JARs, source and binary
+     *             distributions, and WARs.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set information required to build the project.
+     * 
+     * @param build
+     */
+    public void setBuild( Build build )
+    {
+        this.build = build;
+    } //-- void setBuild( Build )
+
+    /**
+     * Set the project's continuous integration information.
+     * 
+     * @param ciManagement
+     */
+    public void setCiManagement( CiManagement ciManagement )
+    {
+        this.ciManagement = ciManagement;
+    } //-- void setCiManagement( CiManagement )
+
+    /**
+     * Set describes the contributors to a project that are not yet
+     * committers.
+     * 
+     * @param contributors
+     */
+    public void setContributors( java.util.List<Contributor> contributors )
+    {
+        this.contributors = contributors;
+    } //-- void setContributors( java.util.List )
+
+    /**
+     * Set a detailed description of the project, used by Maven
+     * whenever it needs to
+     *             describe the project, such as on the web site.
+     * While this element can be specified as
+     *             CDATA to enable the use of HTML tags within the
+     * description, it is discouraged to allow
+     *             plain text representation. If you need to modify
+     * the index page of the generated web
+     *             site, you are able to specify your own instead
+     * of adjusting this text.
+     * 
+     * @param description
+     */
+    public void setDescription( String description )
+    {
+        this.description = description;
+    } //-- void setDescription( String )
+
+    /**
+     * Set describes the committers of a project.
+     * 
+     * @param developers
+     */
+    public void setDevelopers( java.util.List<Developer> developers )
+    {
+        this.developers = developers;
+    } //-- void setDevelopers( java.util.List )
+
+    /**
+     * Set a universally unique identifier for a project. It is
+     * normal to
+     *             use a fully-qualified package name to
+     * distinguish it from other
+     *             projects with a similar name (eg.
+     * <code>org.apache.maven</code>).
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set the year of the project's inception, specified with 4
+     * digits. This value is
+     *             used when generating copyright notices as well
+     * as being informational.
+     * 
+     * @param inceptionYear
+     */
+    public void setInceptionYear( String inceptionYear )
+    {
+        this.inceptionYear = inceptionYear;
+    } //-- void setInceptionYear( String )
+
+    /**
+     * Set the project's issue management system information.
+     * 
+     * @param issueManagement
+     */
+    public void setIssueManagement( IssueManagement issueManagement )
+    {
+        this.issueManagement = issueManagement;
+    } //-- void setIssueManagement( IssueManagement )
+
+    /**
+     * Set this element describes all of the licenses for this
+     * project.
+     *             Each license is described by a
+     * <code>license</code> element, which
+     *             is then described by additional elements.
+     *             Projects should only list the license(s) that
+     * applies to the project
+     *             and not the licenses that apply to dependencies.
+     *             If multiple licenses are listed, it is assumed
+     * that the user can select
+     *             any of them, not that they must accept all.
+     * 
+     * @param licenses
+     */
+    public void setLicenses( java.util.List<License> licenses )
+    {
+        this.licenses = licenses;
+    } //-- void setLicenses( java.util.List )
+
+    /**
+     * Set contains information about a project's mailing lists.
+     * 
+     * @param mailingLists
+     */
+    public void setMailingLists( java.util.List<MailingList> mailingLists )
+    {
+        this.mailingLists = mailingLists;
+    } //-- void setMailingLists( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set declares to which version of project descriptor this POM
+     * conforms.
+     * 
+     * @param modelVersion
+     */
+    public void setModelVersion( String modelVersion )
+    {
+        this.modelVersion = modelVersion;
+    } //-- void setModelVersion( String )
+
+    /**
+     * Set the full name of the project.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set this element describes various attributes of the
+     * organization to which the
+     *             project belongs. These attributes are utilized
+     * when documentation is created (for
+     *             copyright notices and links).
+     * 
+     * @param organization
+     */
+    public void setOrganization( Organization organization )
+    {
+        this.organization = organization;
+    } //-- void setOrganization( Organization )
+
+    /**
+     * Set the type of artifact this project produces, for example
+     * <code>jar</code>
+     *               <code>war</code>
+     *               <code>ear</code>
+     *               <code>pom</code>.
+     *             Plugins can create their own packaging, and
+     *             therefore their own packaging types,
+     *             so this list does not contain all possible
+     * types.
+     * 
+     * @param packaging
+     */
+    public void setPackaging( String packaging )
+    {
+        this.packaging = packaging;
+    } //-- void setPackaging( String )
+
+    /**
+     * Set the location of the parent project, if one exists.
+     * Values from the parent
+     *             project will be the default for this project if
+     * they are left unspecified. The location
+     *             is given as a group ID, artifact ID and version.
+     * 
+     * @param parent
+     */
+    public void setParent( Parent parent )
+    {
+        this.parent = parent;
+    } //-- void setParent( Parent )
+
+    /**
+     * Set describes the prerequisites in the build environment for
+     * this project.
+     * 
+     * @param prerequisites
+     */
+    public void setPrerequisites( Prerequisites prerequisites )
+    {
+        this.prerequisites = prerequisites;
+    } //-- void setPrerequisites( Prerequisites )
+
+    /**
+     * Set a listing of project-local build profiles which will
+     * modify the build process
+     *             when activated.
+     * 
+     * @param profiles
+     */
+    public void setProfiles( java.util.List<Profile> profiles )
+    {
+        this.profiles = profiles;
+    } //-- void setProfiles( java.util.List )
+
+    /**
+     * Set specification for the SCM used by the project, such as
+     * CVS, Subversion, etc.
+     * 
+     * @param scm
+     */
+    public void setScm( Scm scm )
+    {
+        this.scm = scm;
+    } //-- void setScm( Scm )
+
+    /**
+     * Set the URL to the project's homepage.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+    /**
+     * Set the current version of the artifact produced by this
+     * project.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    private void cloneHook( Model copy )
+    {
+        copy.pomFile = pomFile;
+    }
+
+    /**
+     * The POM from which this model originated. This is transient runtime state and therefore not managed by Modello.
+     */
+    private java.io.File pomFile;
+
+    /**
+     * Gets the POM file for the corresponding project (if any).
+     *
+     * @return The POM file from which this model originated or {@code null} if this model does not belong to a local
+     *         project (e.g. describes the metadata of some artifact from the repository).
+     */
+    public java.io.File getPomFile()
+    {
+        return pomFile;
+    }
+
+    public void setPomFile( java.io.File pomFile )
+    {
+        this.pomFile = ( pomFile != null ) ? pomFile.getAbsoluteFile() : null;
+    }
+
+    /**
+     * Gets the base directory for the corresponding project (if any).
+     *
+     * @return The base directory for the corresponding project or {@code null} if this model does not belong to a local
+     *         project (e.g. describes the metadata of some artifact from the repository).
+     */
+    public java.io.File getProjectDirectory()
+    {
+        return ( pomFile != null ) ? pomFile.getParentFile() : null;
+    }
+
+    /**
+     * @return the model id as <code>groupId:artifactId:packaging:version</code>
+     */
+    public String getId()
+    {
+        StringBuilder id = new StringBuilder( 64 );
+
+        id.append( ( getGroupId() == null ) ? "[inherited]" : getGroupId() );
+        id.append( ":" );
+        id.append( getArtifactId() );
+        id.append( ":" );
+        id.append( getPackaging() );
+        id.append( ":" );
+        id.append( ( getVersion() == null ) ? "[inherited]" : getVersion() );
+
+        return id.toString();
+    }
+
+    @Override
+    public String toString()
+    {
+        return getId();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ModelBase.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ModelBase.java
new file mode 100644
index 0000000..7e6fe45
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ModelBase.java
@@ -0,0 +1,576 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         Base class for the <code>Model</code> and the
+ * <code>Profile</code> objects.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ModelBase
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field modules.
+     */
+    private java.util.List<String> modules;
+
+    /**
+     * Distribution information for a project that enables
+     * deployment of the site
+     *             and artifacts to remote web servers and
+     * repositories respectively.
+     */
+    private DistributionManagement distributionManagement;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Default dependency information for projects that inherit
+     * from this one. The
+     *             dependencies in this section are not immediately
+     * resolved. Instead, when a POM derived
+     *             from this one declares a dependency described by
+     * a matching groupId and artifactId, the
+     *             version and other values from this section are
+     * used for that dependency if they were not
+     *             already specified.
+     */
+    private DependencyManagement dependencyManagement;
+
+    /**
+     * Field dependencies.
+     */
+    private java.util.List<Dependency> dependencies;
+
+    /**
+     * Field repositories.
+     */
+    private java.util.List<Repository> repositories;
+
+    /**
+     * Field pluginRepositories.
+     */
+    private java.util.List<Repository> pluginRepositories;
+
+    /**
+     * 
+     *             
+     *             <b>Deprecated</b>. Now ignored by Maven.
+     *             
+     *           
+     */
+    private Object reports;
+
+    /**
+     * 
+     *             
+     *             This element includes the specification of
+     * report plugins to use
+     *             to generate the reports on the Maven-generated
+     * site.
+     *             These reports will be run when a user executes
+     * <code>mvn site</code>.
+     *             All of the reports will be included in the
+     * navigation bar for browsing.
+     *             
+     *           
+     */
+    private Reporting reporting;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addDependency.
+     * 
+     * @param dependency
+     */
+    public void addDependency( Dependency dependency )
+    {
+        getDependencies().add( dependency );
+    } //-- void addDependency( Dependency )
+
+    /**
+     * Method addModule.
+     * 
+     * @param string
+     */
+    public void addModule( String string )
+    {
+        getModules().add( string );
+    } //-- void addModule( String )
+
+    /**
+     * Method addPluginRepository.
+     * 
+     * @param repository
+     */
+    public void addPluginRepository( Repository repository )
+    {
+        getPluginRepositories().add( repository );
+    } //-- void addPluginRepository( Repository )
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addRepository.
+     * 
+     * @param repository
+     */
+    public void addRepository( Repository repository )
+    {
+        getRepositories().add( repository );
+    } //-- void addRepository( Repository )
+
+    /**
+     * Method clone.
+     * 
+     * @return ModelBase
+     */
+    public ModelBase clone()
+    {
+        try
+        {
+            ModelBase copy = (ModelBase) super.clone();
+
+            if ( this.modules != null )
+            {
+                copy.modules = new java.util.ArrayList<String>();
+                copy.modules.addAll( this.modules );
+            }
+
+            if ( this.distributionManagement != null )
+            {
+                copy.distributionManagement = (DistributionManagement) this.distributionManagement.clone();
+            }
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( this.dependencyManagement != null )
+            {
+                copy.dependencyManagement = (DependencyManagement) this.dependencyManagement.clone();
+            }
+
+            if ( this.dependencies != null )
+            {
+                copy.dependencies = new java.util.ArrayList<Dependency>();
+                for ( Dependency item : this.dependencies )
+                {
+                    copy.dependencies.add( ( (Dependency) item).clone() );
+                }
+            }
+
+            if ( this.repositories != null )
+            {
+                copy.repositories = new java.util.ArrayList<Repository>();
+                for ( Repository item : this.repositories )
+                {
+                    copy.repositories.add( ( (Repository) item).clone() );
+                }
+            }
+
+            if ( this.pluginRepositories != null )
+            {
+                copy.pluginRepositories = new java.util.ArrayList<Repository>();
+                for ( Repository item : this.pluginRepositories )
+                {
+                    copy.pluginRepositories.add( ( (Repository) item).clone() );
+                }
+            }
+
+            if ( this.reports != null )
+            {
+                copy.reports = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.reports );
+            }
+
+            if ( this.reporting != null )
+            {
+                copy.reporting = (Reporting) this.reporting.clone();
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ModelBase clone()
+
+    /**
+     * Method getDependencies.
+     * 
+     * @return List
+     */
+    public java.util.List<Dependency> getDependencies()
+    {
+        if ( this.dependencies == null )
+        {
+            this.dependencies = new java.util.ArrayList<Dependency>();
+        }
+
+        return this.dependencies;
+    } //-- java.util.List<Dependency> getDependencies()
+
+    /**
+     * Get default dependency information for projects that inherit
+     * from this one. The
+     *             dependencies in this section are not immediately
+     * resolved. Instead, when a POM derived
+     *             from this one declares a dependency described by
+     * a matching groupId and artifactId, the
+     *             version and other values from this section are
+     * used for that dependency if they were not
+     *             already specified.
+     * 
+     * @return DependencyManagement
+     */
+    public DependencyManagement getDependencyManagement()
+    {
+        return this.dependencyManagement;
+    } //-- DependencyManagement getDependencyManagement()
+
+    /**
+     * Get distribution information for a project that enables
+     * deployment of the site
+     *             and artifacts to remote web servers and
+     * repositories respectively.
+     * 
+     * @return DistributionManagement
+     */
+    public DistributionManagement getDistributionManagement()
+    {
+        return this.distributionManagement;
+    } //-- DistributionManagement getDistributionManagement()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Method getModules.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getModules()
+    {
+        if ( this.modules == null )
+        {
+            this.modules = new java.util.ArrayList<String>();
+        }
+
+        return this.modules;
+    } //-- java.util.List<String> getModules()
+
+    /**
+     * Method getPluginRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getPluginRepositories()
+    {
+        if ( this.pluginRepositories == null )
+        {
+            this.pluginRepositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.pluginRepositories;
+    } //-- java.util.List<Repository> getPluginRepositories()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Get this element includes the specification of report
+     * plugins to use
+     *             to generate the reports on the Maven-generated
+     * site.
+     *             These reports will be run when a user executes
+     * <code>mvn site</code>.
+     *             All of the reports will be included in the
+     * navigation bar for browsing.
+     * 
+     * @return Reporting
+     */
+    public Reporting getReporting()
+    {
+        return this.reporting;
+    } //-- Reporting getReporting()
+
+    /**
+     * Get <b>Deprecated</b>. Now ignored by Maven.
+     * 
+     * @return Object
+     */
+    public Object getReports()
+    {
+        return this.reports;
+    } //-- Object getReports()
+
+    /**
+     * Method getRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getRepositories()
+    {
+        if ( this.repositories == null )
+        {
+            this.repositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.repositories;
+    } //-- java.util.List<Repository> getRepositories()
+
+    /**
+     * Method removeDependency.
+     * 
+     * @param dependency
+     */
+    public void removeDependency( Dependency dependency )
+    {
+        getDependencies().remove( dependency );
+    } //-- void removeDependency( Dependency )
+
+    /**
+     * Method removeModule.
+     * 
+     * @param string
+     */
+    public void removeModule( String string )
+    {
+        getModules().remove( string );
+    } //-- void removeModule( String )
+
+    /**
+     * Method removePluginRepository.
+     * 
+     * @param repository
+     */
+    public void removePluginRepository( Repository repository )
+    {
+        getPluginRepositories().remove( repository );
+    } //-- void removePluginRepository( Repository )
+
+    /**
+     * Method removeRepository.
+     * 
+     * @param repository
+     */
+    public void removeRepository( Repository repository )
+    {
+        getRepositories().remove( repository );
+    } //-- void removeRepository( Repository )
+
+    /**
+     * Set this element describes all of the dependencies
+     * associated with a
+     *             project.
+     *             These dependencies are used to construct a
+     * classpath for your
+     *             project during the build process. They are
+     * automatically downloaded from the
+     *             repositories defined in this project.
+     *             See <a
+     * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
+     *             dependency mechanism</a> for more information.
+     * 
+     * @param dependencies
+     */
+    public void setDependencies( java.util.List<Dependency> dependencies )
+    {
+        this.dependencies = dependencies;
+    } //-- void setDependencies( java.util.List )
+
+    /**
+     * Set default dependency information for projects that inherit
+     * from this one. The
+     *             dependencies in this section are not immediately
+     * resolved. Instead, when a POM derived
+     *             from this one declares a dependency described by
+     * a matching groupId and artifactId, the
+     *             version and other values from this section are
+     * used for that dependency if they were not
+     *             already specified.
+     * 
+     * @param dependencyManagement
+     */
+    public void setDependencyManagement( DependencyManagement dependencyManagement )
+    {
+        this.dependencyManagement = dependencyManagement;
+    } //-- void setDependencyManagement( DependencyManagement )
+
+    /**
+     * Set distribution information for a project that enables
+     * deployment of the site
+     *             and artifacts to remote web servers and
+     * repositories respectively.
+     * 
+     * @param distributionManagement
+     */
+    public void setDistributionManagement( DistributionManagement distributionManagement )
+    {
+        this.distributionManagement = distributionManagement;
+    } //-- void setDistributionManagement( DistributionManagement )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the modules (sometimes called subprojects) to build as a
+     * part of this
+     *             project. Each module listed is a relative path
+     * to the directory containing the module.
+     *             To be consistent with the way default urls are
+     * calculated from parent, it is recommended
+     *             to have module names match artifact ids.
+     * 
+     * @param modules
+     */
+    public void setModules( java.util.List<String> modules )
+    {
+        this.modules = modules;
+    } //-- void setModules( java.util.List )
+
+    /**
+     * Set the lists of the remote repositories for discovering
+     * plugins for builds and
+     *             reports.
+     * 
+     * @param pluginRepositories
+     */
+    public void setPluginRepositories( java.util.List<Repository> pluginRepositories )
+    {
+        this.pluginRepositories = pluginRepositories;
+    } //-- void setPluginRepositories( java.util.List )
+
+    /**
+     * Set properties that can be used throughout the POM as a
+     * substitution, and
+     *             are used as filters in resources if enabled.
+     *             The format is
+     * <code>&lt;name&gt;value&lt;/name&gt;</code>.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set this element includes the specification of report
+     * plugins to use
+     *             to generate the reports on the Maven-generated
+     * site.
+     *             These reports will be run when a user executes
+     * <code>mvn site</code>.
+     *             All of the reports will be included in the
+     * navigation bar for browsing.
+     * 
+     * @param reporting
+     */
+    public void setReporting( Reporting reporting )
+    {
+        this.reporting = reporting;
+    } //-- void setReporting( Reporting )
+
+    /**
+     * Set <b>Deprecated</b>. Now ignored by Maven.
+     * 
+     * @param reports
+     */
+    public void setReports( Object reports )
+    {
+        this.reports = reports;
+    } //-- void setReports( Object )
+
+    /**
+     * Set the lists of the remote repositories for discovering
+     * dependencies and
+     *             extensions.
+     * 
+     * @param repositories
+     */
+    public void setRepositories( java.util.List<Repository> repositories )
+    {
+        this.repositories = repositories;
+    } //-- void setRepositories( java.util.List )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Notifier.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Notifier.java
new file mode 100644
index 0000000..cd9de6e
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Notifier.java
@@ -0,0 +1,291 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Configures one method for notifying users/developers when a
+ * build breaks.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Notifier
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The mechanism used to deliver notifications.
+     */
+    private String type = "mail";
+
+    /**
+     * Whether to send notifications on error.
+     */
+    private boolean sendOnError = true;
+
+    /**
+     * Whether to send notifications on failure.
+     */
+    private boolean sendOnFailure = true;
+
+    /**
+     * Whether to send notifications on success.
+     */
+    private boolean sendOnSuccess = true;
+
+    /**
+     * Whether to send notifications on warning.
+     */
+    private boolean sendOnWarning = true;
+
+    /**
+     * 
+     *             
+     *             <b>Deprecated</b>. Where to send the
+     * notification to - eg email address.
+     *             
+     *           
+     */
+    private String address;
+
+    /**
+     * Field configuration.
+     */
+    private java.util.Properties configuration;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addConfiguration.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addConfiguration( String key, String value )
+    {
+        getConfiguration().put( key, value );
+    } //-- void addConfiguration( String, String )
+
+    /**
+     * Method clone.
+     * 
+     * @return Notifier
+     */
+    public Notifier clone()
+    {
+        try
+        {
+            Notifier copy = (Notifier) super.clone();
+
+            if ( this.configuration != null )
+            {
+                copy.configuration = (java.util.Properties) this.configuration.clone();
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Notifier clone()
+
+    /**
+     * Get <b>Deprecated</b>. Where to send the notification to -
+     * eg email address.
+     * 
+     * @return String
+     */
+    public String getAddress()
+    {
+        return this.address;
+    } //-- String getAddress()
+
+    /**
+     * Method getConfiguration.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getConfiguration()
+    {
+        if ( this.configuration == null )
+        {
+            this.configuration = new java.util.Properties();
+        }
+
+        return this.configuration;
+    } //-- java.util.Properties getConfiguration()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the mechanism used to deliver notifications.
+     * 
+     * @return String
+     */
+    public String getType()
+    {
+        return this.type;
+    } //-- String getType()
+
+    /**
+     * Get whether to send notifications on error.
+     * 
+     * @return boolean
+     */
+    public boolean isSendOnError()
+    {
+        return this.sendOnError;
+    } //-- boolean isSendOnError()
+
+    /**
+     * Get whether to send notifications on failure.
+     * 
+     * @return boolean
+     */
+    public boolean isSendOnFailure()
+    {
+        return this.sendOnFailure;
+    } //-- boolean isSendOnFailure()
+
+    /**
+     * Get whether to send notifications on success.
+     * 
+     * @return boolean
+     */
+    public boolean isSendOnSuccess()
+    {
+        return this.sendOnSuccess;
+    } //-- boolean isSendOnSuccess()
+
+    /**
+     * Get whether to send notifications on warning.
+     * 
+     * @return boolean
+     */
+    public boolean isSendOnWarning()
+    {
+        return this.sendOnWarning;
+    } //-- boolean isSendOnWarning()
+
+    /**
+     * Set <b>Deprecated</b>. Where to send the notification to -
+     * eg email address.
+     * 
+     * @param address
+     */
+    public void setAddress( String address )
+    {
+        this.address = address;
+    } //-- void setAddress( String )
+
+    /**
+     * Set extended configuration specific to this notifier goes
+     * here.
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( java.util.Properties configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( java.util.Properties )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set whether to send notifications on error.
+     * 
+     * @param sendOnError
+     */
+    public void setSendOnError( boolean sendOnError )
+    {
+        this.sendOnError = sendOnError;
+    } //-- void setSendOnError( boolean )
+
+    /**
+     * Set whether to send notifications on failure.
+     * 
+     * @param sendOnFailure
+     */
+    public void setSendOnFailure( boolean sendOnFailure )
+    {
+        this.sendOnFailure = sendOnFailure;
+    } //-- void setSendOnFailure( boolean )
+
+    /**
+     * Set whether to send notifications on success.
+     * 
+     * @param sendOnSuccess
+     */
+    public void setSendOnSuccess( boolean sendOnSuccess )
+    {
+        this.sendOnSuccess = sendOnSuccess;
+    } //-- void setSendOnSuccess( boolean )
+
+    /**
+     * Set whether to send notifications on warning.
+     * 
+     * @param sendOnWarning
+     */
+    public void setSendOnWarning( boolean sendOnWarning )
+    {
+        this.sendOnWarning = sendOnWarning;
+    } //-- void setSendOnWarning( boolean )
+
+    /**
+     * Set the mechanism used to deliver notifications.
+     * 
+     * @param type
+     */
+    public void setType( String type )
+    {
+        this.type = type;
+    } //-- void setType( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Organization.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Organization.java
new file mode 100644
index 0000000..7d561fa
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Organization.java
@@ -0,0 +1,136 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Specifies the organization that produces this project.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Organization
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The full name of the organization.
+     */
+    private String name;
+
+    /**
+     * The URL to the organization's home page.
+     */
+    private String url;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Organization
+     */
+    public Organization clone()
+    {
+        try
+        {
+            Organization copy = (Organization) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Organization clone()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the full name of the organization.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the URL to the organization's home page.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the full name of the organization.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the URL to the organization's home page.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Parent.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Parent.java
new file mode 100644
index 0000000..03f4bd9
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Parent.java
@@ -0,0 +1,285 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;parent&gt;</code> element contains
+ * information required to locate the parent project from which
+ *         this project will inherit from.
+ *         <strong>Note:</strong> The children of this element are
+ * not interpolated and must be given as literal values.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Parent
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The group id of the parent project to inherit from.
+     */
+    private String groupId;
+
+    /**
+     * The artifact id of the parent project to inherit from.
+     */
+    private String artifactId;
+
+    /**
+     * The version of the parent project to inherit.
+     */
+    private String version;
+
+    /**
+     * 
+     *             
+     *             The relative path of the parent
+     * <code>pom.xml</code> file within the check out.
+     *             If not specified, it defaults to
+     * <code>../pom.xml</code>.
+     *             Maven looks for the parent POM first in this
+     * location on
+     *             the filesystem, then the local repository, and
+     * lastly in the remote repo.
+     *             <code>relativePath</code> allows you to select a
+     * different location,
+     *             for example when your structure is flat, or
+     * deeper without an intermediate parent POM.
+     *             However, the group ID, artifact ID and version
+     * are still required,
+     *             and must match the file in the location given or
+     * it will revert to the repository for the POM.
+     *             This feature is only for enhancing the
+     * development in a local checkout of that project.
+     *             Set the value to an empty string in case you
+     * want to disable the feature and always resolve
+     *             the parent POM from the repositories.
+     *             
+     *           
+     */
+    private String relativePath = "../pom.xml";
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Parent
+     */
+    public Parent clone()
+    {
+        try
+        {
+            Parent copy = (Parent) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Parent clone()
+
+    /**
+     * Get the artifact id of the parent project to inherit from.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the group id of the parent project to inherit from.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the relative path of the parent <code>pom.xml</code>
+     * file within the check out.
+     *             If not specified, it defaults to
+     * <code>../pom.xml</code>.
+     *             Maven looks for the parent POM first in this
+     * location on
+     *             the filesystem, then the local repository, and
+     * lastly in the remote repo.
+     *             <code>relativePath</code> allows you to select a
+     * different location,
+     *             for example when your structure is flat, or
+     * deeper without an intermediate parent POM.
+     *             However, the group ID, artifact ID and version
+     * are still required,
+     *             and must match the file in the location given or
+     * it will revert to the repository for the POM.
+     *             This feature is only for enhancing the
+     * development in a local checkout of that project.
+     *             Set the value to an empty string in case you
+     * want to disable the feature and always resolve
+     *             the parent POM from the repositories.
+     * 
+     * @return String
+     */
+    public String getRelativePath()
+    {
+        return this.relativePath;
+    } //-- String getRelativePath()
+
+    /**
+     * Get the version of the parent project to inherit.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the artifact id of the parent project to inherit from.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the group id of the parent project to inherit from.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the relative path of the parent <code>pom.xml</code>
+     * file within the check out.
+     *             If not specified, it defaults to
+     * <code>../pom.xml</code>.
+     *             Maven looks for the parent POM first in this
+     * location on
+     *             the filesystem, then the local repository, and
+     * lastly in the remote repo.
+     *             <code>relativePath</code> allows you to select a
+     * different location,
+     *             for example when your structure is flat, or
+     * deeper without an intermediate parent POM.
+     *             However, the group ID, artifact ID and version
+     * are still required,
+     *             and must match the file in the location given or
+     * it will revert to the repository for the POM.
+     *             This feature is only for enhancing the
+     * development in a local checkout of that project.
+     *             Set the value to an empty string in case you
+     * want to disable the feature and always resolve
+     *             the parent POM from the repositories.
+     * 
+     * @param relativePath
+     */
+    public void setRelativePath( String relativePath )
+    {
+        this.relativePath = relativePath;
+    } //-- void setRelativePath( String )
+
+    /**
+     * Set the version of the parent project to inherit.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    /**
+     * @return the id as <code>groupId:artifactId:version</code>
+     */
+    public String getId()
+    {
+        StringBuilder id = new StringBuilder( 64 );
+
+        id.append( getGroupId() );
+        id.append( ":" );
+        id.append( getArtifactId() );
+        id.append( ":" );
+        id.append( "pom" );
+        id.append( ":" );
+        id.append( getVersion() );
+
+        return id.toString();
+    }
+
+    @Override
+    public String toString()
+    {
+        return getId();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/PatternSet.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/PatternSet.java
new file mode 100644
index 0000000..56dd3c9
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/PatternSet.java
@@ -0,0 +1,230 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Definition of include or exclude patterns.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PatternSet
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field includes.
+     */
+    private java.util.List<String> includes;
+
+    /**
+     * Field excludes.
+     */
+    private java.util.List<String> excludes;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExclude.
+     * 
+     * @param string
+     */
+    public void addExclude( String string )
+    {
+        getExcludes().add( string );
+    } //-- void addExclude( String )
+
+    /**
+     * Method addInclude.
+     * 
+     * @param string
+     */
+    public void addInclude( String string )
+    {
+        getIncludes().add( string );
+    } //-- void addInclude( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return PatternSet
+     */
+    public PatternSet clone()
+    {
+        try
+        {
+            PatternSet copy = (PatternSet) super.clone();
+
+            if ( this.includes != null )
+            {
+                copy.includes = new java.util.ArrayList<String>();
+                copy.includes.addAll( this.includes );
+            }
+
+            if ( this.excludes != null )
+            {
+                copy.excludes = new java.util.ArrayList<String>();
+                copy.excludes.addAll( this.excludes );
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PatternSet clone()
+
+    /**
+     * Method getExcludes.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getExcludes()
+    {
+        if ( this.excludes == null )
+        {
+            this.excludes = new java.util.ArrayList<String>();
+        }
+
+        return this.excludes;
+    } //-- java.util.List<String> getExcludes()
+
+    /**
+     * Method getIncludes.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getIncludes()
+    {
+        if ( this.includes == null )
+        {
+            this.includes = new java.util.ArrayList<String>();
+        }
+
+        return this.includes;
+    } //-- java.util.List<String> getIncludes()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Method removeExclude.
+     * 
+     * @param string
+     */
+    public void removeExclude( String string )
+    {
+        getExcludes().remove( string );
+    } //-- void removeExclude( String )
+
+    /**
+     * Method removeInclude.
+     * 
+     * @param string
+     */
+    public void removeInclude( String string )
+    {
+        getIncludes().remove( string );
+    } //-- void removeInclude( String )
+
+    /**
+     * Set a list of patterns to exclude, e.g.
+     * <code>**&#47;*.xml</code>
+     * 
+     * @param excludes
+     */
+    public void setExcludes( java.util.List<String> excludes )
+    {
+        this.excludes = excludes;
+    } //-- void setExcludes( java.util.List )
+
+    /**
+     * Set a list of patterns to include, e.g.
+     * <code>**&#47;*.xml</code>.
+     * 
+     * @param includes
+     */
+    public void setIncludes( java.util.List<String> includes )
+    {
+        this.includes = includes;
+    } //-- void setIncludes( java.util.List )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    
+            
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString()
+    {
+        StringBuilder sb = new StringBuilder( 128 );
+
+        sb.append("PatternSet [includes: {");
+        for (java.util.Iterator i = getIncludes().iterator(); i.hasNext(); )
+        {
+            String str = (String) i.next();
+            sb.append(str).append(", ");
+        }
+        if (sb.substring(sb.length() - 2).equals(", ")) sb.delete(sb.length() - 2, sb.length());
+
+        sb.append("}, excludes: {");
+        for (java.util.Iterator i = getExcludes().iterator(); i.hasNext(); )
+        {
+            String str = (String) i.next();
+            sb.append(str).append(", ");
+        }
+        if (sb.substring(sb.length() - 2).equals(", ")) sb.delete(sb.length() - 2, sb.length());
+
+        sb.append("}]");
+        return sb.toString();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Plugin.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Plugin.java
new file mode 100644
index 0000000..6819e38
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Plugin.java
@@ -0,0 +1,462 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;plugin&gt;</code> element contains
+ * informations required for a plugin.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Plugin
+    extends ConfigurationContainer
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The group ID of the plugin in the repository.
+     */
+    private String groupId = "org.apache.maven.plugins";
+
+    /**
+     * The artifact ID of the plugin in the repository.
+     */
+    private String artifactId;
+
+    /**
+     * The version (or valid range of versions) of the plugin to be
+     * used.
+     */
+    private String version;
+
+    /**
+     * 
+     *             
+     *             Whether to load Maven extensions (such as
+     * packaging and type handlers) from
+     *             this plugin. For performance reasons, this
+     * should only be enabled when necessary. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     *             
+     *           
+     */
+    private String extensions;
+
+    /**
+     * Field executions.
+     */
+    private java.util.List<PluginExecution> executions;
+
+    /**
+     * Field dependencies.
+     */
+    private java.util.List<Dependency> dependencies;
+
+    /**
+     * 
+     *             
+     *             <b>Deprecated</b>. Unused by Maven.
+     *             
+     *           
+     */
+    private Object goals;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addDependency.
+     * 
+     * @param dependency
+     */
+    public void addDependency( Dependency dependency )
+    {
+        getDependencies().add( dependency );
+    } //-- void addDependency( Dependency )
+
+    /**
+     * Method addExecution.
+     * 
+     * @param pluginExecution
+     */
+    public void addExecution( PluginExecution pluginExecution )
+    {
+        getExecutions().add( pluginExecution );
+    } //-- void addExecution( PluginExecution )
+
+    /**
+     * Method clone.
+     * 
+     * @return Plugin
+     */
+    public Plugin clone()
+    {
+        try
+        {
+            Plugin copy = (Plugin) super.clone();
+
+            if ( this.executions != null )
+            {
+                copy.executions = new java.util.ArrayList<PluginExecution>();
+                for ( PluginExecution item : this.executions )
+                {
+                    copy.executions.add( ( (PluginExecution) item).clone() );
+                }
+            }
+
+            if ( this.dependencies != null )
+            {
+                copy.dependencies = new java.util.ArrayList<Dependency>();
+                for ( Dependency item : this.dependencies )
+                {
+                    copy.dependencies.add( ( (Dependency) item).clone() );
+                }
+            }
+
+            if ( this.goals != null )
+            {
+                copy.goals = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.goals );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Plugin clone()
+
+    /**
+     * Get the artifact ID of the plugin in the repository.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Method getDependencies.
+     * 
+     * @return List
+     */
+    public java.util.List<Dependency> getDependencies()
+    {
+        if ( this.dependencies == null )
+        {
+            this.dependencies = new java.util.ArrayList<Dependency>();
+        }
+
+        return this.dependencies;
+    } //-- java.util.List<Dependency> getDependencies()
+
+    /**
+     * Method getExecutions.
+     * 
+     * @return List
+     */
+    public java.util.List<PluginExecution> getExecutions()
+    {
+        if ( this.executions == null )
+        {
+            this.executions = new java.util.ArrayList<PluginExecution>();
+        }
+
+        return this.executions;
+    } //-- java.util.List<PluginExecution> getExecutions()
+
+    /**
+     * Get whether to load Maven extensions (such as packaging and
+     * type handlers) from
+     *             this plugin. For performance reasons, this
+     * should only be enabled when necessary. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @return String
+     */
+    public String getExtensions()
+    {
+        return this.extensions;
+    } //-- String getExtensions()
+
+    /**
+     * Get <b>Deprecated</b>. Unused by Maven.
+     * 
+     * @return Object
+     */
+    public Object getGoals()
+    {
+        return this.goals;
+    } //-- Object getGoals()
+
+    /**
+     * Get the group ID of the plugin in the repository.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get the version (or valid range of versions) of the plugin
+     * to be used.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Method removeDependency.
+     * 
+     * @param dependency
+     */
+    public void removeDependency( Dependency dependency )
+    {
+        getDependencies().remove( dependency );
+    } //-- void removeDependency( Dependency )
+
+    /**
+     * Method removeExecution.
+     * 
+     * @param pluginExecution
+     */
+    public void removeExecution( PluginExecution pluginExecution )
+    {
+        getExecutions().remove( pluginExecution );
+    } //-- void removeExecution( PluginExecution )
+
+    /**
+     * Set the artifact ID of the plugin in the repository.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set additional dependencies that this project needs to
+     * introduce to the plugin's
+     *             classloader.
+     * 
+     * @param dependencies
+     */
+    public void setDependencies( java.util.List<Dependency> dependencies )
+    {
+        this.dependencies = dependencies;
+    } //-- void setDependencies( java.util.List )
+
+    /**
+     * Set multiple specifications of a set of goals to execute
+     * during the build
+     *             lifecycle, each having (possibly) a different
+     * configuration.
+     * 
+     * @param executions
+     */
+    public void setExecutions( java.util.List<PluginExecution> executions )
+    {
+        this.executions = executions;
+    } //-- void setExecutions( java.util.List )
+
+    /**
+     * Set whether to load Maven extensions (such as packaging and
+     * type handlers) from
+     *             this plugin. For performance reasons, this
+     * should only be enabled when necessary. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @param extensions
+     */
+    public void setExtensions( String extensions )
+    {
+        this.extensions = extensions;
+    } //-- void setExtensions( String )
+
+    /**
+     * Set <b>Deprecated</b>. Unused by Maven.
+     * 
+     * @param goals
+     */
+    public void setGoals( Object goals )
+    {
+        this.goals = goals;
+    } //-- void setGoals( Object )
+
+    /**
+     * Set the group ID of the plugin in the repository.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set the version (or valid range of versions) of the plugin
+     * to be used.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    public boolean isExtensions()
+    {
+        return ( extensions != null ) ? Boolean.parseBoolean( extensions ) : false;
+    }
+
+    public void setExtensions( boolean extensions )
+    {
+        this.extensions = String.valueOf( extensions );
+    }
+
+    private java.util.Map<String, PluginExecution> executionMap = null;
+
+    /**
+     * Reset the <code>executionMap</code> field to <code>null</code>
+     */
+    public void flushExecutionMap()
+    {
+        this.executionMap = null;
+    }
+
+    /**
+     * @return a Map of executions field with <code>PluginExecution#getId()</code> as key
+     * @see org.apache.maven.model.PluginExecution#getId()
+     */
+    public java.util.Map<String, PluginExecution> getExecutionsAsMap()
+    {
+        if ( executionMap == null )
+        {
+            executionMap = new java.util.LinkedHashMap<String, PluginExecution>();
+            if ( getExecutions() != null )
+            {
+                for ( java.util.Iterator<PluginExecution> i = getExecutions().iterator(); i.hasNext(); )
+                {
+                    PluginExecution exec = (PluginExecution) i.next();
+
+                    if ( executionMap.containsKey( exec.getId() ) )
+                    {
+                        throw new IllegalStateException( "You cannot have two plugin executions with the same (or missing) <id/> elements.\nOffending execution\n\nId: \'" + exec.getId() + "\'\nPlugin:\'" + getKey() + "\'\n\n" );
+                    }
+
+                    executionMap.put( exec.getId(), exec );
+                }
+            }
+        }
+
+        return executionMap;
+    }
+
+    /**
+     * Gets the identifier of the plugin.
+     *
+     * @return The plugin id in the form {@code <groupId>:<artifactId>:<version>}, never {@code null}.
+     */
+    public String getId()
+    {
+        StringBuilder id = new StringBuilder( 128 );
+
+        id.append( ( getGroupId() == null ) ? "[unknown-group-id]" : getGroupId() );
+        id.append( ":" );
+        id.append( ( getArtifactId() == null ) ? "[unknown-artifact-id]" : getArtifactId() );
+        id.append( ":" );
+        id.append( ( getVersion() == null ) ? "[unknown-version]" : getVersion() );
+
+        return id.toString();
+    }
+
+    //TODO we shall reset key variable when groupId/artifactId change
+    private String key = null;
+    /**
+     * @return the key of the plugin, ie <code>groupId:artifactId</code>
+     */
+    public String getKey()
+    {
+        if ( key == null )
+        {
+            key = constructKey( groupId, artifactId );
+        }
+        return key;
+    }
+
+    /**
+     * @param groupId
+     * @param artifactId
+     * @return the key of the plugin, ie <code>groupId:artifactId</code>
+     */
+    public static String constructKey( String groupId, String artifactId )
+    {
+        return groupId + ":" + artifactId;
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals( Object other )
+    {
+        if ( other instanceof Plugin )
+        {
+            Plugin otherPlugin = (Plugin) other;
+
+            return getKey().equals( otherPlugin.getKey() );
+        }
+
+        return false;
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode()
+    {
+        return getKey().hashCode();
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString()
+    {
+        return "Plugin [" + getKey() + "]";
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginConfiguration.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginConfiguration.java
new file mode 100644
index 0000000..e6f2445
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginConfiguration.java
@@ -0,0 +1,96 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Contains the plugins management informations for the project.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PluginConfiguration
+    extends PluginContainer
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Default plugin information to be made available for
+     * reference by projects
+     *             derived from this one. This plugin configuration
+     * will not be resolved or bound to the
+     *             lifecycle unless referenced. Any local
+     * configuration for a given plugin will override
+     *             the plugin's entire definition here.
+     */
+    private PluginManagement pluginManagement;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return PluginConfiguration
+     */
+    public PluginConfiguration clone()
+    {
+        try
+        {
+            PluginConfiguration copy = (PluginConfiguration) super.clone();
+
+            if ( this.pluginManagement != null )
+            {
+                copy.pluginManagement = (PluginManagement) this.pluginManagement.clone();
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PluginConfiguration clone()
+
+    /**
+     * Get default plugin information to be made available for
+     * reference by projects
+     *             derived from this one. This plugin configuration
+     * will not be resolved or bound to the
+     *             lifecycle unless referenced. Any local
+     * configuration for a given plugin will override
+     *             the plugin's entire definition here.
+     * 
+     * @return PluginManagement
+     */
+    public PluginManagement getPluginManagement()
+    {
+        return this.pluginManagement;
+    } //-- PluginManagement getPluginManagement()
+
+    /**
+     * Set default plugin information to be made available for
+     * reference by projects
+     *             derived from this one. This plugin configuration
+     * will not be resolved or bound to the
+     *             lifecycle unless referenced. Any local
+     * configuration for a given plugin will override
+     *             the plugin's entire definition here.
+     * 
+     * @param pluginManagement
+     */
+    public void setPluginManagement( PluginManagement pluginManagement )
+    {
+        this.pluginManagement = pluginManagement;
+    } //-- void setPluginManagement( PluginManagement )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginContainer.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginContainer.java
new file mode 100644
index 0000000..7858213
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginContainer.java
@@ -0,0 +1,180 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Contains the plugins informations for the project.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PluginContainer
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field plugins.
+     */
+    private java.util.List<Plugin> plugins;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addPlugin.
+     * 
+     * @param plugin
+     */
+    public void addPlugin( Plugin plugin )
+    {
+        getPlugins().add( plugin );
+    } //-- void addPlugin( Plugin )
+
+    /**
+     * Method clone.
+     * 
+     * @return PluginContainer
+     */
+    public PluginContainer clone()
+    {
+        try
+        {
+            PluginContainer copy = (PluginContainer) super.clone();
+
+            if ( this.plugins != null )
+            {
+                copy.plugins = new java.util.ArrayList<Plugin>();
+                for ( Plugin item : this.plugins )
+                {
+                    copy.plugins.add( ( (Plugin) item).clone() );
+                }
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PluginContainer clone()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Method getPlugins.
+     * 
+     * @return List
+     */
+    public java.util.List<Plugin> getPlugins()
+    {
+        if ( this.plugins == null )
+        {
+            this.plugins = new java.util.ArrayList<Plugin>();
+        }
+
+        return this.plugins;
+    } //-- java.util.List<Plugin> getPlugins()
+
+    /**
+     * Method removePlugin.
+     * 
+     * @param plugin
+     */
+    public void removePlugin( Plugin plugin )
+    {
+        getPlugins().remove( plugin );
+    } //-- void removePlugin( Plugin )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the list of plugins to use.
+     * 
+     * @param plugins
+     */
+    public void setPlugins( java.util.List<Plugin> plugins )
+    {
+        this.plugins = plugins;
+    } //-- void setPlugins( java.util.List )
+
+    
+            
+    java.util.Map<String, Plugin> pluginMap;
+
+    /**
+     * Reset the <code>pluginsMap</code> field to <code>null</code>
+     */
+    public synchronized void flushPluginMap()
+    {
+        this.pluginMap = null;
+    }
+
+    /**
+     * @return a Map of plugins field with <code>Plugins#getKey()</code> as key
+     * @see org.apache.maven.model.Plugin#getKey()
+     */
+    public synchronized java.util.Map<String, Plugin> getPluginsAsMap()
+    {
+        if ( pluginMap == null )
+        {
+            pluginMap = new java.util.LinkedHashMap<String, Plugin>();
+            if ( plugins != null )
+            {
+                for ( java.util.Iterator<Plugin> it = plugins.iterator(); it.hasNext(); )
+                {
+                    Plugin plugin = (Plugin) it.next();
+                    pluginMap.put( plugin.getKey(), plugin );
+                }
+            }
+        }
+
+        return pluginMap;
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginExecution.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginExecution.java
new file mode 100644
index 0000000..411296d
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginExecution.java
@@ -0,0 +1,236 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;execution&gt;</code> element contains
+ * informations required for the
+ *         execution of a plugin.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PluginExecution
+    extends ConfigurationContainer
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The identifier of this execution for labelling the goals
+     * during the build,
+     *             and for matching executions to merge during
+     * inheritance and profile injection.
+     */
+    private String id = "default";
+
+    /**
+     * The build lifecycle phase to bind the goals in this
+     * execution to. If omitted,
+     *             the goals will be bound to the default phase
+     * specified by the plugin. 
+     */
+    private String phase;
+
+    /**
+     * 
+     *             
+     *             The priority of this execution compared to other
+     * executions which are bound to the same phase.
+     *             <strong>Warning:</strong> This is an internal
+     * utility property that is only public for technical reasons,
+     *             it is not part of the public API. In particular,
+     * this property can be changed or deleted without prior
+     *             notice.
+     *             
+     *           
+     */
+    private int priority = 0;
+
+    /**
+     * Field goals.
+     */
+    private java.util.List<String> goals;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addGoal.
+     * 
+     * @param string
+     */
+    public void addGoal( String string )
+    {
+        getGoals().add( string );
+    } //-- void addGoal( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return PluginExecution
+     */
+    public PluginExecution clone()
+    {
+        try
+        {
+            PluginExecution copy = (PluginExecution) super.clone();
+
+            if ( this.goals != null )
+            {
+                copy.goals = new java.util.ArrayList<String>();
+                copy.goals.addAll( this.goals );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PluginExecution clone()
+
+    /**
+     * Method getGoals.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getGoals()
+    {
+        if ( this.goals == null )
+        {
+            this.goals = new java.util.ArrayList<String>();
+        }
+
+        return this.goals;
+    } //-- java.util.List<String> getGoals()
+
+    /**
+     * Get the identifier of this execution for labelling the goals
+     * during the build,
+     *             and for matching executions to merge during
+     * inheritance and profile injection.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Get the build lifecycle phase to bind the goals in this
+     * execution to. If omitted,
+     *             the goals will be bound to the default phase
+     * specified by the plugin.
+     * 
+     * @return String
+     */
+    public String getPhase()
+    {
+        return this.phase;
+    } //-- String getPhase()
+
+    /**
+     * Get the priority of this execution compared to other
+     * executions which are bound to the same phase.
+     *             <strong>Warning:</strong> This is an internal
+     * utility property that is only public for technical reasons,
+     *             it is not part of the public API. In particular,
+     * this property can be changed or deleted without prior
+     *             notice.
+     * 
+     * @return int
+     */
+    public int getPriority()
+    {
+        return this.priority;
+    } //-- int getPriority()
+
+    /**
+     * Method removeGoal.
+     * 
+     * @param string
+     */
+    public void removeGoal( String string )
+    {
+        getGoals().remove( string );
+    } //-- void removeGoal( String )
+
+    /**
+     * Set the goals to execute with the given configuration.
+     * 
+     * @param goals
+     */
+    public void setGoals( java.util.List<String> goals )
+    {
+        this.goals = goals;
+    } //-- void setGoals( java.util.List )
+
+    /**
+     * Set the identifier of this execution for labelling the goals
+     * during the build,
+     *             and for matching executions to merge during
+     * inheritance and profile injection.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the build lifecycle phase to bind the goals in this
+     * execution to. If omitted,
+     *             the goals will be bound to the default phase
+     * specified by the plugin.
+     * 
+     * @param phase
+     */
+    public void setPhase( String phase )
+    {
+        this.phase = phase;
+    } //-- void setPhase( String )
+
+    /**
+     * Set the priority of this execution compared to other
+     * executions which are bound to the same phase.
+     *             <strong>Warning:</strong> This is an internal
+     * utility property that is only public for technical reasons,
+     *             it is not part of the public API. In particular,
+     * this property can be changed or deleted without prior
+     *             notice.
+     * 
+     * @param priority
+     */
+    public void setPriority( int priority )
+    {
+        this.priority = priority;
+    } //-- void setPriority( int )
+
+    
+            
+    public static final String DEFAULT_EXECUTION_ID = "default";
+
+    @Override
+    public String toString()
+    {
+        return getId();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginManagement.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginManagement.java
new file mode 100644
index 0000000..ea65220
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/PluginManagement.java
@@ -0,0 +1,45 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Section for management of default plugin information for use in
+ * a group of POMs.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PluginManagement
+    extends PluginContainer
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return PluginManagement
+     */
+    public PluginManagement clone()
+    {
+        try
+        {
+            PluginManagement copy = (PluginManagement) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PluginManagement clone()
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Prerequisites.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Prerequisites.java
new file mode 100644
index 0000000..4e607ee
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Prerequisites.java
@@ -0,0 +1,141 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Describes the prerequisites a project can have.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Prerequisites
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             For a plugin project, the minimum version of
+     * Maven required to use
+     *             the resulting plugin.<br />
+     *             For specifying the minimum version of Maven
+     * required to build a
+     *             project, this element is <b>deprecated</b>. Use
+     * the Maven Enforcer
+     *             Plugin's <a
+     * href="https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html"><code>requireMavenVersion</code></a>
+     *             rule instead.
+     *             
+     *           
+     */
+    private String maven = "2.0";
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Prerequisites
+     */
+    public Prerequisites clone()
+    {
+        try
+        {
+            Prerequisites copy = (Prerequisites) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Prerequisites clone()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get for a plugin project, the minimum version of Maven
+     * required to use
+     *             the resulting plugin.<br />
+     *             For specifying the minimum version of Maven
+     * required to build a
+     *             project, this element is <b>deprecated</b>. Use
+     * the Maven Enforcer
+     *             Plugin's <a
+     * href="https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html"><code>requireMavenVersion</code></a>
+     *             rule instead.
+     * 
+     * @return String
+     */
+    public String getMaven()
+    {
+        return this.maven;
+    } //-- String getMaven()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set for a plugin project, the minimum version of Maven
+     * required to use
+     *             the resulting plugin.<br />
+     *             For specifying the minimum version of Maven
+     * required to build a
+     *             project, this element is <b>deprecated</b>. Use
+     * the Maven Enforcer
+     *             Plugin's <a
+     * href="https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html"><code>requireMavenVersion</code></a>
+     *             rule instead.
+     * 
+     * @param maven
+     */
+    public void setMaven( String maven )
+    {
+        this.maven = maven;
+    } //-- void setMaven( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Profile.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Profile.java
new file mode 100644
index 0000000..e074319
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Profile.java
@@ -0,0 +1,180 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Modifications to the build process which is activated based on
+ * environmental
+ *         parameters or command line arguments.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Profile
+    extends ModelBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The identifier of this build profile. This is used for
+     * command line
+     *             activation, and identifies profiles to be
+     * merged.
+     *           
+     */
+    private String id = "default";
+
+    /**
+     * The conditional logic which will automatically trigger the
+     * inclusion of this
+     *             profile.
+     */
+    private Activation activation;
+
+    /**
+     * Information required to build the project.
+     */
+    private BuildBase build;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Profile
+     */
+    public Profile clone()
+    {
+        try
+        {
+            Profile copy = (Profile) super.clone();
+
+            if ( this.activation != null )
+            {
+                copy.activation = (Activation) this.activation.clone();
+            }
+
+            if ( this.build != null )
+            {
+                copy.build = (BuildBase) this.build.clone();
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Profile clone()
+
+    /**
+     * Get the conditional logic which will automatically trigger
+     * the inclusion of this
+     *             profile.
+     * 
+     * @return Activation
+     */
+    public Activation getActivation()
+    {
+        return this.activation;
+    } //-- Activation getActivation()
+
+    /**
+     * Get information required to build the project.
+     * 
+     * @return BuildBase
+     */
+    public BuildBase getBuild()
+    {
+        return this.build;
+    } //-- BuildBase getBuild()
+
+    /**
+     * Get the identifier of this build profile. This is used for
+     * command line
+     *             activation, and identifies profiles to be
+     * merged.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Set the conditional logic which will automatically trigger
+     * the inclusion of this
+     *             profile.
+     * 
+     * @param activation
+     */
+    public void setActivation( Activation activation )
+    {
+        this.activation = activation;
+    } //-- void setActivation( Activation )
+
+    /**
+     * Set information required to build the project.
+     * 
+     * @param build
+     */
+    public void setBuild( BuildBase build )
+    {
+        this.build = build;
+    } //-- void setBuild( BuildBase )
+
+    /**
+     * Set the identifier of this build profile. This is used for
+     * command line
+     *             activation, and identifies profiles to be
+     * merged.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    
+            
+    public static final String SOURCE_POM = "pom";
+
+    public static final String SOURCE_SETTINGS = "settings.xml";
+
+    // We don't want this to be parseable...it's sort of 'hidden'
+    // default source for this profile is in the pom itself.
+    private String source = SOURCE_POM;
+
+    public void setSource( String source )
+    {
+        this.source = source;
+    }
+
+    public String getSource()
+    {
+        return source;
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString()
+    {
+        return "Profile {id: " + getId() + ", source: " + getSource() + "}";
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Relocation.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Relocation.java
new file mode 100644
index 0000000..f95a2d5
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Relocation.java
@@ -0,0 +1,191 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Describes where an artifact has moved to. If any of the values
+ * are omitted, it is
+ *         assumed to be the same as it was before.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Relocation
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The group ID the artifact has moved to.
+     */
+    private String groupId;
+
+    /**
+     * The new artifact ID of the artifact.
+     */
+    private String artifactId;
+
+    /**
+     * The new version of the artifact.
+     */
+    private String version;
+
+    /**
+     * An additional message to show the user about the move, such
+     * as the reason.
+     */
+    private String message;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Relocation
+     */
+    public Relocation clone()
+    {
+        try
+        {
+            Relocation copy = (Relocation) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Relocation clone()
+
+    /**
+     * Get the new artifact ID of the artifact.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the group ID the artifact has moved to.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get an additional message to show the user about the move,
+     * such as the reason.
+     * 
+     * @return String
+     */
+    public String getMessage()
+    {
+        return this.message;
+    } //-- String getMessage()
+
+    /**
+     * Get the new version of the artifact.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the new artifact ID of the artifact.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the group ID the artifact has moved to.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set an additional message to show the user about the move,
+     * such as the reason.
+     * 
+     * @param message
+     */
+    public void setMessage( String message )
+    {
+        this.message = message;
+    } //-- void setMessage( String )
+
+    /**
+     * Set the new version of the artifact.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ReportPlugin.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ReportPlugin.java
new file mode 100644
index 0000000..9b0989a
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ReportPlugin.java
@@ -0,0 +1,245 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;plugin&gt;</code> element contains
+ * informations required for a report plugin.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ReportPlugin
+    extends ConfigurationContainer
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The group ID of the reporting plugin in the repository.
+     */
+    private String groupId = "org.apache.maven.plugins";
+
+    /**
+     * The artifact ID of the reporting plugin in the repository.
+     */
+    private String artifactId;
+
+    /**
+     * The version of the reporting plugin to be used.
+     */
+    private String version;
+
+    /**
+     * Field reportSets.
+     */
+    private java.util.List<ReportSet> reportSets;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addReportSet.
+     * 
+     * @param reportSet
+     */
+    public void addReportSet( ReportSet reportSet )
+    {
+        getReportSets().add( reportSet );
+    } //-- void addReportSet( ReportSet )
+
+    /**
+     * Method clone.
+     * 
+     * @return ReportPlugin
+     */
+    public ReportPlugin clone()
+    {
+        try
+        {
+            ReportPlugin copy = (ReportPlugin) super.clone();
+
+            if ( this.reportSets != null )
+            {
+                copy.reportSets = new java.util.ArrayList<ReportSet>();
+                for ( ReportSet item : this.reportSets )
+                {
+                    copy.reportSets.add( ( (ReportSet) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ReportPlugin clone()
+
+    /**
+     * Get the artifact ID of the reporting plugin in the
+     * repository.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the group ID of the reporting plugin in the repository.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Method getReportSets.
+     * 
+     * @return List
+     */
+    public java.util.List<ReportSet> getReportSets()
+    {
+        if ( this.reportSets == null )
+        {
+            this.reportSets = new java.util.ArrayList<ReportSet>();
+        }
+
+        return this.reportSets;
+    } //-- java.util.List<ReportSet> getReportSets()
+
+    /**
+     * Get the version of the reporting plugin to be used.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Method removeReportSet.
+     * 
+     * @param reportSet
+     */
+    public void removeReportSet( ReportSet reportSet )
+    {
+        getReportSets().remove( reportSet );
+    } //-- void removeReportSet( ReportSet )
+
+    /**
+     * Set the artifact ID of the reporting plugin in the
+     * repository.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the group ID of the reporting plugin in the repository.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set multiple specifications of a set of reports, each having
+     * (possibly) different
+     *             configuration. This is the reporting parallel to
+     * an <code>execution</code> in the build.
+     * 
+     * @param reportSets
+     */
+    public void setReportSets( java.util.List<ReportSet> reportSets )
+    {
+        this.reportSets = reportSets;
+    } //-- void setReportSets( java.util.List )
+
+    /**
+     * Set the version of the reporting plugin to be used.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    private java.util.Map<String, ReportSet> reportSetMap = null;
+
+    /**
+     * Reset the <code>reportSetMap</code> field to <code>null</code>
+     */
+    public void flushReportSetMap()
+    {
+        this.reportSetMap = null;
+    }
+
+    /**
+     * @return a Map of reportSets field with <code>ReportSet#getId()</code> as key
+     * @see org.apache.maven.model.ReportSet#getId()
+     */
+    public java.util.Map<String, ReportSet> getReportSetsAsMap()
+    {
+        if ( reportSetMap == null )
+        {
+            reportSetMap = new java.util.LinkedHashMap<String, ReportSet>();
+            if ( getReportSets() != null )
+            {
+                for ( java.util.Iterator<ReportSet> i = getReportSets().iterator(); i.hasNext(); )
+                {
+                    ReportSet reportSet = (ReportSet) i.next();
+                    reportSetMap.put( reportSet.getId(), reportSet );
+                }
+            }
+        }
+
+        return reportSetMap;
+    }
+
+    /**
+     * @return the key of the report plugin, ie <code>groupId:artifactId</code>
+     */
+    public String getKey()
+    {
+        return constructKey( groupId, artifactId );
+    }
+
+    /**
+     * @param groupId
+     * @param artifactId
+     * @return the key of the report plugin, ie <code>groupId:artifactId</code>
+     */
+    public static String constructKey( String groupId, String artifactId )
+    {
+        return groupId + ":" + artifactId;
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/ReportSet.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/ReportSet.java
new file mode 100644
index 0000000..cf17936
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/ReportSet.java
@@ -0,0 +1,147 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Represents a set of reports and configuration to be used to
+ * generate them.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ReportSet
+    extends ConfigurationContainer
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The unique id for this report set, to be used during POM
+     * inheritance and profile injection
+     *             for merging of report sets.
+     *           
+     */
+    private String id = "default";
+
+    /**
+     * Field reports.
+     */
+    private java.util.List<String> reports;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addReport.
+     * 
+     * @param string
+     */
+    public void addReport( String string )
+    {
+        getReports().add( string );
+    } //-- void addReport( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return ReportSet
+     */
+    public ReportSet clone()
+    {
+        try
+        {
+            ReportSet copy = (ReportSet) super.clone();
+
+            if ( this.reports != null )
+            {
+                copy.reports = new java.util.ArrayList<String>();
+                copy.reports.addAll( this.reports );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ReportSet clone()
+
+    /**
+     * Get the unique id for this report set, to be used during POM
+     * inheritance and profile injection
+     *             for merging of report sets.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Method getReports.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getReports()
+    {
+        if ( this.reports == null )
+        {
+            this.reports = new java.util.ArrayList<String>();
+        }
+
+        return this.reports;
+    } //-- java.util.List<String> getReports()
+
+    /**
+     * Method removeReport.
+     * 
+     * @param string
+     */
+    public void removeReport( String string )
+    {
+        getReports().remove( string );
+    } //-- void removeReport( String )
+
+    /**
+     * Set the unique id for this report set, to be used during POM
+     * inheritance and profile injection
+     *             for merging of report sets.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the list of reports from this plugin which should be
+     * generated from this set.
+     * 
+     * @param reports
+     */
+    public void setReports( java.util.List<String> reports )
+    {
+        this.reports = reports;
+    } //-- void setReports( java.util.List )
+
+    
+            
+    @Override
+    public String toString()
+    {
+        return getId();
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Reporting.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Reporting.java
new file mode 100644
index 0000000..8d1ff82
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Reporting.java
@@ -0,0 +1,275 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Section for management of reports and their configuration.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Reporting
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             If true, then the default reports are not
+     * included in the site generation.
+     *             This includes the reports in the "Project Info"
+     * menu. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     *             
+     *           
+     */
+    private String excludeDefaults;
+
+    /**
+     * 
+     *             
+     *             Where to store all of the generated reports. The
+     * default is
+     *             <code>${project.build.directory}/site</code>.
+     *             
+     *           
+     */
+    private String outputDirectory;
+
+    /**
+     * Field plugins.
+     */
+    private java.util.List<ReportPlugin> plugins;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addPlugin.
+     * 
+     * @param reportPlugin
+     */
+    public void addPlugin( ReportPlugin reportPlugin )
+    {
+        getPlugins().add( reportPlugin );
+    } //-- void addPlugin( ReportPlugin )
+
+    /**
+     * Method clone.
+     * 
+     * @return Reporting
+     */
+    public Reporting clone()
+    {
+        try
+        {
+            Reporting copy = (Reporting) super.clone();
+
+            if ( this.plugins != null )
+            {
+                copy.plugins = new java.util.ArrayList<ReportPlugin>();
+                for ( ReportPlugin item : this.plugins )
+                {
+                    copy.plugins.add( ( (ReportPlugin) item).clone() );
+                }
+            }
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Reporting clone()
+
+    /**
+     * Get if true, then the default reports are not included in
+     * the site generation.
+     *             This includes the reports in the "Project Info"
+     * menu. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @return String
+     */
+    public String getExcludeDefaults()
+    {
+        return this.excludeDefaults;
+    } //-- String getExcludeDefaults()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get where to store all of the generated reports. The default
+     * is
+     *             <code>${project.build.directory}/site</code>.
+     * 
+     * @return String
+     */
+    public String getOutputDirectory()
+    {
+        return this.outputDirectory;
+    } //-- String getOutputDirectory()
+
+    /**
+     * Method getPlugins.
+     * 
+     * @return List
+     */
+    public java.util.List<ReportPlugin> getPlugins()
+    {
+        if ( this.plugins == null )
+        {
+            this.plugins = new java.util.ArrayList<ReportPlugin>();
+        }
+
+        return this.plugins;
+    } //-- java.util.List<ReportPlugin> getPlugins()
+
+    /**
+     * Method removePlugin.
+     * 
+     * @param reportPlugin
+     */
+    public void removePlugin( ReportPlugin reportPlugin )
+    {
+        getPlugins().remove( reportPlugin );
+    } //-- void removePlugin( ReportPlugin )
+
+    /**
+     * Set if true, then the default reports are not included in
+     * the site generation.
+     *             This includes the reports in the "Project Info"
+     * menu. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @param excludeDefaults
+     */
+    public void setExcludeDefaults( String excludeDefaults )
+    {
+        this.excludeDefaults = excludeDefaults;
+    } //-- void setExcludeDefaults( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set where to store all of the generated reports. The default
+     * is
+     *             <code>${project.build.directory}/site</code>.
+     * 
+     * @param outputDirectory
+     */
+    public void setOutputDirectory( String outputDirectory )
+    {
+        this.outputDirectory = outputDirectory;
+    } //-- void setOutputDirectory( String )
+
+    /**
+     * Set the reporting plugins to use and their configuration.
+     * 
+     * @param plugins
+     */
+    public void setPlugins( java.util.List<ReportPlugin> plugins )
+    {
+        this.plugins = plugins;
+    } //-- void setPlugins( java.util.List )
+
+    
+            
+    public boolean isExcludeDefaults()
+    {
+        return ( excludeDefaults != null ) ? Boolean.parseBoolean( excludeDefaults ) : false;
+    }
+
+    public void setExcludeDefaults( boolean excludeDefaults )
+    {
+        this.excludeDefaults = String.valueOf( excludeDefaults );
+    }
+
+    java.util.Map<String, ReportPlugin> reportPluginMap;
+
+    /**
+     * Reset the <code>reportPluginMap</code> field to <code>null</code>
+     */
+    public synchronized void flushReportPluginMap()
+    {
+        this.reportPluginMap = null;
+    }
+
+    /**
+     * @return a Map of plugins field with <code>ReportPlugin#getKey()</code> as key
+     * @see org.apache.maven.model.ReportPlugin#getKey()
+     */
+    public synchronized java.util.Map<String, ReportPlugin> getReportPluginsAsMap()
+    {
+        if ( reportPluginMap == null )
+        {
+            reportPluginMap = new java.util.LinkedHashMap<String, ReportPlugin>();
+            if ( getPlugins() != null )
+            {
+                for ( java.util.Iterator<ReportPlugin> it = getPlugins().iterator(); it.hasNext(); )
+                {
+                    ReportPlugin reportPlugin = (ReportPlugin) it.next();
+                    reportPluginMap.put( reportPlugin.getKey(), reportPlugin );
+                }
+            }
+        }
+
+        return reportPluginMap;
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Repository.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Repository.java
new file mode 100644
index 0000000..68f5a37
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Repository.java
@@ -0,0 +1,114 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * A repository contains the information needed for establishing
+ * connections with
+ *         remote repository.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Repository
+    extends RepositoryBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * How to handle downloading of releases from this repository.
+     */
+    private RepositoryPolicy releases;
+
+    /**
+     * How to handle downloading of snapshots from this repository.
+     */
+    private RepositoryPolicy snapshots;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Repository
+     */
+    public Repository clone()
+    {
+        try
+        {
+            Repository copy = (Repository) super.clone();
+
+            if ( this.releases != null )
+            {
+                copy.releases = (RepositoryPolicy) this.releases.clone();
+            }
+
+            if ( this.snapshots != null )
+            {
+                copy.snapshots = (RepositoryPolicy) this.snapshots.clone();
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Repository clone()
+
+    /**
+     * Get how to handle downloading of releases from this
+     * repository.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy getReleases()
+    {
+        return this.releases;
+    } //-- RepositoryPolicy getReleases()
+
+    /**
+     * Get how to handle downloading of snapshots from this
+     * repository.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy getSnapshots()
+    {
+        return this.snapshots;
+    } //-- RepositoryPolicy getSnapshots()
+
+    /**
+     * Set how to handle downloading of releases from this
+     * repository.
+     * 
+     * @param releases
+     */
+    public void setReleases( RepositoryPolicy releases )
+    {
+        this.releases = releases;
+    } //-- void setReleases( RepositoryPolicy )
+
+    /**
+     * Set how to handle downloading of snapshots from this
+     * repository.
+     * 
+     * @param snapshots
+     */
+    public void setSnapshots( RepositoryPolicy snapshots )
+    {
+        this.snapshots = snapshots;
+    } //-- void setSnapshots( RepositoryPolicy )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryBase.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryBase.java
new file mode 100644
index 0000000..1f40b1e
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryBase.java
@@ -0,0 +1,286 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * A repository contains the information needed for establishing
+ * connections with
+ *         remote repository.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class RepositoryBase
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             A unique identifier for a repository. This is
+     * used to match the repository
+     *             to configuration in the
+     * <code>settings.xml</code> file, for example. Furthermore,
+     * the identifier is
+     *             used during POM inheritance and profile
+     * injection to detect repositories that should be merged.
+     *             
+     *           
+     */
+    private String id;
+
+    /**
+     * Human readable name of the repository.
+     */
+    private String name;
+
+    /**
+     * 
+     *             
+     *             The url of the repository, in the form
+     * <code>protocol://hostname/path</code>.
+     *             
+     *           
+     */
+    private String url;
+
+    /**
+     * 
+     *             
+     *             The type of layout this repository uses for
+     * locating and storing artifacts -
+     *             can be <code>legacy</code> or
+     * <code>default</code>.
+     *             
+     *           
+     */
+    private String layout = "default";
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return RepositoryBase
+     */
+    public RepositoryBase clone()
+    {
+        try
+        {
+            RepositoryBase copy = (RepositoryBase) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- RepositoryBase clone()
+
+    /**
+     * Method equals.
+     * 
+     * @param other
+     * @return boolean
+     */
+    public boolean equals( Object other )
+    {
+        if ( this == other )
+        {
+            return true;
+        }
+
+        if ( !( other instanceof RepositoryBase ) )
+        {
+            return false;
+        }
+
+        RepositoryBase that = (RepositoryBase) other;
+        boolean result = true;
+
+        result = result && ( getId() == null ? that.getId() == null : getId().equals( that.getId() ) );
+
+        return result;
+    } //-- boolean equals( Object )
+
+    /**
+     * Get a unique identifier for a repository. This is used to
+     * match the repository
+     *             to configuration in the
+     * <code>settings.xml</code> file, for example. Furthermore,
+     * the identifier is
+     *             used during POM inheritance and profile
+     * injection to detect repositories that should be merged.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Get the type of layout this repository uses for locating and
+     * storing artifacts -
+     *             can be <code>legacy</code> or
+     * <code>default</code>.
+     * 
+     * @return String
+     */
+    public String getLayout()
+    {
+        return this.layout;
+    } //-- String getLayout()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get human readable name of the repository.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the url of the repository, in the form
+     * <code>protocol://hostname/path</code>.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Method hashCode.
+     * 
+     * @return int
+     */
+    public int hashCode()
+    {
+        int result = 17;
+
+        result = 37 * result + ( id != null ? id.hashCode() : 0 );
+
+        return result;
+    } //-- int hashCode()
+
+    /**
+     * Set a unique identifier for a repository. This is used to
+     * match the repository
+     *             to configuration in the
+     * <code>settings.xml</code> file, for example. Furthermore,
+     * the identifier is
+     *             used during POM inheritance and profile
+     * injection to detect repositories that should be merged.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the type of layout this repository uses for locating and
+     * storing artifacts -
+     *             can be <code>legacy</code> or
+     * <code>default</code>.
+     * 
+     * @param layout
+     */
+    public void setLayout( String layout )
+    {
+        this.layout = layout;
+    } //-- void setLayout( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set human readable name of the repository.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the url of the repository, in the form
+     * <code>protocol://hostname/path</code>.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+    /**
+     * Method toString.
+     * 
+     * @return String
+     */
+    public java.lang.String toString()
+    {
+        StringBuilder buf = new StringBuilder( 128 );
+
+        buf.append( "id = '" );
+        buf.append( getId() );
+        buf.append( "'" );
+
+        return buf.toString();
+    } //-- java.lang.String toString()
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryPolicy.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryPolicy.java
new file mode 100644
index 0000000..e3c820a
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/RepositoryPolicy.java
@@ -0,0 +1,245 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Download policy.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class RepositoryPolicy
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             Whether to use this repository for downloading
+     * this type of artifact. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>true</code>.
+     *             
+     *           
+     */
+    private String enabled;
+
+    /**
+     * 
+     *             
+     *             The frequency for downloading updates - can be
+     *             <code>always,</code>
+     *             <code>daily</code>
+     *             (default),
+     *             <code>interval:XXX</code>
+     *             (in minutes) or
+     *             <code>never</code>
+     *             (only if it doesn't exist locally).
+     *             
+     *           
+     */
+    private String updatePolicy;
+
+    /**
+     * 
+     *             
+     *             What to do when verification of an artifact
+     * checksum fails. Valid values are
+     *             <code>ignore</code>
+     *             ,
+     *             <code>fail</code>
+     *             or
+     *             <code>warn</code>
+     *             (the default).
+     *             
+     *           
+     */
+    private String checksumPolicy;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy clone()
+    {
+        try
+        {
+            RepositoryPolicy copy = (RepositoryPolicy) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- RepositoryPolicy clone()
+
+    /**
+     * Get what to do when verification of an artifact checksum
+     * fails. Valid values are
+     *             <code>ignore</code>
+     *             ,
+     *             <code>fail</code>
+     *             or
+     *             <code>warn</code>
+     *             (the default).
+     * 
+     * @return String
+     */
+    public String getChecksumPolicy()
+    {
+        return this.checksumPolicy;
+    } //-- String getChecksumPolicy()
+
+    /**
+     * Get whether to use this repository for downloading this type
+     * of artifact. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>true</code>.
+     * 
+     * @return String
+     */
+    public String getEnabled()
+    {
+        return this.enabled;
+    } //-- String getEnabled()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the frequency for downloading updates - can be
+     *             <code>always,</code>
+     *             <code>daily</code>
+     *             (default),
+     *             <code>interval:XXX</code>
+     *             (in minutes) or
+     *             <code>never</code>
+     *             (only if it doesn't exist locally).
+     * 
+     * @return String
+     */
+    public String getUpdatePolicy()
+    {
+        return this.updatePolicy;
+    } //-- String getUpdatePolicy()
+
+    /**
+     * Set what to do when verification of an artifact checksum
+     * fails. Valid values are
+     *             <code>ignore</code>
+     *             ,
+     *             <code>fail</code>
+     *             or
+     *             <code>warn</code>
+     *             (the default).
+     * 
+     * @param checksumPolicy
+     */
+    public void setChecksumPolicy( String checksumPolicy )
+    {
+        this.checksumPolicy = checksumPolicy;
+    } //-- void setChecksumPolicy( String )
+
+    /**
+     * Set whether to use this repository for downloading this type
+     * of artifact. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>true</code>.
+     * 
+     * @param enabled
+     */
+    public void setEnabled( String enabled )
+    {
+        this.enabled = enabled;
+    } //-- void setEnabled( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the frequency for downloading updates - can be
+     *             <code>always,</code>
+     *             <code>daily</code>
+     *             (default),
+     *             <code>interval:XXX</code>
+     *             (in minutes) or
+     *             <code>never</code>
+     *             (only if it doesn't exist locally).
+     * 
+     * @param updatePolicy
+     */
+    public void setUpdatePolicy( String updatePolicy )
+    {
+        this.updatePolicy = updatePolicy;
+    } //-- void setUpdatePolicy( String )
+
+    
+            
+
+    public boolean isEnabled()
+    {
+        return ( enabled != null ) ? Boolean.parseBoolean( enabled ) : true;
+    }
+
+    public void setEnabled( boolean enabled )
+    {
+        this.enabled = String.valueOf( enabled );
+    }
+
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Resource.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Resource.java
new file mode 100644
index 0000000..d15b35d
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Resource.java
@@ -0,0 +1,255 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * This element describes all of the classpath resources associated
+ * with a project
+ *         or unit tests.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Resource
+    extends FileSet
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             Describe the resource target path. The path is
+     * relative to the target/classes
+     *             directory (i.e.
+     * <code>${project.build.outputDirectory}</code>).
+     *             For example, if you want that resource to appear
+     * in a specific package
+     *             (<code>org.apache.maven.messages</code>), you
+     * must specify this
+     *             element with this value:
+     * <code>org/apache/maven/messages</code>.
+     *             This is not required if you simply put the
+     * resources in that directory
+     *             structure at the source, however.
+     *             
+     *           
+     */
+    private String targetPath;
+
+    /**
+     * 
+     *             
+     *             Whether resources are filtered to replace tokens
+     * with parameterised values or not.
+     *             The values are taken from the
+     * <code>properties</code> element and from the
+     *             properties in the files listed in the
+     * <code>filters</code> element. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     *             
+     *           
+     */
+    private String filtering;
+
+    /**
+     * 
+     *             
+     *             FOR INTERNAL USE ONLY. This is a unique
+     * identifier assigned to each
+     *             resource to allow Maven to merge changes to this
+     * resource that take
+     *             place during the execution of a plugin. This
+     * field must be managed
+     *             by the generated parser and formatter classes in
+     * order to allow it
+     *             to survive model interpolation.
+     *             
+     *           
+     */
+    private String mergeId;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Resource
+     */
+    public Resource clone()
+    {
+        try
+        {
+            Resource copy = (Resource) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Resource clone()
+
+    /**
+     * Get whether resources are filtered to replace tokens with
+     * parameterised values or not.
+     *             The values are taken from the
+     * <code>properties</code> element and from the
+     *             properties in the files listed in the
+     * <code>filters</code> element. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @return String
+     */
+    public String getFiltering()
+    {
+        return this.filtering;
+    } //-- String getFiltering()
+
+    /**
+     * Get fOR INTERNAL USE ONLY. This is a unique identifier
+     * assigned to each
+     *             resource to allow Maven to merge changes to this
+     * resource that take
+     *             place during the execution of a plugin. This
+     * field must be managed
+     *             by the generated parser and formatter classes in
+     * order to allow it
+     *             to survive model interpolation.
+     * 
+     * @return String
+     */
+    public String getMergeId()
+    {
+        return this.mergeId;
+    } //-- String getMergeId()
+
+    /**
+     * Get describe the resource target path. The path is relative
+     * to the target/classes
+     *             directory (i.e.
+     * <code>${project.build.outputDirectory}</code>).
+     *             For example, if you want that resource to appear
+     * in a specific package
+     *             (<code>org.apache.maven.messages</code>), you
+     * must specify this
+     *             element with this value:
+     * <code>org/apache/maven/messages</code>.
+     *             This is not required if you simply put the
+     * resources in that directory
+     *             structure at the source, however.
+     * 
+     * @return String
+     */
+    public String getTargetPath()
+    {
+        return this.targetPath;
+    } //-- String getTargetPath()
+
+    /**
+     * Set whether resources are filtered to replace tokens with
+     * parameterised values or not.
+     *             The values are taken from the
+     * <code>properties</code> element and from the
+     *             properties in the files listed in the
+     * <code>filters</code> element. Note: While the type
+     *             of this field is <code>String</code> for
+     * technical reasons, the semantic type is actually
+     *             <code>Boolean</code>. Default value is
+     * <code>false</code>.
+     * 
+     * @param filtering
+     */
+    public void setFiltering( String filtering )
+    {
+        this.filtering = filtering;
+    } //-- void setFiltering( String )
+
+    /**
+     * Set fOR INTERNAL USE ONLY. This is a unique identifier
+     * assigned to each
+     *             resource to allow Maven to merge changes to this
+     * resource that take
+     *             place during the execution of a plugin. This
+     * field must be managed
+     *             by the generated parser and formatter classes in
+     * order to allow it
+     *             to survive model interpolation.
+     * 
+     * @param mergeId
+     */
+    public void setMergeId( String mergeId )
+    {
+        this.mergeId = mergeId;
+    } //-- void setMergeId( String )
+
+    /**
+     * Set describe the resource target path. The path is relative
+     * to the target/classes
+     *             directory (i.e.
+     * <code>${project.build.outputDirectory}</code>).
+     *             For example, if you want that resource to appear
+     * in a specific package
+     *             (<code>org.apache.maven.messages</code>), you
+     * must specify this
+     *             element with this value:
+     * <code>org/apache/maven/messages</code>.
+     *             This is not required if you simply put the
+     * resources in that directory
+     *             structure at the source, however.
+     * 
+     * @param targetPath
+     */
+    public void setTargetPath( String targetPath )
+    {
+        this.targetPath = targetPath;
+    } //-- void setTargetPath( String )
+
+    
+            
+    private static int mergeIdCounter = 0;
+
+    public void initMergeId()
+    {
+        if ( getMergeId() == null )
+        {
+            setMergeId( "resource-" + (mergeIdCounter++) );
+        }
+    }
+
+    public boolean isFiltering()
+    {
+        return ( filtering != null ) ? Boolean.parseBoolean( filtering ) : false;
+    }
+
+    public void setFiltering( boolean filtering )
+    {
+        this.filtering = String.valueOf( filtering );
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString()
+    {
+        return "Resource {targetPath: " + getTargetPath() + ", filtering: " + isFiltering() + ", " + super.toString() + "}";
+    }
+            
+          
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Scm.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Scm.java
new file mode 100644
index 0000000..39ebe41
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Scm.java
@@ -0,0 +1,264 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;scm&gt;</code> element contains
+ * informations required to the SCM
+ *         (Source Control Management) of the project.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Scm
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The source control management system URL
+     *             that describes the repository and how to connect
+     * to the
+     *             repository. For more information, see the
+     *             <a
+     * href="http://maven.apache.org/scm/scm-url-format.html">URL
+     * format</a>
+     *             and <a
+     * href="http://maven.apache.org/scm/scms-overview.html">list
+     * of supported SCMs</a>.
+     *             This connection is read-only.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId
+     *             
+     *           .
+     */
+    private String connection;
+
+    /**
+     * 
+     *             
+     *             Just like <code>connection</code>, but for
+     * developers, i.e. this scm connection
+     *             will not be read only.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId
+     *             
+     *           .
+     */
+    private String developerConnection;
+
+    /**
+     * The tag of current code. By default, it's set to HEAD during
+     * development.
+     */
+    private String tag = "HEAD";
+
+    /**
+     * 
+     *             
+     *             The URL to the project's browsable SCM
+     * repository, such as ViewVC or Fisheye.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId
+     *             
+     *           .
+     */
+    private String url;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Scm
+     */
+    public Scm clone()
+    {
+        try
+        {
+            Scm copy = (Scm) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Scm clone()
+
+    /**
+     * Get the source control management system URL
+     *             that describes the repository and how to connect
+     * to the
+     *             repository. For more information, see the
+     *             <a
+     * href="http://maven.apache.org/scm/scm-url-format.html">URL
+     * format</a>
+     *             and <a
+     * href="http://maven.apache.org/scm/scms-overview.html">list
+     * of supported SCMs</a>.
+     *             This connection is read-only.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @return String
+     */
+    public String getConnection()
+    {
+        return this.connection;
+    } //-- String getConnection()
+
+    /**
+     * Get just like <code>connection</code>, but for developers,
+     * i.e. this scm connection
+     *             will not be read only.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @return String
+     */
+    public String getDeveloperConnection()
+    {
+        return this.developerConnection;
+    } //-- String getDeveloperConnection()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get the tag of current code. By default, it's set to HEAD
+     * during development.
+     * 
+     * @return String
+     */
+    public String getTag()
+    {
+        return this.tag;
+    } //-- String getTag()
+
+    /**
+     * Get the URL to the project's browsable SCM repository, such
+     * as ViewVC or Fisheye.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Set the source control management system URL
+     *             that describes the repository and how to connect
+     * to the
+     *             repository. For more information, see the
+     *             <a
+     * href="http://maven.apache.org/scm/scm-url-format.html">URL
+     * format</a>
+     *             and <a
+     * href="http://maven.apache.org/scm/scms-overview.html">list
+     * of supported SCMs</a>.
+     *             This connection is read-only.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @param connection
+     */
+    public void setConnection( String connection )
+    {
+        this.connection = connection;
+    } //-- void setConnection( String )
+
+    /**
+     * Set just like <code>connection</code>, but for developers,
+     * i.e. this scm connection
+     *             will not be read only.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @param developerConnection
+     */
+    public void setDeveloperConnection( String developerConnection )
+    {
+        this.developerConnection = developerConnection;
+    } //-- void setDeveloperConnection( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set the tag of current code. By default, it's set to HEAD
+     * during development.
+     * 
+     * @param tag
+     */
+    public void setTag( String tag )
+    {
+        this.tag = tag;
+    } //-- void setTag( String )
+
+    /**
+     * Set the URL to the project's browsable SCM repository, such
+     * as ViewVC or Fisheye.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/Site.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/Site.java
new file mode 100644
index 0000000..bf37e99
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/Site.java
@@ -0,0 +1,187 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model;
+
+/**
+ * Contains the information needed for deploying websites.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Site
+    implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             A unique identifier for a deployment location.
+     * This is used to match the
+     *             site to configuration in the
+     * <code>settings.xml</code> file, for example.
+     *             
+     *           
+     */
+    private String id;
+
+    /**
+     * Human readable name of the deployment location.
+     */
+    private String name;
+
+    /**
+     * 
+     *             
+     *             The url of the location where website is
+     * deployed, in the form <code>protocol://hostname/path</code>.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId
+     *             
+     *           .
+     */
+    private String url;
+
+    /**
+     * Field locations.
+     */
+    private java.util.Map<Object, InputLocation> locations;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Site
+     */
+    public Site clone()
+    {
+        try
+        {
+            Site copy = (Site) super.clone();
+
+            if ( copy.locations != null )
+            {
+                copy.locations = new java.util.LinkedHashMap( copy.locations );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Site clone()
+
+    /**
+     * Get a unique identifier for a deployment location. This is
+     * used to match the
+     *             site to configuration in the
+     * <code>settings.xml</code> file, for example.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * 
+     * 
+     * @param key
+     * @return InputLocation
+     */
+    public InputLocation getLocation( Object key )
+    {
+        return ( locations != null ) ? locations.get( key ) : null;
+    } //-- InputLocation getLocation( Object )
+
+    /**
+     * Get human readable name of the deployment location.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the url of the location where website is deployed, in
+     * the form <code>protocol://hostname/path</code>.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Set a unique identifier for a deployment location. This is
+     * used to match the
+     *             site to configuration in the
+     * <code>settings.xml</code> file, for example.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * 
+     * 
+     * @param key
+     * @param location
+     */
+    public void setLocation( Object key, InputLocation location )
+    {
+        if ( location != null )
+        {
+            if ( this.locations == null )
+            {
+                this.locations = new java.util.LinkedHashMap<Object, InputLocation>();
+            }
+            this.locations.put( key, location );
+        }
+    } //-- void setLocation( Object, InputLocation )
+
+    /**
+     * Set human readable name of the deployment location.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the url of the location where website is deployed, in
+     * the form <code>protocol://hostname/path</code>.
+     *             <br /><b>Default value is</b>: parent value [+
+     * path adjustment] + artifactId.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Reader.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Reader.java
new file mode 100644
index 0000000..18b1cb2
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Reader.java
@@ -0,0 +1,3876 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.model.Activation;
+import org.apache.maven.model.ActivationFile;
+import org.apache.maven.model.ActivationOS;
+import org.apache.maven.model.ActivationProperty;
+import org.apache.maven.model.Build;
+import org.apache.maven.model.BuildBase;
+import org.apache.maven.model.CiManagement;
+import org.apache.maven.model.ConfigurationContainer;
+import org.apache.maven.model.Contributor;
+import org.apache.maven.model.Dependency;
+import org.apache.maven.model.DependencyManagement;
+import org.apache.maven.model.DeploymentRepository;
+import org.apache.maven.model.Developer;
+import org.apache.maven.model.DistributionManagement;
+import org.apache.maven.model.Exclusion;
+import org.apache.maven.model.Extension;
+import org.apache.maven.model.FileSet;
+import org.apache.maven.model.IssueManagement;
+import org.apache.maven.model.License;
+import org.apache.maven.model.MailingList;
+import org.apache.maven.model.Model;
+import org.apache.maven.model.ModelBase;
+import org.apache.maven.model.Notifier;
+import org.apache.maven.model.Organization;
+import org.apache.maven.model.Parent;
+import org.apache.maven.model.PatternSet;
+import org.apache.maven.model.Plugin;
+import org.apache.maven.model.PluginConfiguration;
+import org.apache.maven.model.PluginContainer;
+import org.apache.maven.model.PluginExecution;
+import org.apache.maven.model.PluginManagement;
+import org.apache.maven.model.Prerequisites;
+import org.apache.maven.model.Profile;
+import org.apache.maven.model.Relocation;
+import org.apache.maven.model.ReportPlugin;
+import org.apache.maven.model.ReportSet;
+import org.apache.maven.model.Reporting;
+import org.apache.maven.model.Repository;
+import org.apache.maven.model.RepositoryBase;
+import org.apache.maven.model.RepositoryPolicy;
+import org.apache.maven.model.Resource;
+import org.apache.maven.model.Scm;
+import org.apache.maven.model.Site;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class MavenXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MavenXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MavenXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.model.io.xpp3.MavenXpp3Reader()
+
+    public MavenXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.model.io.xpp3.MavenXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    public Model read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- Model read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    public Model read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- Model read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    public Model read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- Model read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    public Model read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- Model read( InputStream )
+
+    /**
+     * Method parseActivation.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Activation
+     */
+    private Activation parseActivation( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Activation activation = new Activation();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "activeByDefault", null, parsed ) )
+            {
+                activation.setActiveByDefault( getBooleanValue( interpolatedTrimmed( parser.nextText(), "activeByDefault" ), "activeByDefault", parser, "false" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "jdk", null, parsed ) )
+            {
+                activation.setJdk( interpolatedTrimmed( parser.nextText(), "jdk" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "os", null, parsed ) )
+            {
+                activation.setOs( parseActivationOS( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "property", null, parsed ) )
+            {
+                activation.setProperty( parseActivationProperty( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "file", null, parsed ) )
+            {
+                activation.setFile( parseActivationFile( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activation;
+    } //-- Activation parseActivation( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationFile.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationFile
+     */
+    private ActivationFile parseActivationFile( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationFile activationFile = new ActivationFile();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "missing", null, parsed ) )
+            {
+                activationFile.setMissing( interpolatedTrimmed( parser.nextText(), "missing" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "exists", null, parsed ) )
+            {
+                activationFile.setExists( interpolatedTrimmed( parser.nextText(), "exists" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationFile;
+    } //-- ActivationFile parseActivationFile( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationOS.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationOS
+     */
+    private ActivationOS parseActivationOS( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationOS activationOS = new ActivationOS();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                activationOS.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "family", null, parsed ) )
+            {
+                activationOS.setFamily( interpolatedTrimmed( parser.nextText(), "family" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "arch", null, parsed ) )
+            {
+                activationOS.setArch( interpolatedTrimmed( parser.nextText(), "arch" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                activationOS.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationOS;
+    } //-- ActivationOS parseActivationOS( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationProperty.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationProperty
+     */
+    private ActivationProperty parseActivationProperty( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationProperty activationProperty = new ActivationProperty();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                activationProperty.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "value", null, parsed ) )
+            {
+                activationProperty.setValue( interpolatedTrimmed( parser.nextText(), "value" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationProperty;
+    } //-- ActivationProperty parseActivationProperty( XmlPullParser, boolean )
+
+    /**
+     * Method parseBuild.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Build
+     */
+    private Build parseBuild( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Build build = new Build();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "sourceDirectory", null, parsed ) )
+            {
+                build.setSourceDirectory( interpolatedTrimmed( parser.nextText(), "sourceDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "scriptSourceDirectory", null, parsed ) )
+            {
+                build.setScriptSourceDirectory( interpolatedTrimmed( parser.nextText(), "scriptSourceDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "testSourceDirectory", null, parsed ) )
+            {
+                build.setTestSourceDirectory( interpolatedTrimmed( parser.nextText(), "testSourceDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "outputDirectory", null, parsed ) )
+            {
+                build.setOutputDirectory( interpolatedTrimmed( parser.nextText(), "outputDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "testOutputDirectory", null, parsed ) )
+            {
+                build.setTestOutputDirectory( interpolatedTrimmed( parser.nextText(), "testOutputDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "extensions", null, parsed ) )
+            {
+                java.util.List extensions = new java.util.ArrayList/*<Extension>*/();
+                build.setExtensions( extensions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "extension".equals( parser.getName() ) )
+                    {
+                        extensions.add( parseExtension( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "defaultGoal", null, parsed ) )
+            {
+                build.setDefaultGoal( interpolatedTrimmed( parser.nextText(), "defaultGoal" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "resources", null, parsed ) )
+            {
+                java.util.List resources = new java.util.ArrayList/*<Resource>*/();
+                build.setResources( resources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "resource".equals( parser.getName() ) )
+                    {
+                        resources.add( parseResource( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "testResources", null, parsed ) )
+            {
+                java.util.List testResources = new java.util.ArrayList/*<Resource>*/();
+                build.setTestResources( testResources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "testResource".equals( parser.getName() ) )
+                    {
+                        testResources.add( parseResource( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                build.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "finalName", null, parsed ) )
+            {
+                build.setFinalName( interpolatedTrimmed( parser.nextText(), "finalName" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filters", null, parsed ) )
+            {
+                java.util.List filters = new java.util.ArrayList/*<String>*/();
+                build.setFilters( filters );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "filter".equals( parser.getName() ) )
+                    {
+                        filters.add( interpolatedTrimmed( parser.nextText(), "filters" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
+            {
+                build.setPluginManagement( parsePluginManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                build.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return build;
+    } //-- Build parseBuild( XmlPullParser, boolean )
+
+    /**
+     * Method parseBuildBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return BuildBase
+     */
+    private BuildBase parseBuildBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        BuildBase buildBase = new BuildBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "defaultGoal", null, parsed ) )
+            {
+                buildBase.setDefaultGoal( interpolatedTrimmed( parser.nextText(), "defaultGoal" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "resources", null, parsed ) )
+            {
+                java.util.List resources = new java.util.ArrayList/*<Resource>*/();
+                buildBase.setResources( resources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "resource".equals( parser.getName() ) )
+                    {
+                        resources.add( parseResource( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "testResources", null, parsed ) )
+            {
+                java.util.List testResources = new java.util.ArrayList/*<Resource>*/();
+                buildBase.setTestResources( testResources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "testResource".equals( parser.getName() ) )
+                    {
+                        testResources.add( parseResource( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                buildBase.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "finalName", null, parsed ) )
+            {
+                buildBase.setFinalName( interpolatedTrimmed( parser.nextText(), "finalName" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filters", null, parsed ) )
+            {
+                java.util.List filters = new java.util.ArrayList/*<String>*/();
+                buildBase.setFilters( filters );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "filter".equals( parser.getName() ) )
+                    {
+                        filters.add( interpolatedTrimmed( parser.nextText(), "filters" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
+            {
+                buildBase.setPluginManagement( parsePluginManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                buildBase.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return buildBase;
+    } //-- BuildBase parseBuildBase( XmlPullParser, boolean )
+
+    /**
+     * Method parseCiManagement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CiManagement
+     */
+    private CiManagement parseCiManagement( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        CiManagement ciManagement = new CiManagement();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "system", null, parsed ) )
+            {
+                ciManagement.setSystem( interpolatedTrimmed( parser.nextText(), "system" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                ciManagement.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "notifiers", null, parsed ) )
+            {
+                java.util.List notifiers = new java.util.ArrayList/*<Notifier>*/();
+                ciManagement.setNotifiers( notifiers );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "notifier".equals( parser.getName() ) )
+                    {
+                        notifiers.add( parseNotifier( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return ciManagement;
+    } //-- CiManagement parseCiManagement( XmlPullParser, boolean )
+
+    /**
+     * Method parseConfigurationContainer.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ConfigurationContainer
+     */
+    private ConfigurationContainer parseConfigurationContainer( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ConfigurationContainer configurationContainer = new ConfigurationContainer();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                configurationContainer.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                configurationContainer.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return configurationContainer;
+    } //-- ConfigurationContainer parseConfigurationContainer( XmlPullParser, boolean )
+
+    /**
+     * Method parseContributor.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Contributor
+     */
+    private Contributor parseContributor( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Contributor contributor = new Contributor();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                contributor.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "email", null, parsed ) )
+            {
+                contributor.setEmail( interpolatedTrimmed( parser.nextText(), "email" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                contributor.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
+            {
+                contributor.setOrganization( interpolatedTrimmed( parser.nextText(), "organization" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organizationUrl", "organisationUrl", parsed ) )
+            {
+                contributor.setOrganizationUrl( interpolatedTrimmed( parser.nextText(), "organizationUrl" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "roles", null, parsed ) )
+            {
+                java.util.List roles = new java.util.ArrayList/*<String>*/();
+                contributor.setRoles( roles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "role".equals( parser.getName() ) )
+                    {
+                        roles.add( interpolatedTrimmed( parser.nextText(), "roles" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "timezone", null, parsed ) )
+            {
+                contributor.setTimezone( interpolatedTrimmed( parser.nextText(), "timezone" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    contributor.addProperty( key, value );
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return contributor;
+    } //-- Contributor parseContributor( XmlPullParser, boolean )
+
+    /**
+     * Method parseDependency.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Dependency
+     */
+    private Dependency parseDependency( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Dependency dependency = new Dependency();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                dependency.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                dependency.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                dependency.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
+            {
+                dependency.setType( interpolatedTrimmed( parser.nextText(), "type" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "classifier", null, parsed ) )
+            {
+                dependency.setClassifier( interpolatedTrimmed( parser.nextText(), "classifier" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "scope", null, parsed ) )
+            {
+                dependency.setScope( interpolatedTrimmed( parser.nextText(), "scope" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "systemPath", null, parsed ) )
+            {
+                dependency.setSystemPath( interpolatedTrimmed( parser.nextText(), "systemPath" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "exclusions", null, parsed ) )
+            {
+                java.util.List exclusions = new java.util.ArrayList/*<Exclusion>*/();
+                dependency.setExclusions( exclusions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclusion".equals( parser.getName() ) )
+                    {
+                        exclusions.add( parseExclusion( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "optional", null, parsed ) )
+            {
+                dependency.setOptional( interpolatedTrimmed( parser.nextText(), "optional" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return dependency;
+    } //-- Dependency parseDependency( XmlPullParser, boolean )
+
+    /**
+     * Method parseDependencyManagement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return DependencyManagement
+     */
+    private DependencyManagement parseDependencyManagement( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        DependencyManagement dependencyManagement = new DependencyManagement();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                dependencyManagement.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return dependencyManagement;
+    } //-- DependencyManagement parseDependencyManagement( XmlPullParser, boolean )
+
+    /**
+     * Method parseDeploymentRepository.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return DeploymentRepository
+     */
+    private DeploymentRepository parseDeploymentRepository( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        DeploymentRepository deploymentRepository = new DeploymentRepository();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "uniqueVersion", null, parsed ) )
+            {
+                deploymentRepository.setUniqueVersion( getBooleanValue( interpolatedTrimmed( parser.nextText(), "uniqueVersion" ), "uniqueVersion", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
+            {
+                deploymentRepository.setReleases( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
+            {
+                deploymentRepository.setSnapshots( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                deploymentRepository.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                deploymentRepository.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                deploymentRepository.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                deploymentRepository.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return deploymentRepository;
+    } //-- DeploymentRepository parseDeploymentRepository( XmlPullParser, boolean )
+
+    /**
+     * Method parseDeveloper.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Developer
+     */
+    private Developer parseDeveloper( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Developer developer = new Developer();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                developer.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                developer.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "email", null, parsed ) )
+            {
+                developer.setEmail( interpolatedTrimmed( parser.nextText(), "email" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                developer.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
+            {
+                developer.setOrganization( interpolatedTrimmed( parser.nextText(), "organization" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organizationUrl", "organisationUrl", parsed ) )
+            {
+                developer.setOrganizationUrl( interpolatedTrimmed( parser.nextText(), "organizationUrl" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "roles", null, parsed ) )
+            {
+                java.util.List roles = new java.util.ArrayList/*<String>*/();
+                developer.setRoles( roles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "role".equals( parser.getName() ) )
+                    {
+                        roles.add( interpolatedTrimmed( parser.nextText(), "roles" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "timezone", null, parsed ) )
+            {
+                developer.setTimezone( interpolatedTrimmed( parser.nextText(), "timezone" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    developer.addProperty( key, value );
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return developer;
+    } //-- Developer parseDeveloper( XmlPullParser, boolean )
+
+    /**
+     * Method parseDistributionManagement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return DistributionManagement
+     */
+    private DistributionManagement parseDistributionManagement( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        DistributionManagement distributionManagement = new DistributionManagement();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "repository", null, parsed ) )
+            {
+                distributionManagement.setRepository( parseDeploymentRepository( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshotRepository", null, parsed ) )
+            {
+                distributionManagement.setSnapshotRepository( parseDeploymentRepository( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "site", null, parsed ) )
+            {
+                distributionManagement.setSite( parseSite( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "downloadUrl", null, parsed ) )
+            {
+                distributionManagement.setDownloadUrl( interpolatedTrimmed( parser.nextText(), "downloadUrl" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "relocation", null, parsed ) )
+            {
+                distributionManagement.setRelocation( parseRelocation( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "status", null, parsed ) )
+            {
+                distributionManagement.setStatus( interpolatedTrimmed( parser.nextText(), "status" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return distributionManagement;
+    } //-- DistributionManagement parseDistributionManagement( XmlPullParser, boolean )
+
+    /**
+     * Method parseExclusion.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Exclusion
+     */
+    private Exclusion parseExclusion( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Exclusion exclusion = new Exclusion();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                exclusion.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                exclusion.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return exclusion;
+    } //-- Exclusion parseExclusion( XmlPullParser, boolean )
+
+    /**
+     * Method parseExtension.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Extension
+     */
+    private Extension parseExtension( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Extension extension = new Extension();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                extension.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                extension.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                extension.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return extension;
+    } //-- Extension parseExtension( XmlPullParser, boolean )
+
+    /**
+     * Method parseFileSet.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return FileSet
+     */
+    private FileSet parseFileSet( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        FileSet fileSet = new FileSet();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                fileSet.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
+            {
+                java.util.List includes = new java.util.ArrayList/*<String>*/();
+                fileSet.setIncludes( includes );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "include".equals( parser.getName() ) )
+                    {
+                        includes.add( interpolatedTrimmed( parser.nextText(), "includes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
+            {
+                java.util.List excludes = new java.util.ArrayList/*<String>*/();
+                fileSet.setExcludes( excludes );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclude".equals( parser.getName() ) )
+                    {
+                        excludes.add( interpolatedTrimmed( parser.nextText(), "excludes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return fileSet;
+    } //-- FileSet parseFileSet( XmlPullParser, boolean )
+
+    /**
+     * Method parseIssueManagement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return IssueManagement
+     */
+    private IssueManagement parseIssueManagement( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        IssueManagement issueManagement = new IssueManagement();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "system", null, parsed ) )
+            {
+                issueManagement.setSystem( interpolatedTrimmed( parser.nextText(), "system" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                issueManagement.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return issueManagement;
+    } //-- IssueManagement parseIssueManagement( XmlPullParser, boolean )
+
+    /**
+     * Method parseLicense.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return License
+     */
+    private License parseLicense( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        License license = new License();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                license.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                license.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "distribution", null, parsed ) )
+            {
+                license.setDistribution( interpolatedTrimmed( parser.nextText(), "distribution" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "comments", null, parsed ) )
+            {
+                license.setComments( interpolatedTrimmed( parser.nextText(), "comments" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return license;
+    } //-- License parseLicense( XmlPullParser, boolean )
+
+    /**
+     * Method parseMailingList.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return MailingList
+     */
+    private MailingList parseMailingList( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        MailingList mailingList = new MailingList();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                mailingList.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "subscribe", null, parsed ) )
+            {
+                mailingList.setSubscribe( interpolatedTrimmed( parser.nextText(), "subscribe" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "unsubscribe", null, parsed ) )
+            {
+                mailingList.setUnsubscribe( interpolatedTrimmed( parser.nextText(), "unsubscribe" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "post", null, parsed ) )
+            {
+                mailingList.setPost( interpolatedTrimmed( parser.nextText(), "post" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "archive", null, parsed ) )
+            {
+                mailingList.setArchive( interpolatedTrimmed( parser.nextText(), "archive" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "otherArchives", null, parsed ) )
+            {
+                java.util.List otherArchives = new java.util.ArrayList/*<String>*/();
+                mailingList.setOtherArchives( otherArchives );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "otherArchive".equals( parser.getName() ) )
+                    {
+                        otherArchives.add( interpolatedTrimmed( parser.nextText(), "otherArchives" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return mailingList;
+    } //-- MailingList parseMailingList( XmlPullParser, boolean )
+
+    /**
+     * Method parseModel.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    private Model parseModel( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Model model = new Model();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "modelVersion", null, parsed ) )
+            {
+                model.setModelVersion( interpolatedTrimmed( parser.nextText(), "modelVersion" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "parent", null, parsed ) )
+            {
+                model.setParent( parseParent( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                model.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                model.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                model.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "packaging", null, parsed ) )
+            {
+                model.setPackaging( interpolatedTrimmed( parser.nextText(), "packaging" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                model.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "description", null, parsed ) )
+            {
+                model.setDescription( interpolatedTrimmed( parser.nextText(), "description" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                model.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "inceptionYear", null, parsed ) )
+            {
+                model.setInceptionYear( interpolatedTrimmed( parser.nextText(), "inceptionYear" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
+            {
+                model.setOrganization( parseOrganization( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "licenses", null, parsed ) )
+            {
+                java.util.List licenses = new java.util.ArrayList/*<License>*/();
+                model.setLicenses( licenses );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "license".equals( parser.getName() ) )
+                    {
+                        licenses.add( parseLicense( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "developers", null, parsed ) )
+            {
+                java.util.List developers = new java.util.ArrayList/*<Developer>*/();
+                model.setDevelopers( developers );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "developer".equals( parser.getName() ) )
+                    {
+                        developers.add( parseDeveloper( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "contributors", null, parsed ) )
+            {
+                java.util.List contributors = new java.util.ArrayList/*<Contributor>*/();
+                model.setContributors( contributors );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "contributor".equals( parser.getName() ) )
+                    {
+                        contributors.add( parseContributor( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "mailingLists", null, parsed ) )
+            {
+                java.util.List mailingLists = new java.util.ArrayList/*<MailingList>*/();
+                model.setMailingLists( mailingLists );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "mailingList".equals( parser.getName() ) )
+                    {
+                        mailingLists.add( parseMailingList( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "prerequisites", null, parsed ) )
+            {
+                model.setPrerequisites( parsePrerequisites( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
+            {
+                java.util.List modules = new java.util.ArrayList/*<String>*/();
+                model.setModules( modules );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "module".equals( parser.getName() ) )
+                    {
+                        modules.add( interpolatedTrimmed( parser.nextText(), "modules" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "scm", null, parsed ) )
+            {
+                model.setScm( parseScm( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "issueManagement", null, parsed ) )
+            {
+                model.setIssueManagement( parseIssueManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "ciManagement", null, parsed ) )
+            {
+                model.setCiManagement( parseCiManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
+            {
+                model.setDistributionManagement( parseDistributionManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    model.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
+            {
+                model.setDependencyManagement( parseDependencyManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                model.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                model.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                model.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "build", null, parsed ) )
+            {
+                model.setBuild( parseBuild( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                model.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
+            {
+                model.setReporting( parseReporting( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "profiles", null, parsed ) )
+            {
+                java.util.List profiles = new java.util.ArrayList/*<Profile>*/();
+                model.setProfiles( profiles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "profile".equals( parser.getName() ) )
+                    {
+                        profiles.add( parseProfile( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return model;
+    } //-- Model parseModel( XmlPullParser, boolean )
+
+    /**
+     * Method parseModelBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ModelBase
+     */
+    private ModelBase parseModelBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ModelBase modelBase = new ModelBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
+            {
+                java.util.List modules = new java.util.ArrayList/*<String>*/();
+                modelBase.setModules( modules );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "module".equals( parser.getName() ) )
+                    {
+                        modules.add( interpolatedTrimmed( parser.nextText(), "modules" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
+            {
+                modelBase.setDistributionManagement( parseDistributionManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    modelBase.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
+            {
+                modelBase.setDependencyManagement( parseDependencyManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                modelBase.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                modelBase.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                modelBase.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                modelBase.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
+            {
+                modelBase.setReporting( parseReporting( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return modelBase;
+    } //-- ModelBase parseModelBase( XmlPullParser, boolean )
+
+    /**
+     * Method parseNotifier.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Notifier
+     */
+    private Notifier parseNotifier( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Notifier notifier = new Notifier();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
+            {
+                notifier.setType( interpolatedTrimmed( parser.nextText(), "type" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnError", null, parsed ) )
+            {
+                notifier.setSendOnError( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnError" ), "sendOnError", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnFailure", null, parsed ) )
+            {
+                notifier.setSendOnFailure( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnFailure" ), "sendOnFailure", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnSuccess", null, parsed ) )
+            {
+                notifier.setSendOnSuccess( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnSuccess" ), "sendOnSuccess", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnWarning", null, parsed ) )
+            {
+                notifier.setSendOnWarning( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnWarning" ), "sendOnWarning", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "address", null, parsed ) )
+            {
+                notifier.setAddress( interpolatedTrimmed( parser.nextText(), "address" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    notifier.addConfiguration( key, value );
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return notifier;
+    } //-- Notifier parseNotifier( XmlPullParser, boolean )
+
+    /**
+     * Method parseOrganization.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Organization
+     */
+    private Organization parseOrganization( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Organization organization = new Organization();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                organization.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                organization.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return organization;
+    } //-- Organization parseOrganization( XmlPullParser, boolean )
+
+    /**
+     * Method parseParent.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Parent
+     */
+    private Parent parseParent( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Parent parent = new Parent();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                parent.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                parent.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                parent.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "relativePath", null, parsed ) )
+            {
+                parent.setRelativePath( interpolatedTrimmed( parser.nextText(), "relativePath" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return parent;
+    } //-- Parent parseParent( XmlPullParser, boolean )
+
+    /**
+     * Method parsePatternSet.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PatternSet
+     */
+    private PatternSet parsePatternSet( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PatternSet patternSet = new PatternSet();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
+            {
+                java.util.List includes = new java.util.ArrayList/*<String>*/();
+                patternSet.setIncludes( includes );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "include".equals( parser.getName() ) )
+                    {
+                        includes.add( interpolatedTrimmed( parser.nextText(), "includes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
+            {
+                java.util.List excludes = new java.util.ArrayList/*<String>*/();
+                patternSet.setExcludes( excludes );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclude".equals( parser.getName() ) )
+                    {
+                        excludes.add( interpolatedTrimmed( parser.nextText(), "excludes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return patternSet;
+    } //-- PatternSet parsePatternSet( XmlPullParser, boolean )
+
+    /**
+     * Method parsePlugin.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Plugin
+     */
+    private Plugin parsePlugin( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Plugin plugin = new Plugin();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                plugin.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                plugin.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                plugin.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "extensions", null, parsed ) )
+            {
+                plugin.setExtensions( interpolatedTrimmed( parser.nextText(), "extensions" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "executions", null, parsed ) )
+            {
+                java.util.List executions = new java.util.ArrayList/*<PluginExecution>*/();
+                plugin.setExecutions( executions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "execution".equals( parser.getName() ) )
+                    {
+                        executions.add( parsePluginExecution( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                plugin.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
+            {
+                plugin.setGoals( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                plugin.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                plugin.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return plugin;
+    } //-- Plugin parsePlugin( XmlPullParser, boolean )
+
+    /**
+     * Method parsePluginConfiguration.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginConfiguration
+     */
+    private PluginConfiguration parsePluginConfiguration( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginConfiguration pluginConfiguration = new PluginConfiguration();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
+            {
+                pluginConfiguration.setPluginManagement( parsePluginManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                pluginConfiguration.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginConfiguration;
+    } //-- PluginConfiguration parsePluginConfiguration( XmlPullParser, boolean )
+
+    /**
+     * Method parsePluginContainer.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginContainer
+     */
+    private PluginContainer parsePluginContainer( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginContainer pluginContainer = new PluginContainer();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                pluginContainer.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginContainer;
+    } //-- PluginContainer parsePluginContainer( XmlPullParser, boolean )
+
+    /**
+     * Method parsePluginExecution.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginExecution
+     */
+    private PluginExecution parsePluginExecution( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginExecution pluginExecution = new PluginExecution();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                pluginExecution.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "phase", null, parsed ) )
+            {
+                pluginExecution.setPhase( interpolatedTrimmed( parser.nextText(), "phase" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
+            {
+                java.util.List goals = new java.util.ArrayList/*<String>*/();
+                pluginExecution.setGoals( goals );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "goal".equals( parser.getName() ) )
+                    {
+                        goals.add( interpolatedTrimmed( parser.nextText(), "goals" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                pluginExecution.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                pluginExecution.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginExecution;
+    } //-- PluginExecution parsePluginExecution( XmlPullParser, boolean )
+
+    /**
+     * Method parsePluginManagement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginManagement
+     */
+    private PluginManagement parsePluginManagement( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginManagement pluginManagement = new PluginManagement();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                pluginManagement.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginManagement;
+    } //-- PluginManagement parsePluginManagement( XmlPullParser, boolean )
+
+    /**
+     * Method parsePrerequisites.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Prerequisites
+     */
+    private Prerequisites parsePrerequisites( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Prerequisites prerequisites = new Prerequisites();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "maven", null, parsed ) )
+            {
+                prerequisites.setMaven( interpolatedTrimmed( parser.nextText(), "maven" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return prerequisites;
+    } //-- Prerequisites parsePrerequisites( XmlPullParser, boolean )
+
+    /**
+     * Method parseProfile.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Profile
+     */
+    private Profile parseProfile( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Profile profile = new Profile();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                profile.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "activation", null, parsed ) )
+            {
+                profile.setActivation( parseActivation( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "build", null, parsed ) )
+            {
+                profile.setBuild( parseBuildBase( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
+            {
+                java.util.List modules = new java.util.ArrayList/*<String>*/();
+                profile.setModules( modules );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "module".equals( parser.getName() ) )
+                    {
+                        modules.add( interpolatedTrimmed( parser.nextText(), "modules" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
+            {
+                profile.setDistributionManagement( parseDistributionManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    profile.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
+            {
+                profile.setDependencyManagement( parseDependencyManagement( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                profile.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                profile.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
+            {
+                profile.setReporting( parseReporting( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return profile;
+    } //-- Profile parseProfile( XmlPullParser, boolean )
+
+    /**
+     * Method parseRelocation.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Relocation
+     */
+    private Relocation parseRelocation( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Relocation relocation = new Relocation();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                relocation.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                relocation.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                relocation.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "message", null, parsed ) )
+            {
+                relocation.setMessage( interpolatedTrimmed( parser.nextText(), "message" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return relocation;
+    } //-- Relocation parseRelocation( XmlPullParser, boolean )
+
+    /**
+     * Method parseReportPlugin.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ReportPlugin
+     */
+    private ReportPlugin parseReportPlugin( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ReportPlugin reportPlugin = new ReportPlugin();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                reportPlugin.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                reportPlugin.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                reportPlugin.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reportSets", null, parsed ) )
+            {
+                java.util.List reportSets = new java.util.ArrayList/*<ReportSet>*/();
+                reportPlugin.setReportSets( reportSets );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "reportSet".equals( parser.getName() ) )
+                    {
+                        reportSets.add( parseReportSet( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                reportPlugin.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                reportPlugin.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return reportPlugin;
+    } //-- ReportPlugin parseReportPlugin( XmlPullParser, boolean )
+
+    /**
+     * Method parseReportSet.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ReportSet
+     */
+    private ReportSet parseReportSet( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ReportSet reportSet = new ReportSet();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                reportSet.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                java.util.List reports = new java.util.ArrayList/*<String>*/();
+                reportSet.setReports( reports );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "report".equals( parser.getName() ) )
+                    {
+                        reports.add( interpolatedTrimmed( parser.nextText(), "reports" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                reportSet.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                reportSet.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return reportSet;
+    } //-- ReportSet parseReportSet( XmlPullParser, boolean )
+
+    /**
+     * Method parseReporting.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Reporting
+     */
+    private Reporting parseReporting( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Reporting reporting = new Reporting();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "excludeDefaults", null, parsed ) )
+            {
+                reporting.setExcludeDefaults( interpolatedTrimmed( parser.nextText(), "excludeDefaults" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "outputDirectory", null, parsed ) )
+            {
+                reporting.setOutputDirectory( interpolatedTrimmed( parser.nextText(), "outputDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<ReportPlugin>*/();
+                reporting.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parseReportPlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return reporting;
+    } //-- Reporting parseReporting( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepository.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Repository
+     */
+    private Repository parseRepository( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Repository repository = new Repository();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
+            {
+                repository.setReleases( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
+            {
+                repository.setSnapshots( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                repository.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                repository.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                repository.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                repository.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repository;
+    } //-- Repository parseRepository( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepositoryBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryBase
+     */
+    private RepositoryBase parseRepositoryBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryBase repositoryBase = new RepositoryBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                repositoryBase.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                repositoryBase.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                repositoryBase.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                repositoryBase.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryBase;
+    } //-- RepositoryBase parseRepositoryBase( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepositoryPolicy.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryPolicy
+     */
+    private RepositoryPolicy parseRepositoryPolicy( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryPolicy repositoryPolicy = new RepositoryPolicy();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "enabled", null, parsed ) )
+            {
+                repositoryPolicy.setEnabled( interpolatedTrimmed( parser.nextText(), "enabled" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "updatePolicy", null, parsed ) )
+            {
+                repositoryPolicy.setUpdatePolicy( interpolatedTrimmed( parser.nextText(), "updatePolicy" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "checksumPolicy", null, parsed ) )
+            {
+                repositoryPolicy.setChecksumPolicy( interpolatedTrimmed( parser.nextText(), "checksumPolicy" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryPolicy;
+    } //-- RepositoryPolicy parseRepositoryPolicy( XmlPullParser, boolean )
+
+    /**
+     * Method parseResource.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Resource
+     */
+    private Resource parseResource( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Resource resource = new Resource();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "targetPath", null, parsed ) )
+            {
+                resource.setTargetPath( interpolatedTrimmed( parser.nextText(), "targetPath" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filtering", null, parsed ) )
+            {
+                resource.setFiltering( interpolatedTrimmed( parser.nextText(), "filtering" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                resource.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
+            {
+                java.util.List includes = new java.util.ArrayList/*<String>*/();
+                resource.setIncludes( includes );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "include".equals( parser.getName() ) )
+                    {
+                        includes.add( interpolatedTrimmed( parser.nextText(), "includes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
+            {
+                java.util.List excludes = new java.util.ArrayList/*<String>*/();
+                resource.setExcludes( excludes );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclude".equals( parser.getName() ) )
+                    {
+                        excludes.add( interpolatedTrimmed( parser.nextText(), "excludes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return resource;
+    } //-- Resource parseResource( XmlPullParser, boolean )
+
+    /**
+     * Method parseScm.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Scm
+     */
+    private Scm parseScm( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Scm scm = new Scm();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "connection", null, parsed ) )
+            {
+                scm.setConnection( interpolatedTrimmed( parser.nextText(), "connection" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "developerConnection", null, parsed ) )
+            {
+                scm.setDeveloperConnection( interpolatedTrimmed( parser.nextText(), "developerConnection" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "tag", null, parsed ) )
+            {
+                scm.setTag( interpolatedTrimmed( parser.nextText(), "tag" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                scm.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return scm;
+    } //-- Scm parseScm( XmlPullParser, boolean )
+
+    /**
+     * Method parseSite.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Site
+     */
+    private Site parseSite( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Site site = new Site();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                site.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                site.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                site.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return site;
+    } //-- Site parseSite( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    private Model read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "project".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'project' but found '" + parser.getName() + "'", parser, null );
+                }
+                Model model = parseModel( parser, strict );
+                model.setModelEncoding( parser.getInputEncoding() );
+                return model;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'project' but found no element at all: invalid XML document", parser, null );
+    } //-- Model read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java
new file mode 100644
index 0000000..e4455c4
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java
@@ -0,0 +1,4419 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.model.Activation;
+import org.apache.maven.model.ActivationFile;
+import org.apache.maven.model.ActivationOS;
+import org.apache.maven.model.ActivationProperty;
+import org.apache.maven.model.Build;
+import org.apache.maven.model.BuildBase;
+import org.apache.maven.model.CiManagement;
+import org.apache.maven.model.ConfigurationContainer;
+import org.apache.maven.model.Contributor;
+import org.apache.maven.model.Dependency;
+import org.apache.maven.model.DependencyManagement;
+import org.apache.maven.model.DeploymentRepository;
+import org.apache.maven.model.Developer;
+import org.apache.maven.model.DistributionManagement;
+import org.apache.maven.model.Exclusion;
+import org.apache.maven.model.Extension;
+import org.apache.maven.model.FileSet;
+import org.apache.maven.model.InputLocation;
+import org.apache.maven.model.InputSource;
+import org.apache.maven.model.IssueManagement;
+import org.apache.maven.model.License;
+import org.apache.maven.model.MailingList;
+import org.apache.maven.model.Model;
+import org.apache.maven.model.ModelBase;
+import org.apache.maven.model.Notifier;
+import org.apache.maven.model.Organization;
+import org.apache.maven.model.Parent;
+import org.apache.maven.model.PatternSet;
+import org.apache.maven.model.Plugin;
+import org.apache.maven.model.PluginConfiguration;
+import org.apache.maven.model.PluginContainer;
+import org.apache.maven.model.PluginExecution;
+import org.apache.maven.model.PluginManagement;
+import org.apache.maven.model.Prerequisites;
+import org.apache.maven.model.Profile;
+import org.apache.maven.model.Relocation;
+import org.apache.maven.model.ReportPlugin;
+import org.apache.maven.model.ReportSet;
+import org.apache.maven.model.Reporting;
+import org.apache.maven.model.Repository;
+import org.apache.maven.model.RepositoryBase;
+import org.apache.maven.model.RepositoryPolicy;
+import org.apache.maven.model.Resource;
+import org.apache.maven.model.Scm;
+import org.apache.maven.model.Site;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class MavenXpp3ReaderEx.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MavenXpp3ReaderEx
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MavenXpp3ReaderEx()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.model.io.xpp3.MavenXpp3ReaderEx()
+
+    public MavenXpp3ReaderEx(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.model.io.xpp3.MavenXpp3ReaderEx(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    public Model read( Reader reader, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict, source );
+    } //-- Model read( Reader, boolean, InputSource )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    public Model read( InputStream in, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict, source );
+    } //-- Model read( InputStream, boolean, InputSource )
+
+    /**
+     * Method parseActivation.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Activation
+     */
+    private Activation parseActivation( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Activation activation = new Activation();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        activation.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "activeByDefault", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activation.setLocation( "activeByDefault", _location );
+                activation.setActiveByDefault( getBooleanValue( interpolatedTrimmed( parser.nextText(), "activeByDefault" ), "activeByDefault", parser, "false" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "jdk", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activation.setLocation( "jdk", _location );
+                activation.setJdk( interpolatedTrimmed( parser.nextText(), "jdk" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "os", null, parsed ) )
+            {
+                activation.setOs( parseActivationOS( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "property", null, parsed ) )
+            {
+                activation.setProperty( parseActivationProperty( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "file", null, parsed ) )
+            {
+                activation.setFile( parseActivationFile( parser, strict, source ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activation;
+    } //-- Activation parseActivation( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseActivationFile.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationFile
+     */
+    private ActivationFile parseActivationFile( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationFile activationFile = new ActivationFile();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        activationFile.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "missing", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationFile.setLocation( "missing", _location );
+                activationFile.setMissing( interpolatedTrimmed( parser.nextText(), "missing" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "exists", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationFile.setLocation( "exists", _location );
+                activationFile.setExists( interpolatedTrimmed( parser.nextText(), "exists" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationFile;
+    } //-- ActivationFile parseActivationFile( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseActivationOS.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationOS
+     */
+    private ActivationOS parseActivationOS( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationOS activationOS = new ActivationOS();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        activationOS.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationOS.setLocation( "name", _location );
+                activationOS.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "family", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationOS.setLocation( "family", _location );
+                activationOS.setFamily( interpolatedTrimmed( parser.nextText(), "family" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "arch", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationOS.setLocation( "arch", _location );
+                activationOS.setArch( interpolatedTrimmed( parser.nextText(), "arch" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationOS.setLocation( "version", _location );
+                activationOS.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationOS;
+    } //-- ActivationOS parseActivationOS( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseActivationProperty.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationProperty
+     */
+    private ActivationProperty parseActivationProperty( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationProperty activationProperty = new ActivationProperty();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        activationProperty.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationProperty.setLocation( "name", _location );
+                activationProperty.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "value", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                activationProperty.setLocation( "value", _location );
+                activationProperty.setValue( interpolatedTrimmed( parser.nextText(), "value" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationProperty;
+    } //-- ActivationProperty parseActivationProperty( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseBuild.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Build
+     */
+    private Build parseBuild( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Build build = new Build();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        build.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "sourceDirectory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "sourceDirectory", _location );
+                build.setSourceDirectory( interpolatedTrimmed( parser.nextText(), "sourceDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "scriptSourceDirectory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "scriptSourceDirectory", _location );
+                build.setScriptSourceDirectory( interpolatedTrimmed( parser.nextText(), "scriptSourceDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "testSourceDirectory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "testSourceDirectory", _location );
+                build.setTestSourceDirectory( interpolatedTrimmed( parser.nextText(), "testSourceDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "outputDirectory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "outputDirectory", _location );
+                build.setOutputDirectory( interpolatedTrimmed( parser.nextText(), "outputDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "testOutputDirectory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "testOutputDirectory", _location );
+                build.setTestOutputDirectory( interpolatedTrimmed( parser.nextText(), "testOutputDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "extensions", null, parsed ) )
+            {
+                java.util.List extensions = new java.util.ArrayList/*<Extension>*/();
+                build.setExtensions( extensions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "extension".equals( parser.getName() ) )
+                    {
+                        extensions.add( parseExtension( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "defaultGoal", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "defaultGoal", _location );
+                build.setDefaultGoal( interpolatedTrimmed( parser.nextText(), "defaultGoal" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "resources", null, parsed ) )
+            {
+                java.util.List resources = new java.util.ArrayList/*<Resource>*/();
+                build.setResources( resources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "resource".equals( parser.getName() ) )
+                    {
+                        resources.add( parseResource( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "testResources", null, parsed ) )
+            {
+                java.util.List testResources = new java.util.ArrayList/*<Resource>*/();
+                build.setTestResources( testResources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "testResource".equals( parser.getName() ) )
+                    {
+                        testResources.add( parseResource( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "directory", _location );
+                build.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "finalName", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "finalName", _location );
+                build.setFinalName( interpolatedTrimmed( parser.nextText(), "finalName" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filters", null, parsed ) )
+            {
+                java.util.List filters = new java.util.ArrayList/*<String>*/();
+                build.setFilters( filters );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                build.setLocation( "filters", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "filter".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( filters.size() ), _location );
+                        filters.add( interpolatedTrimmed( parser.nextText(), "filters" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
+            {
+                build.setPluginManagement( parsePluginManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                build.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return build;
+    } //-- Build parseBuild( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseBuildBase.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return BuildBase
+     */
+    private BuildBase parseBuildBase( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        BuildBase buildBase = new BuildBase();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        buildBase.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "defaultGoal", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                buildBase.setLocation( "defaultGoal", _location );
+                buildBase.setDefaultGoal( interpolatedTrimmed( parser.nextText(), "defaultGoal" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "resources", null, parsed ) )
+            {
+                java.util.List resources = new java.util.ArrayList/*<Resource>*/();
+                buildBase.setResources( resources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "resource".equals( parser.getName() ) )
+                    {
+                        resources.add( parseResource( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "testResources", null, parsed ) )
+            {
+                java.util.List testResources = new java.util.ArrayList/*<Resource>*/();
+                buildBase.setTestResources( testResources );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "testResource".equals( parser.getName() ) )
+                    {
+                        testResources.add( parseResource( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                buildBase.setLocation( "directory", _location );
+                buildBase.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "finalName", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                buildBase.setLocation( "finalName", _location );
+                buildBase.setFinalName( interpolatedTrimmed( parser.nextText(), "finalName" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filters", null, parsed ) )
+            {
+                java.util.List filters = new java.util.ArrayList/*<String>*/();
+                buildBase.setFilters( filters );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                buildBase.setLocation( "filters", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "filter".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( filters.size() ), _location );
+                        filters.add( interpolatedTrimmed( parser.nextText(), "filters" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
+            {
+                buildBase.setPluginManagement( parsePluginManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                buildBase.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return buildBase;
+    } //-- BuildBase parseBuildBase( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseCiManagement.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return CiManagement
+     */
+    private CiManagement parseCiManagement( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        CiManagement ciManagement = new CiManagement();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        ciManagement.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "system", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                ciManagement.setLocation( "system", _location );
+                ciManagement.setSystem( interpolatedTrimmed( parser.nextText(), "system" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                ciManagement.setLocation( "url", _location );
+                ciManagement.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "notifiers", null, parsed ) )
+            {
+                java.util.List notifiers = new java.util.ArrayList/*<Notifier>*/();
+                ciManagement.setNotifiers( notifiers );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "notifier".equals( parser.getName() ) )
+                    {
+                        notifiers.add( parseNotifier( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return ciManagement;
+    } //-- CiManagement parseCiManagement( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseConfigurationContainer.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ConfigurationContainer
+     */
+    private ConfigurationContainer parseConfigurationContainer( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ConfigurationContainer configurationContainer = new ConfigurationContainer();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        configurationContainer.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                configurationContainer.setLocation( "inherited", _location );
+                configurationContainer.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                configurationContainer.setLocation( "configuration", _location );
+                configurationContainer.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return configurationContainer;
+    } //-- ConfigurationContainer parseConfigurationContainer( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseContributor.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Contributor
+     */
+    private Contributor parseContributor( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Contributor contributor = new Contributor();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        contributor.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "name", _location );
+                contributor.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "email", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "email", _location );
+                contributor.setEmail( interpolatedTrimmed( parser.nextText(), "email" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "url", _location );
+                contributor.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "organization", _location );
+                contributor.setOrganization( interpolatedTrimmed( parser.nextText(), "organization" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organizationUrl", "organisationUrl", parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "organizationUrl", _location );
+                contributor.setOrganizationUrl( interpolatedTrimmed( parser.nextText(), "organizationUrl" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "roles", null, parsed ) )
+            {
+                java.util.List roles = new java.util.ArrayList/*<String>*/();
+                contributor.setRoles( roles );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "roles", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "role".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( roles.size() ), _location );
+                        roles.add( interpolatedTrimmed( parser.nextText(), "roles" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "timezone", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "timezone", _location );
+                contributor.setTimezone( interpolatedTrimmed( parser.nextText(), "timezone" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                contributor.setLocation( "properties", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                    _locations.setLocation( key, _location );
+                    String value = parser.nextText().trim();
+                    contributor.addProperty( key, value );
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return contributor;
+    } //-- Contributor parseContributor( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseDependency.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Dependency
+     */
+    private Dependency parseDependency( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Dependency dependency = new Dependency();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        dependency.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "groupId", _location );
+                dependency.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "artifactId", _location );
+                dependency.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "version", _location );
+                dependency.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "type", _location );
+                dependency.setType( interpolatedTrimmed( parser.nextText(), "type" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "classifier", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "classifier", _location );
+                dependency.setClassifier( interpolatedTrimmed( parser.nextText(), "classifier" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "scope", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "scope", _location );
+                dependency.setScope( interpolatedTrimmed( parser.nextText(), "scope" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "systemPath", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "systemPath", _location );
+                dependency.setSystemPath( interpolatedTrimmed( parser.nextText(), "systemPath" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "exclusions", null, parsed ) )
+            {
+                java.util.List exclusions = new java.util.ArrayList/*<Exclusion>*/();
+                dependency.setExclusions( exclusions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclusion".equals( parser.getName() ) )
+                    {
+                        exclusions.add( parseExclusion( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "optional", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                dependency.setLocation( "optional", _location );
+                dependency.setOptional( interpolatedTrimmed( parser.nextText(), "optional" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return dependency;
+    } //-- Dependency parseDependency( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseDependencyManagement.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return DependencyManagement
+     */
+    private DependencyManagement parseDependencyManagement( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        DependencyManagement dependencyManagement = new DependencyManagement();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        dependencyManagement.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                dependencyManagement.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return dependencyManagement;
+    } //-- DependencyManagement parseDependencyManagement( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseDeploymentRepository.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return DeploymentRepository
+     */
+    private DeploymentRepository parseDeploymentRepository( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        DeploymentRepository deploymentRepository = new DeploymentRepository();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        deploymentRepository.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "uniqueVersion", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                deploymentRepository.setLocation( "uniqueVersion", _location );
+                deploymentRepository.setUniqueVersion( getBooleanValue( interpolatedTrimmed( parser.nextText(), "uniqueVersion" ), "uniqueVersion", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
+            {
+                deploymentRepository.setReleases( parseRepositoryPolicy( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
+            {
+                deploymentRepository.setSnapshots( parseRepositoryPolicy( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                deploymentRepository.setLocation( "id", _location );
+                deploymentRepository.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                deploymentRepository.setLocation( "name", _location );
+                deploymentRepository.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                deploymentRepository.setLocation( "url", _location );
+                deploymentRepository.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                deploymentRepository.setLocation( "layout", _location );
+                deploymentRepository.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return deploymentRepository;
+    } //-- DeploymentRepository parseDeploymentRepository( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseDeveloper.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Developer
+     */
+    private Developer parseDeveloper( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Developer developer = new Developer();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        developer.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "id", _location );
+                developer.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "name", _location );
+                developer.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "email", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "email", _location );
+                developer.setEmail( interpolatedTrimmed( parser.nextText(), "email" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "url", _location );
+                developer.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "organization", _location );
+                developer.setOrganization( interpolatedTrimmed( parser.nextText(), "organization" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organizationUrl", "organisationUrl", parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "organizationUrl", _location );
+                developer.setOrganizationUrl( interpolatedTrimmed( parser.nextText(), "organizationUrl" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "roles", null, parsed ) )
+            {
+                java.util.List roles = new java.util.ArrayList/*<String>*/();
+                developer.setRoles( roles );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "roles", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "role".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( roles.size() ), _location );
+                        roles.add( interpolatedTrimmed( parser.nextText(), "roles" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "timezone", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "timezone", _location );
+                developer.setTimezone( interpolatedTrimmed( parser.nextText(), "timezone" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                developer.setLocation( "properties", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                    _locations.setLocation( key, _location );
+                    String value = parser.nextText().trim();
+                    developer.addProperty( key, value );
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return developer;
+    } //-- Developer parseDeveloper( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseDistributionManagement.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return DistributionManagement
+     */
+    private DistributionManagement parseDistributionManagement( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        DistributionManagement distributionManagement = new DistributionManagement();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        distributionManagement.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "repository", null, parsed ) )
+            {
+                distributionManagement.setRepository( parseDeploymentRepository( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshotRepository", null, parsed ) )
+            {
+                distributionManagement.setSnapshotRepository( parseDeploymentRepository( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "site", null, parsed ) )
+            {
+                distributionManagement.setSite( parseSite( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "downloadUrl", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                distributionManagement.setLocation( "downloadUrl", _location );
+                distributionManagement.setDownloadUrl( interpolatedTrimmed( parser.nextText(), "downloadUrl" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "relocation", null, parsed ) )
+            {
+                distributionManagement.setRelocation( parseRelocation( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "status", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                distributionManagement.setLocation( "status", _location );
+                distributionManagement.setStatus( interpolatedTrimmed( parser.nextText(), "status" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return distributionManagement;
+    } //-- DistributionManagement parseDistributionManagement( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseExclusion.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Exclusion
+     */
+    private Exclusion parseExclusion( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Exclusion exclusion = new Exclusion();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        exclusion.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                exclusion.setLocation( "artifactId", _location );
+                exclusion.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                exclusion.setLocation( "groupId", _location );
+                exclusion.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return exclusion;
+    } //-- Exclusion parseExclusion( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseExtension.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Extension
+     */
+    private Extension parseExtension( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Extension extension = new Extension();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        extension.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                extension.setLocation( "groupId", _location );
+                extension.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                extension.setLocation( "artifactId", _location );
+                extension.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                extension.setLocation( "version", _location );
+                extension.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return extension;
+    } //-- Extension parseExtension( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseFileSet.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return FileSet
+     */
+    private FileSet parseFileSet( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        FileSet fileSet = new FileSet();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        fileSet.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                fileSet.setLocation( "directory", _location );
+                fileSet.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
+            {
+                java.util.List includes = new java.util.ArrayList/*<String>*/();
+                fileSet.setIncludes( includes );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                fileSet.setLocation( "includes", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "include".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( includes.size() ), _location );
+                        includes.add( interpolatedTrimmed( parser.nextText(), "includes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
+            {
+                java.util.List excludes = new java.util.ArrayList/*<String>*/();
+                fileSet.setExcludes( excludes );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                fileSet.setLocation( "excludes", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclude".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( excludes.size() ), _location );
+                        excludes.add( interpolatedTrimmed( parser.nextText(), "excludes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return fileSet;
+    } //-- FileSet parseFileSet( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseIssueManagement.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return IssueManagement
+     */
+    private IssueManagement parseIssueManagement( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        IssueManagement issueManagement = new IssueManagement();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        issueManagement.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "system", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                issueManagement.setLocation( "system", _location );
+                issueManagement.setSystem( interpolatedTrimmed( parser.nextText(), "system" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                issueManagement.setLocation( "url", _location );
+                issueManagement.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return issueManagement;
+    } //-- IssueManagement parseIssueManagement( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseLicense.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return License
+     */
+    private License parseLicense( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        License license = new License();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        license.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                license.setLocation( "name", _location );
+                license.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                license.setLocation( "url", _location );
+                license.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "distribution", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                license.setLocation( "distribution", _location );
+                license.setDistribution( interpolatedTrimmed( parser.nextText(), "distribution" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "comments", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                license.setLocation( "comments", _location );
+                license.setComments( interpolatedTrimmed( parser.nextText(), "comments" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return license;
+    } //-- License parseLicense( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseMailingList.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return MailingList
+     */
+    private MailingList parseMailingList( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        MailingList mailingList = new MailingList();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        mailingList.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                mailingList.setLocation( "name", _location );
+                mailingList.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "subscribe", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                mailingList.setLocation( "subscribe", _location );
+                mailingList.setSubscribe( interpolatedTrimmed( parser.nextText(), "subscribe" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "unsubscribe", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                mailingList.setLocation( "unsubscribe", _location );
+                mailingList.setUnsubscribe( interpolatedTrimmed( parser.nextText(), "unsubscribe" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "post", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                mailingList.setLocation( "post", _location );
+                mailingList.setPost( interpolatedTrimmed( parser.nextText(), "post" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "archive", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                mailingList.setLocation( "archive", _location );
+                mailingList.setArchive( interpolatedTrimmed( parser.nextText(), "archive" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "otherArchives", null, parsed ) )
+            {
+                java.util.List otherArchives = new java.util.ArrayList/*<String>*/();
+                mailingList.setOtherArchives( otherArchives );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                mailingList.setLocation( "otherArchives", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "otherArchive".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( otherArchives.size() ), _location );
+                        otherArchives.add( interpolatedTrimmed( parser.nextText(), "otherArchives" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return mailingList;
+    } //-- MailingList parseMailingList( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseModel.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    private Model parseModel( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Model model = new Model();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        model.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "modelVersion", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "modelVersion", _location );
+                model.setModelVersion( interpolatedTrimmed( parser.nextText(), "modelVersion" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "parent", null, parsed ) )
+            {
+                model.setParent( parseParent( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "groupId", _location );
+                model.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "artifactId", _location );
+                model.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "version", _location );
+                model.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "packaging", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "packaging", _location );
+                model.setPackaging( interpolatedTrimmed( parser.nextText(), "packaging" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "name", _location );
+                model.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "description", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "description", _location );
+                model.setDescription( interpolatedTrimmed( parser.nextText(), "description" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "url", _location );
+                model.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "inceptionYear", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "inceptionYear", _location );
+                model.setInceptionYear( interpolatedTrimmed( parser.nextText(), "inceptionYear" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
+            {
+                model.setOrganization( parseOrganization( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "licenses", null, parsed ) )
+            {
+                java.util.List licenses = new java.util.ArrayList/*<License>*/();
+                model.setLicenses( licenses );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "license".equals( parser.getName() ) )
+                    {
+                        licenses.add( parseLicense( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "developers", null, parsed ) )
+            {
+                java.util.List developers = new java.util.ArrayList/*<Developer>*/();
+                model.setDevelopers( developers );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "developer".equals( parser.getName() ) )
+                    {
+                        developers.add( parseDeveloper( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "contributors", null, parsed ) )
+            {
+                java.util.List contributors = new java.util.ArrayList/*<Contributor>*/();
+                model.setContributors( contributors );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "contributor".equals( parser.getName() ) )
+                    {
+                        contributors.add( parseContributor( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "mailingLists", null, parsed ) )
+            {
+                java.util.List mailingLists = new java.util.ArrayList/*<MailingList>*/();
+                model.setMailingLists( mailingLists );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "mailingList".equals( parser.getName() ) )
+                    {
+                        mailingLists.add( parseMailingList( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "prerequisites", null, parsed ) )
+            {
+                model.setPrerequisites( parsePrerequisites( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
+            {
+                java.util.List modules = new java.util.ArrayList/*<String>*/();
+                model.setModules( modules );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "modules", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "module".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( modules.size() ), _location );
+                        modules.add( interpolatedTrimmed( parser.nextText(), "modules" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "scm", null, parsed ) )
+            {
+                model.setScm( parseScm( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "issueManagement", null, parsed ) )
+            {
+                model.setIssueManagement( parseIssueManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "ciManagement", null, parsed ) )
+            {
+                model.setCiManagement( parseCiManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
+            {
+                model.setDistributionManagement( parseDistributionManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "properties", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                    _locations.setLocation( key, _location );
+                    String value = parser.nextText().trim();
+                    model.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
+            {
+                model.setDependencyManagement( parseDependencyManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                model.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                model.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                model.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "build", null, parsed ) )
+            {
+                model.setBuild( parseBuild( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                model.setLocation( "reports", _location );
+                model.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
+            {
+                model.setReporting( parseReporting( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "profiles", null, parsed ) )
+            {
+                java.util.List profiles = new java.util.ArrayList/*<Profile>*/();
+                model.setProfiles( profiles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "profile".equals( parser.getName() ) )
+                    {
+                        profiles.add( parseProfile( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return model;
+    } //-- Model parseModel( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseModelBase.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ModelBase
+     */
+    private ModelBase parseModelBase( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ModelBase modelBase = new ModelBase();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        modelBase.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
+            {
+                java.util.List modules = new java.util.ArrayList/*<String>*/();
+                modelBase.setModules( modules );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                modelBase.setLocation( "modules", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "module".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( modules.size() ), _location );
+                        modules.add( interpolatedTrimmed( parser.nextText(), "modules" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
+            {
+                modelBase.setDistributionManagement( parseDistributionManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                modelBase.setLocation( "properties", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                    _locations.setLocation( key, _location );
+                    String value = parser.nextText().trim();
+                    modelBase.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
+            {
+                modelBase.setDependencyManagement( parseDependencyManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                modelBase.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                modelBase.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                modelBase.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                modelBase.setLocation( "reports", _location );
+                modelBase.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
+            {
+                modelBase.setReporting( parseReporting( parser, strict, source ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return modelBase;
+    } //-- ModelBase parseModelBase( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseNotifier.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Notifier
+     */
+    private Notifier parseNotifier( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Notifier notifier = new Notifier();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        notifier.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "type", _location );
+                notifier.setType( interpolatedTrimmed( parser.nextText(), "type" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnError", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "sendOnError", _location );
+                notifier.setSendOnError( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnError" ), "sendOnError", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnFailure", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "sendOnFailure", _location );
+                notifier.setSendOnFailure( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnFailure" ), "sendOnFailure", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnSuccess", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "sendOnSuccess", _location );
+                notifier.setSendOnSuccess( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnSuccess" ), "sendOnSuccess", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "sendOnWarning", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "sendOnWarning", _location );
+                notifier.setSendOnWarning( getBooleanValue( interpolatedTrimmed( parser.nextText(), "sendOnWarning" ), "sendOnWarning", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "address", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "address", _location );
+                notifier.setAddress( interpolatedTrimmed( parser.nextText(), "address" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                notifier.setLocation( "configuration", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                    _locations.setLocation( key, _location );
+                    String value = parser.nextText().trim();
+                    notifier.addConfiguration( key, value );
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return notifier;
+    } //-- Notifier parseNotifier( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseOrganization.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Organization
+     */
+    private Organization parseOrganization( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Organization organization = new Organization();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        organization.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                organization.setLocation( "name", _location );
+                organization.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                organization.setLocation( "url", _location );
+                organization.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return organization;
+    } //-- Organization parseOrganization( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseParent.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Parent
+     */
+    private Parent parseParent( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Parent parent = new Parent();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        parent.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                parent.setLocation( "groupId", _location );
+                parent.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                parent.setLocation( "artifactId", _location );
+                parent.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                parent.setLocation( "version", _location );
+                parent.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "relativePath", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                parent.setLocation( "relativePath", _location );
+                parent.setRelativePath( interpolatedTrimmed( parser.nextText(), "relativePath" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return parent;
+    } //-- Parent parseParent( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePatternSet.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PatternSet
+     */
+    private PatternSet parsePatternSet( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PatternSet patternSet = new PatternSet();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        patternSet.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
+            {
+                java.util.List includes = new java.util.ArrayList/*<String>*/();
+                patternSet.setIncludes( includes );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                patternSet.setLocation( "includes", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "include".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( includes.size() ), _location );
+                        includes.add( interpolatedTrimmed( parser.nextText(), "includes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
+            {
+                java.util.List excludes = new java.util.ArrayList/*<String>*/();
+                patternSet.setExcludes( excludes );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                patternSet.setLocation( "excludes", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclude".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( excludes.size() ), _location );
+                        excludes.add( interpolatedTrimmed( parser.nextText(), "excludes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return patternSet;
+    } //-- PatternSet parsePatternSet( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePlugin.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Plugin
+     */
+    private Plugin parsePlugin( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Plugin plugin = new Plugin();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        plugin.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "groupId", _location );
+                plugin.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "artifactId", _location );
+                plugin.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "version", _location );
+                plugin.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "extensions", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "extensions", _location );
+                plugin.setExtensions( interpolatedTrimmed( parser.nextText(), "extensions" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "executions", null, parsed ) )
+            {
+                java.util.List executions = new java.util.ArrayList/*<PluginExecution>*/();
+                plugin.setExecutions( executions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "execution".equals( parser.getName() ) )
+                    {
+                        executions.add( parsePluginExecution( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                plugin.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "goals", _location );
+                plugin.setGoals( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "inherited", _location );
+                plugin.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                plugin.setLocation( "configuration", _location );
+                plugin.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return plugin;
+    } //-- Plugin parsePlugin( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePluginConfiguration.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginConfiguration
+     */
+    private PluginConfiguration parsePluginConfiguration( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginConfiguration pluginConfiguration = new PluginConfiguration();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        pluginConfiguration.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
+            {
+                pluginConfiguration.setPluginManagement( parsePluginManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                pluginConfiguration.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginConfiguration;
+    } //-- PluginConfiguration parsePluginConfiguration( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePluginContainer.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginContainer
+     */
+    private PluginContainer parsePluginContainer( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginContainer pluginContainer = new PluginContainer();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        pluginContainer.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                pluginContainer.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginContainer;
+    } //-- PluginContainer parsePluginContainer( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePluginExecution.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginExecution
+     */
+    private PluginExecution parsePluginExecution( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginExecution pluginExecution = new PluginExecution();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        pluginExecution.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                pluginExecution.setLocation( "id", _location );
+                pluginExecution.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "phase", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                pluginExecution.setLocation( "phase", _location );
+                pluginExecution.setPhase( interpolatedTrimmed( parser.nextText(), "phase" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
+            {
+                java.util.List goals = new java.util.ArrayList/*<String>*/();
+                pluginExecution.setGoals( goals );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                pluginExecution.setLocation( "goals", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "goal".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( goals.size() ), _location );
+                        goals.add( interpolatedTrimmed( parser.nextText(), "goals" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                pluginExecution.setLocation( "inherited", _location );
+                pluginExecution.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                pluginExecution.setLocation( "configuration", _location );
+                pluginExecution.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginExecution;
+    } //-- PluginExecution parsePluginExecution( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePluginManagement.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return PluginManagement
+     */
+    private PluginManagement parsePluginManagement( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        PluginManagement pluginManagement = new PluginManagement();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        pluginManagement.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                pluginManagement.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return pluginManagement;
+    } //-- PluginManagement parsePluginManagement( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parsePrerequisites.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Prerequisites
+     */
+    private Prerequisites parsePrerequisites( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Prerequisites prerequisites = new Prerequisites();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        prerequisites.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "maven", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                prerequisites.setLocation( "maven", _location );
+                prerequisites.setMaven( interpolatedTrimmed( parser.nextText(), "maven" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return prerequisites;
+    } //-- Prerequisites parsePrerequisites( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseProfile.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Profile
+     */
+    private Profile parseProfile( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Profile profile = new Profile();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        profile.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                profile.setLocation( "id", _location );
+                profile.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "activation", null, parsed ) )
+            {
+                profile.setActivation( parseActivation( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "build", null, parsed ) )
+            {
+                profile.setBuild( parseBuildBase( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
+            {
+                java.util.List modules = new java.util.ArrayList/*<String>*/();
+                profile.setModules( modules );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                profile.setLocation( "modules", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "module".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( modules.size() ), _location );
+                        modules.add( interpolatedTrimmed( parser.nextText(), "modules" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
+            {
+                profile.setDistributionManagement( parseDistributionManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                profile.setLocation( "properties", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                    _locations.setLocation( key, _location );
+                    String value = parser.nextText().trim();
+                    profile.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
+            {
+                profile.setDependencyManagement( parseDependencyManagement( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                profile.setDependencies( dependencies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "dependency".equals( parser.getName() ) )
+                    {
+                        dependencies.add( parseDependency( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                profile.setLocation( "reports", _location );
+                profile.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
+            {
+                profile.setReporting( parseReporting( parser, strict, source ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return profile;
+    } //-- Profile parseProfile( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseRelocation.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Relocation
+     */
+    private Relocation parseRelocation( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Relocation relocation = new Relocation();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        relocation.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                relocation.setLocation( "groupId", _location );
+                relocation.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                relocation.setLocation( "artifactId", _location );
+                relocation.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                relocation.setLocation( "version", _location );
+                relocation.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "message", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                relocation.setLocation( "message", _location );
+                relocation.setMessage( interpolatedTrimmed( parser.nextText(), "message" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return relocation;
+    } //-- Relocation parseRelocation( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseReportPlugin.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ReportPlugin
+     */
+    private ReportPlugin parseReportPlugin( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ReportPlugin reportPlugin = new ReportPlugin();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        reportPlugin.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportPlugin.setLocation( "groupId", _location );
+                reportPlugin.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportPlugin.setLocation( "artifactId", _location );
+                reportPlugin.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportPlugin.setLocation( "version", _location );
+                reportPlugin.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reportSets", null, parsed ) )
+            {
+                java.util.List reportSets = new java.util.ArrayList/*<ReportSet>*/();
+                reportPlugin.setReportSets( reportSets );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "reportSet".equals( parser.getName() ) )
+                    {
+                        reportSets.add( parseReportSet( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportPlugin.setLocation( "inherited", _location );
+                reportPlugin.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportPlugin.setLocation( "configuration", _location );
+                reportPlugin.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return reportPlugin;
+    } //-- ReportPlugin parseReportPlugin( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseReportSet.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ReportSet
+     */
+    private ReportSet parseReportSet( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ReportSet reportSet = new ReportSet();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        reportSet.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportSet.setLocation( "id", _location );
+                reportSet.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
+            {
+                java.util.List reports = new java.util.ArrayList/*<String>*/();
+                reportSet.setReports( reports );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportSet.setLocation( "reports", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "report".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( reports.size() ), _location );
+                        reports.add( interpolatedTrimmed( parser.nextText(), "reports" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportSet.setLocation( "inherited", _location );
+                reportSet.setInherited( interpolatedTrimmed( parser.nextText(), "inherited" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reportSet.setLocation( "configuration", _location );
+                reportSet.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return reportSet;
+    } //-- ReportSet parseReportSet( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseReporting.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Reporting
+     */
+    private Reporting parseReporting( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Reporting reporting = new Reporting();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        reporting.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "excludeDefaults", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reporting.setLocation( "excludeDefaults", _location );
+                reporting.setExcludeDefaults( interpolatedTrimmed( parser.nextText(), "excludeDefaults" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "outputDirectory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                reporting.setLocation( "outputDirectory", _location );
+                reporting.setOutputDirectory( interpolatedTrimmed( parser.nextText(), "outputDirectory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<ReportPlugin>*/();
+                reporting.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parseReportPlugin( parser, strict, source ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return reporting;
+    } //-- Reporting parseReporting( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseRepository.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Repository
+     */
+    private Repository parseRepository( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Repository repository = new Repository();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        repository.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
+            {
+                repository.setReleases( parseRepositoryPolicy( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
+            {
+                repository.setSnapshots( parseRepositoryPolicy( parser, strict, source ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repository.setLocation( "id", _location );
+                repository.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repository.setLocation( "name", _location );
+                repository.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repository.setLocation( "url", _location );
+                repository.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repository.setLocation( "layout", _location );
+                repository.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repository;
+    } //-- Repository parseRepository( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseRepositoryBase.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryBase
+     */
+    private RepositoryBase parseRepositoryBase( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryBase repositoryBase = new RepositoryBase();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        repositoryBase.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryBase.setLocation( "id", _location );
+                repositoryBase.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryBase.setLocation( "name", _location );
+                repositoryBase.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryBase.setLocation( "url", _location );
+                repositoryBase.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryBase.setLocation( "layout", _location );
+                repositoryBase.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryBase;
+    } //-- RepositoryBase parseRepositoryBase( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseRepositoryPolicy.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryPolicy
+     */
+    private RepositoryPolicy parseRepositoryPolicy( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryPolicy repositoryPolicy = new RepositoryPolicy();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        repositoryPolicy.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "enabled", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryPolicy.setLocation( "enabled", _location );
+                repositoryPolicy.setEnabled( interpolatedTrimmed( parser.nextText(), "enabled" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "updatePolicy", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryPolicy.setLocation( "updatePolicy", _location );
+                repositoryPolicy.setUpdatePolicy( interpolatedTrimmed( parser.nextText(), "updatePolicy" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "checksumPolicy", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                repositoryPolicy.setLocation( "checksumPolicy", _location );
+                repositoryPolicy.setChecksumPolicy( interpolatedTrimmed( parser.nextText(), "checksumPolicy" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryPolicy;
+    } //-- RepositoryPolicy parseRepositoryPolicy( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseResource.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Resource
+     */
+    private Resource parseResource( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Resource resource = new Resource();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        resource.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "targetPath", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                resource.setLocation( "targetPath", _location );
+                resource.setTargetPath( interpolatedTrimmed( parser.nextText(), "targetPath" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filtering", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                resource.setLocation( "filtering", _location );
+                resource.setFiltering( interpolatedTrimmed( parser.nextText(), "filtering" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                resource.setLocation( "directory", _location );
+                resource.setDirectory( interpolatedTrimmed( parser.nextText(), "directory" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
+            {
+                java.util.List includes = new java.util.ArrayList/*<String>*/();
+                resource.setIncludes( includes );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                resource.setLocation( "includes", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "include".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( includes.size() ), _location );
+                        includes.add( interpolatedTrimmed( parser.nextText(), "includes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
+            {
+                java.util.List excludes = new java.util.ArrayList/*<String>*/();
+                resource.setExcludes( excludes );
+                InputLocation _locations;
+                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                resource.setLocation( "excludes", _locations );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "exclude".equals( parser.getName() ) )
+                    {
+                        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                        _locations.setLocation( Integer.valueOf( excludes.size() ), _location );
+                        excludes.add( interpolatedTrimmed( parser.nextText(), "excludes" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return resource;
+    } //-- Resource parseResource( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseScm.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Scm
+     */
+    private Scm parseScm( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Scm scm = new Scm();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        scm.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "connection", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                scm.setLocation( "connection", _location );
+                scm.setConnection( interpolatedTrimmed( parser.nextText(), "connection" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "developerConnection", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                scm.setLocation( "developerConnection", _location );
+                scm.setDeveloperConnection( interpolatedTrimmed( parser.nextText(), "developerConnection" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "tag", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                scm.setLocation( "tag", _location );
+                scm.setTag( interpolatedTrimmed( parser.nextText(), "tag" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                scm.setLocation( "url", _location );
+                scm.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return scm;
+    } //-- Scm parseScm( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method parseSite.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Site
+     */
+    private Site parseSite( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Site site = new Site();
+        InputLocation _location;
+        _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+        site.setLocation( "", _location );
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                site.setLocation( "id", _location );
+                site.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                site.setLocation( "name", _location );
+                site.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
+                site.setLocation( "url", _location );
+                site.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return site;
+    } //-- Site parseSite( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param source
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Model
+     */
+    private Model read( XmlPullParser parser, boolean strict, InputSource source )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "project".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'project' but found '" + parser.getName() + "'", parser, null );
+                }
+                Model model = parseModel( parser, strict, source );
+                model.setModelEncoding( parser.getInputEncoding() );
+                return model;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'project' but found no element at all: invalid XML document", parser, null );
+    } //-- Model read( XmlPullParser, boolean, InputSource )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Writer.java b/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Writer.java
new file mode 100644
index 0000000..00732b2
--- /dev/null
+++ b/maven-model/target/generated-sources/modello/org/apache/maven/model/io/xpp3/MavenXpp3Writer.java
@@ -0,0 +1,2003 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.model.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.model.Activation;
+import org.apache.maven.model.ActivationFile;
+import org.apache.maven.model.ActivationOS;
+import org.apache.maven.model.ActivationProperty;
+import org.apache.maven.model.Build;
+import org.apache.maven.model.BuildBase;
+import org.apache.maven.model.CiManagement;
+import org.apache.maven.model.ConfigurationContainer;
+import org.apache.maven.model.Contributor;
+import org.apache.maven.model.Dependency;
+import org.apache.maven.model.DependencyManagement;
+import org.apache.maven.model.DeploymentRepository;
+import org.apache.maven.model.Developer;
+import org.apache.maven.model.DistributionManagement;
+import org.apache.maven.model.Exclusion;
+import org.apache.maven.model.Extension;
+import org.apache.maven.model.FileSet;
+import org.apache.maven.model.IssueManagement;
+import org.apache.maven.model.License;
+import org.apache.maven.model.MailingList;
+import org.apache.maven.model.Model;
+import org.apache.maven.model.ModelBase;
+import org.apache.maven.model.Notifier;
+import org.apache.maven.model.Organization;
+import org.apache.maven.model.Parent;
+import org.apache.maven.model.PatternSet;
+import org.apache.maven.model.Plugin;
+import org.apache.maven.model.PluginConfiguration;
+import org.apache.maven.model.PluginContainer;
+import org.apache.maven.model.PluginExecution;
+import org.apache.maven.model.PluginManagement;
+import org.apache.maven.model.Prerequisites;
+import org.apache.maven.model.Profile;
+import org.apache.maven.model.Relocation;
+import org.apache.maven.model.ReportPlugin;
+import org.apache.maven.model.ReportSet;
+import org.apache.maven.model.Reporting;
+import org.apache.maven.model.Repository;
+import org.apache.maven.model.RepositoryBase;
+import org.apache.maven.model.RepositoryPolicy;
+import org.apache.maven.model.Resource;
+import org.apache.maven.model.Scm;
+import org.apache.maven.model.Site;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class MavenXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MavenXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param model
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, Model model )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( model.getModelEncoding(), null );
+        writeModel( model, "project", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, Model )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param model
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, Model model )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, model.getModelEncoding() );
+        serializer.startDocument( model.getModelEncoding(), null );
+        writeModel( model, "project", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, Model )
+
+    /**
+     * Method writeActivation.
+     * 
+     * @param activation
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivation( Activation activation, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activation.isActiveByDefault() != false )
+        {
+            serializer.startTag( NAMESPACE, "activeByDefault" ).text( String.valueOf( activation.isActiveByDefault() ) ).endTag( NAMESPACE, "activeByDefault" );
+        }
+        if ( activation.getJdk() != null )
+        {
+            serializer.startTag( NAMESPACE, "jdk" ).text( activation.getJdk() ).endTag( NAMESPACE, "jdk" );
+        }
+        if ( activation.getOs() != null )
+        {
+            writeActivationOS( (ActivationOS) activation.getOs(), "os", serializer );
+        }
+        if ( activation.getProperty() != null )
+        {
+            writeActivationProperty( (ActivationProperty) activation.getProperty(), "property", serializer );
+        }
+        if ( activation.getFile() != null )
+        {
+            writeActivationFile( (ActivationFile) activation.getFile(), "file", serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivation( Activation, String, XmlSerializer )
+
+    /**
+     * Method writeActivationFile.
+     * 
+     * @param activationFile
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationFile( ActivationFile activationFile, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationFile.getMissing() != null )
+        {
+            serializer.startTag( NAMESPACE, "missing" ).text( activationFile.getMissing() ).endTag( NAMESPACE, "missing" );
+        }
+        if ( activationFile.getExists() != null )
+        {
+            serializer.startTag( NAMESPACE, "exists" ).text( activationFile.getExists() ).endTag( NAMESPACE, "exists" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationFile( ActivationFile, String, XmlSerializer )
+
+    /**
+     * Method writeActivationOS.
+     * 
+     * @param activationOS
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationOS( ActivationOS activationOS, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationOS.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( activationOS.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( activationOS.getFamily() != null )
+        {
+            serializer.startTag( NAMESPACE, "family" ).text( activationOS.getFamily() ).endTag( NAMESPACE, "family" );
+        }
+        if ( activationOS.getArch() != null )
+        {
+            serializer.startTag( NAMESPACE, "arch" ).text( activationOS.getArch() ).endTag( NAMESPACE, "arch" );
+        }
+        if ( activationOS.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( activationOS.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationOS( ActivationOS, String, XmlSerializer )
+
+    /**
+     * Method writeActivationProperty.
+     * 
+     * @param activationProperty
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationProperty( ActivationProperty activationProperty, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationProperty.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( activationProperty.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( activationProperty.getValue() != null )
+        {
+            serializer.startTag( NAMESPACE, "value" ).text( activationProperty.getValue() ).endTag( NAMESPACE, "value" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationProperty( ActivationProperty, String, XmlSerializer )
+
+    /**
+     * Method writeBuild.
+     * 
+     * @param build
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeBuild( Build build, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( build.getSourceDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "sourceDirectory" ).text( build.getSourceDirectory() ).endTag( NAMESPACE, "sourceDirectory" );
+        }
+        if ( build.getScriptSourceDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "scriptSourceDirectory" ).text( build.getScriptSourceDirectory() ).endTag( NAMESPACE, "scriptSourceDirectory" );
+        }
+        if ( build.getTestSourceDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "testSourceDirectory" ).text( build.getTestSourceDirectory() ).endTag( NAMESPACE, "testSourceDirectory" );
+        }
+        if ( build.getOutputDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "outputDirectory" ).text( build.getOutputDirectory() ).endTag( NAMESPACE, "outputDirectory" );
+        }
+        if ( build.getTestOutputDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "testOutputDirectory" ).text( build.getTestOutputDirectory() ).endTag( NAMESPACE, "testOutputDirectory" );
+        }
+        if ( ( build.getExtensions() != null ) && ( build.getExtensions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "extensions" );
+            for ( Iterator iter = build.getExtensions().iterator(); iter.hasNext(); )
+            {
+                Extension o = (Extension) iter.next();
+                writeExtension( o, "extension", serializer );
+            }
+            serializer.endTag( NAMESPACE, "extensions" );
+        }
+        if ( build.getDefaultGoal() != null )
+        {
+            serializer.startTag( NAMESPACE, "defaultGoal" ).text( build.getDefaultGoal() ).endTag( NAMESPACE, "defaultGoal" );
+        }
+        if ( ( build.getResources() != null ) && ( build.getResources().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "resources" );
+            for ( Iterator iter = build.getResources().iterator(); iter.hasNext(); )
+            {
+                Resource o = (Resource) iter.next();
+                writeResource( o, "resource", serializer );
+            }
+            serializer.endTag( NAMESPACE, "resources" );
+        }
+        if ( ( build.getTestResources() != null ) && ( build.getTestResources().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "testResources" );
+            for ( Iterator iter = build.getTestResources().iterator(); iter.hasNext(); )
+            {
+                Resource o = (Resource) iter.next();
+                writeResource( o, "testResource", serializer );
+            }
+            serializer.endTag( NAMESPACE, "testResources" );
+        }
+        if ( build.getDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "directory" ).text( build.getDirectory() ).endTag( NAMESPACE, "directory" );
+        }
+        if ( build.getFinalName() != null )
+        {
+            serializer.startTag( NAMESPACE, "finalName" ).text( build.getFinalName() ).endTag( NAMESPACE, "finalName" );
+        }
+        if ( ( build.getFilters() != null ) && ( build.getFilters().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "filters" );
+            for ( Iterator iter = build.getFilters().iterator(); iter.hasNext(); )
+            {
+                String filter = (String) iter.next();
+                serializer.startTag( NAMESPACE, "filter" ).text( filter ).endTag( NAMESPACE, "filter" );
+            }
+            serializer.endTag( NAMESPACE, "filters" );
+        }
+        if ( build.getPluginManagement() != null )
+        {
+            writePluginManagement( (PluginManagement) build.getPluginManagement(), "pluginManagement", serializer );
+        }
+        if ( ( build.getPlugins() != null ) && ( build.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = build.getPlugins().iterator(); iter.hasNext(); )
+            {
+                Plugin o = (Plugin) iter.next();
+                writePlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeBuild( Build, String, XmlSerializer )
+
+    /**
+     * Method writeBuildBase.
+     * 
+     * @param buildBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeBuildBase( BuildBase buildBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( buildBase.getDefaultGoal() != null )
+        {
+            serializer.startTag( NAMESPACE, "defaultGoal" ).text( buildBase.getDefaultGoal() ).endTag( NAMESPACE, "defaultGoal" );
+        }
+        if ( ( buildBase.getResources() != null ) && ( buildBase.getResources().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "resources" );
+            for ( Iterator iter = buildBase.getResources().iterator(); iter.hasNext(); )
+            {
+                Resource o = (Resource) iter.next();
+                writeResource( o, "resource", serializer );
+            }
+            serializer.endTag( NAMESPACE, "resources" );
+        }
+        if ( ( buildBase.getTestResources() != null ) && ( buildBase.getTestResources().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "testResources" );
+            for ( Iterator iter = buildBase.getTestResources().iterator(); iter.hasNext(); )
+            {
+                Resource o = (Resource) iter.next();
+                writeResource( o, "testResource", serializer );
+            }
+            serializer.endTag( NAMESPACE, "testResources" );
+        }
+        if ( buildBase.getDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "directory" ).text( buildBase.getDirectory() ).endTag( NAMESPACE, "directory" );
+        }
+        if ( buildBase.getFinalName() != null )
+        {
+            serializer.startTag( NAMESPACE, "finalName" ).text( buildBase.getFinalName() ).endTag( NAMESPACE, "finalName" );
+        }
+        if ( ( buildBase.getFilters() != null ) && ( buildBase.getFilters().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "filters" );
+            for ( Iterator iter = buildBase.getFilters().iterator(); iter.hasNext(); )
+            {
+                String filter = (String) iter.next();
+                serializer.startTag( NAMESPACE, "filter" ).text( filter ).endTag( NAMESPACE, "filter" );
+            }
+            serializer.endTag( NAMESPACE, "filters" );
+        }
+        if ( buildBase.getPluginManagement() != null )
+        {
+            writePluginManagement( (PluginManagement) buildBase.getPluginManagement(), "pluginManagement", serializer );
+        }
+        if ( ( buildBase.getPlugins() != null ) && ( buildBase.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = buildBase.getPlugins().iterator(); iter.hasNext(); )
+            {
+                Plugin o = (Plugin) iter.next();
+                writePlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeBuildBase( BuildBase, String, XmlSerializer )
+
+    /**
+     * Method writeCiManagement.
+     * 
+     * @param ciManagement
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeCiManagement( CiManagement ciManagement, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ciManagement.getSystem() != null )
+        {
+            serializer.startTag( NAMESPACE, "system" ).text( ciManagement.getSystem() ).endTag( NAMESPACE, "system" );
+        }
+        if ( ciManagement.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( ciManagement.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( ciManagement.getNotifiers() != null ) && ( ciManagement.getNotifiers().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "notifiers" );
+            for ( Iterator iter = ciManagement.getNotifiers().iterator(); iter.hasNext(); )
+            {
+                Notifier o = (Notifier) iter.next();
+                writeNotifier( o, "notifier", serializer );
+            }
+            serializer.endTag( NAMESPACE, "notifiers" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeCiManagement( CiManagement, String, XmlSerializer )
+
+    /**
+     * Method writeConfigurationContainer.
+     * 
+     * @param configurationContainer
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeConfigurationContainer( ConfigurationContainer configurationContainer, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( configurationContainer.getInherited() != null )
+        {
+            serializer.startTag( NAMESPACE, "inherited" ).text( configurationContainer.getInherited() ).endTag( NAMESPACE, "inherited" );
+        }
+        if ( configurationContainer.getConfiguration() != null )
+        {
+            ((Xpp3Dom) configurationContainer.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeConfigurationContainer( ConfigurationContainer, String, XmlSerializer )
+
+    /**
+     * Method writeContributor.
+     * 
+     * @param contributor
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeContributor( Contributor contributor, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( contributor.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( contributor.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( contributor.getEmail() != null )
+        {
+            serializer.startTag( NAMESPACE, "email" ).text( contributor.getEmail() ).endTag( NAMESPACE, "email" );
+        }
+        if ( contributor.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( contributor.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( contributor.getOrganization() != null )
+        {
+            serializer.startTag( NAMESPACE, "organization" ).text( contributor.getOrganization() ).endTag( NAMESPACE, "organization" );
+        }
+        if ( contributor.getOrganizationUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "organizationUrl" ).text( contributor.getOrganizationUrl() ).endTag( NAMESPACE, "organizationUrl" );
+        }
+        if ( ( contributor.getRoles() != null ) && ( contributor.getRoles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "roles" );
+            for ( Iterator iter = contributor.getRoles().iterator(); iter.hasNext(); )
+            {
+                String role = (String) iter.next();
+                serializer.startTag( NAMESPACE, "role" ).text( role ).endTag( NAMESPACE, "role" );
+            }
+            serializer.endTag( NAMESPACE, "roles" );
+        }
+        if ( contributor.getTimezone() != null )
+        {
+            serializer.startTag( NAMESPACE, "timezone" ).text( contributor.getTimezone() ).endTag( NAMESPACE, "timezone" );
+        }
+        if ( ( contributor.getProperties() != null ) && ( contributor.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = contributor.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) contributor.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeContributor( Contributor, String, XmlSerializer )
+
+    /**
+     * Method writeDependency.
+     * 
+     * @param dependency
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeDependency( Dependency dependency, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( dependency.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( dependency.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( dependency.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( dependency.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( dependency.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( dependency.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( ( dependency.getType() != null ) && !dependency.getType().equals( "jar" ) )
+        {
+            serializer.startTag( NAMESPACE, "type" ).text( dependency.getType() ).endTag( NAMESPACE, "type" );
+        }
+        if ( dependency.getClassifier() != null )
+        {
+            serializer.startTag( NAMESPACE, "classifier" ).text( dependency.getClassifier() ).endTag( NAMESPACE, "classifier" );
+        }
+        if ( dependency.getScope() != null )
+        {
+            serializer.startTag( NAMESPACE, "scope" ).text( dependency.getScope() ).endTag( NAMESPACE, "scope" );
+        }
+        if ( dependency.getSystemPath() != null )
+        {
+            serializer.startTag( NAMESPACE, "systemPath" ).text( dependency.getSystemPath() ).endTag( NAMESPACE, "systemPath" );
+        }
+        if ( ( dependency.getExclusions() != null ) && ( dependency.getExclusions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "exclusions" );
+            for ( Iterator iter = dependency.getExclusions().iterator(); iter.hasNext(); )
+            {
+                Exclusion o = (Exclusion) iter.next();
+                writeExclusion( o, "exclusion", serializer );
+            }
+            serializer.endTag( NAMESPACE, "exclusions" );
+        }
+        if ( dependency.getOptional() != null )
+        {
+            serializer.startTag( NAMESPACE, "optional" ).text( dependency.getOptional() ).endTag( NAMESPACE, "optional" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeDependency( Dependency, String, XmlSerializer )
+
+    /**
+     * Method writeDependencyManagement.
+     * 
+     * @param dependencyManagement
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeDependencyManagement( DependencyManagement dependencyManagement, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( dependencyManagement.getDependencies() != null ) && ( dependencyManagement.getDependencies().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "dependencies" );
+            for ( Iterator iter = dependencyManagement.getDependencies().iterator(); iter.hasNext(); )
+            {
+                Dependency o = (Dependency) iter.next();
+                writeDependency( o, "dependency", serializer );
+            }
+            serializer.endTag( NAMESPACE, "dependencies" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeDependencyManagement( DependencyManagement, String, XmlSerializer )
+
+    /**
+     * Method writeDeploymentRepository.
+     * 
+     * @param deploymentRepository
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeDeploymentRepository( DeploymentRepository deploymentRepository, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( deploymentRepository.isUniqueVersion() != true )
+        {
+            serializer.startTag( NAMESPACE, "uniqueVersion" ).text( String.valueOf( deploymentRepository.isUniqueVersion() ) ).endTag( NAMESPACE, "uniqueVersion" );
+        }
+        if ( deploymentRepository.getReleases() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) deploymentRepository.getReleases(), "releases", serializer );
+        }
+        if ( deploymentRepository.getSnapshots() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) deploymentRepository.getSnapshots(), "snapshots", serializer );
+        }
+        if ( deploymentRepository.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( deploymentRepository.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( deploymentRepository.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( deploymentRepository.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( deploymentRepository.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( deploymentRepository.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( deploymentRepository.getLayout() != null ) && !deploymentRepository.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( deploymentRepository.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeDeploymentRepository( DeploymentRepository, String, XmlSerializer )
+
+    /**
+     * Method writeDeveloper.
+     * 
+     * @param developer
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeDeveloper( Developer developer, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( developer.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( developer.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( developer.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( developer.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( developer.getEmail() != null )
+        {
+            serializer.startTag( NAMESPACE, "email" ).text( developer.getEmail() ).endTag( NAMESPACE, "email" );
+        }
+        if ( developer.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( developer.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( developer.getOrganization() != null )
+        {
+            serializer.startTag( NAMESPACE, "organization" ).text( developer.getOrganization() ).endTag( NAMESPACE, "organization" );
+        }
+        if ( developer.getOrganizationUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "organizationUrl" ).text( developer.getOrganizationUrl() ).endTag( NAMESPACE, "organizationUrl" );
+        }
+        if ( ( developer.getRoles() != null ) && ( developer.getRoles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "roles" );
+            for ( Iterator iter = developer.getRoles().iterator(); iter.hasNext(); )
+            {
+                String role = (String) iter.next();
+                serializer.startTag( NAMESPACE, "role" ).text( role ).endTag( NAMESPACE, "role" );
+            }
+            serializer.endTag( NAMESPACE, "roles" );
+        }
+        if ( developer.getTimezone() != null )
+        {
+            serializer.startTag( NAMESPACE, "timezone" ).text( developer.getTimezone() ).endTag( NAMESPACE, "timezone" );
+        }
+        if ( ( developer.getProperties() != null ) && ( developer.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = developer.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) developer.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeDeveloper( Developer, String, XmlSerializer )
+
+    /**
+     * Method writeDistributionManagement.
+     * 
+     * @param distributionManagement
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeDistributionManagement( DistributionManagement distributionManagement, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( distributionManagement.getRepository() != null )
+        {
+            writeDeploymentRepository( (DeploymentRepository) distributionManagement.getRepository(), "repository", serializer );
+        }
+        if ( distributionManagement.getSnapshotRepository() != null )
+        {
+            writeDeploymentRepository( (DeploymentRepository) distributionManagement.getSnapshotRepository(), "snapshotRepository", serializer );
+        }
+        if ( distributionManagement.getSite() != null )
+        {
+            writeSite( (Site) distributionManagement.getSite(), "site", serializer );
+        }
+        if ( distributionManagement.getDownloadUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "downloadUrl" ).text( distributionManagement.getDownloadUrl() ).endTag( NAMESPACE, "downloadUrl" );
+        }
+        if ( distributionManagement.getRelocation() != null )
+        {
+            writeRelocation( (Relocation) distributionManagement.getRelocation(), "relocation", serializer );
+        }
+        if ( distributionManagement.getStatus() != null )
+        {
+            serializer.startTag( NAMESPACE, "status" ).text( distributionManagement.getStatus() ).endTag( NAMESPACE, "status" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeDistributionManagement( DistributionManagement, String, XmlSerializer )
+
+    /**
+     * Method writeExclusion.
+     * 
+     * @param exclusion
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeExclusion( Exclusion exclusion, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( exclusion.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( exclusion.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( exclusion.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( exclusion.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeExclusion( Exclusion, String, XmlSerializer )
+
+    /**
+     * Method writeExtension.
+     * 
+     * @param extension
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeExtension( Extension extension, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( extension.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( extension.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( extension.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( extension.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( extension.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( extension.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeExtension( Extension, String, XmlSerializer )
+
+    /**
+     * Method writeFileSet.
+     * 
+     * @param fileSet
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeFileSet( FileSet fileSet, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( fileSet.getDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "directory" ).text( fileSet.getDirectory() ).endTag( NAMESPACE, "directory" );
+        }
+        if ( ( fileSet.getIncludes() != null ) && ( fileSet.getIncludes().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "includes" );
+            for ( Iterator iter = fileSet.getIncludes().iterator(); iter.hasNext(); )
+            {
+                String include = (String) iter.next();
+                serializer.startTag( NAMESPACE, "include" ).text( include ).endTag( NAMESPACE, "include" );
+            }
+            serializer.endTag( NAMESPACE, "includes" );
+        }
+        if ( ( fileSet.getExcludes() != null ) && ( fileSet.getExcludes().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "excludes" );
+            for ( Iterator iter = fileSet.getExcludes().iterator(); iter.hasNext(); )
+            {
+                String exclude = (String) iter.next();
+                serializer.startTag( NAMESPACE, "exclude" ).text( exclude ).endTag( NAMESPACE, "exclude" );
+            }
+            serializer.endTag( NAMESPACE, "excludes" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeFileSet( FileSet, String, XmlSerializer )
+
+    /**
+     * Method writeIssueManagement.
+     * 
+     * @param issueManagement
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeIssueManagement( IssueManagement issueManagement, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( issueManagement.getSystem() != null )
+        {
+            serializer.startTag( NAMESPACE, "system" ).text( issueManagement.getSystem() ).endTag( NAMESPACE, "system" );
+        }
+        if ( issueManagement.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( issueManagement.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeIssueManagement( IssueManagement, String, XmlSerializer )
+
+    /**
+     * Method writeLicense.
+     * 
+     * @param license
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeLicense( License license, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( license.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( license.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( license.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( license.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( license.getDistribution() != null )
+        {
+            serializer.startTag( NAMESPACE, "distribution" ).text( license.getDistribution() ).endTag( NAMESPACE, "distribution" );
+        }
+        if ( license.getComments() != null )
+        {
+            serializer.startTag( NAMESPACE, "comments" ).text( license.getComments() ).endTag( NAMESPACE, "comments" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeLicense( License, String, XmlSerializer )
+
+    /**
+     * Method writeMailingList.
+     * 
+     * @param mailingList
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeMailingList( MailingList mailingList, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( mailingList.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( mailingList.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( mailingList.getSubscribe() != null )
+        {
+            serializer.startTag( NAMESPACE, "subscribe" ).text( mailingList.getSubscribe() ).endTag( NAMESPACE, "subscribe" );
+        }
+        if ( mailingList.getUnsubscribe() != null )
+        {
+            serializer.startTag( NAMESPACE, "unsubscribe" ).text( mailingList.getUnsubscribe() ).endTag( NAMESPACE, "unsubscribe" );
+        }
+        if ( mailingList.getPost() != null )
+        {
+            serializer.startTag( NAMESPACE, "post" ).text( mailingList.getPost() ).endTag( NAMESPACE, "post" );
+        }
+        if ( mailingList.getArchive() != null )
+        {
+            serializer.startTag( NAMESPACE, "archive" ).text( mailingList.getArchive() ).endTag( NAMESPACE, "archive" );
+        }
+        if ( ( mailingList.getOtherArchives() != null ) && ( mailingList.getOtherArchives().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "otherArchives" );
+            for ( Iterator iter = mailingList.getOtherArchives().iterator(); iter.hasNext(); )
+            {
+                String otherArchive = (String) iter.next();
+                serializer.startTag( NAMESPACE, "otherArchive" ).text( otherArchive ).endTag( NAMESPACE, "otherArchive" );
+            }
+            serializer.endTag( NAMESPACE, "otherArchives" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeMailingList( MailingList, String, XmlSerializer )
+
+    /**
+     * Method writeModel.
+     * 
+     * @param model
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeModel( Model model, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/POM/4.0.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" );
+        if ( model.getModelVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "modelVersion" ).text( model.getModelVersion() ).endTag( NAMESPACE, "modelVersion" );
+        }
+        if ( model.getParent() != null )
+        {
+            writeParent( (Parent) model.getParent(), "parent", serializer );
+        }
+        if ( model.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( model.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( model.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( model.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( model.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( model.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( ( model.getPackaging() != null ) && !model.getPackaging().equals( "jar" ) )
+        {
+            serializer.startTag( NAMESPACE, "packaging" ).text( model.getPackaging() ).endTag( NAMESPACE, "packaging" );
+        }
+        if ( model.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( model.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( model.getDescription() != null )
+        {
+            serializer.startTag( NAMESPACE, "description" ).text( model.getDescription() ).endTag( NAMESPACE, "description" );
+        }
+        if ( model.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( model.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( model.getInceptionYear() != null )
+        {
+            serializer.startTag( NAMESPACE, "inceptionYear" ).text( model.getInceptionYear() ).endTag( NAMESPACE, "inceptionYear" );
+        }
+        if ( model.getOrganization() != null )
+        {
+            writeOrganization( (Organization) model.getOrganization(), "organization", serializer );
+        }
+        if ( ( model.getLicenses() != null ) && ( model.getLicenses().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "licenses" );
+            for ( Iterator iter = model.getLicenses().iterator(); iter.hasNext(); )
+            {
+                License o = (License) iter.next();
+                writeLicense( o, "license", serializer );
+            }
+            serializer.endTag( NAMESPACE, "licenses" );
+        }
+        if ( ( model.getDevelopers() != null ) && ( model.getDevelopers().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "developers" );
+            for ( Iterator iter = model.getDevelopers().iterator(); iter.hasNext(); )
+            {
+                Developer o = (Developer) iter.next();
+                writeDeveloper( o, "developer", serializer );
+            }
+            serializer.endTag( NAMESPACE, "developers" );
+        }
+        if ( ( model.getContributors() != null ) && ( model.getContributors().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "contributors" );
+            for ( Iterator iter = model.getContributors().iterator(); iter.hasNext(); )
+            {
+                Contributor o = (Contributor) iter.next();
+                writeContributor( o, "contributor", serializer );
+            }
+            serializer.endTag( NAMESPACE, "contributors" );
+        }
+        if ( ( model.getMailingLists() != null ) && ( model.getMailingLists().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "mailingLists" );
+            for ( Iterator iter = model.getMailingLists().iterator(); iter.hasNext(); )
+            {
+                MailingList o = (MailingList) iter.next();
+                writeMailingList( o, "mailingList", serializer );
+            }
+            serializer.endTag( NAMESPACE, "mailingLists" );
+        }
+        if ( model.getPrerequisites() != null )
+        {
+            writePrerequisites( (Prerequisites) model.getPrerequisites(), "prerequisites", serializer );
+        }
+        if ( ( model.getModules() != null ) && ( model.getModules().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "modules" );
+            for ( Iterator iter = model.getModules().iterator(); iter.hasNext(); )
+            {
+                String module = (String) iter.next();
+                serializer.startTag( NAMESPACE, "module" ).text( module ).endTag( NAMESPACE, "module" );
+            }
+            serializer.endTag( NAMESPACE, "modules" );
+        }
+        if ( model.getScm() != null )
+        {
+            writeScm( (Scm) model.getScm(), "scm", serializer );
+        }
+        if ( model.getIssueManagement() != null )
+        {
+            writeIssueManagement( (IssueManagement) model.getIssueManagement(), "issueManagement", serializer );
+        }
+        if ( model.getCiManagement() != null )
+        {
+            writeCiManagement( (CiManagement) model.getCiManagement(), "ciManagement", serializer );
+        }
+        if ( model.getDistributionManagement() != null )
+        {
+            writeDistributionManagement( (DistributionManagement) model.getDistributionManagement(), "distributionManagement", serializer );
+        }
+        if ( ( model.getProperties() != null ) && ( model.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = model.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) model.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        if ( model.getDependencyManagement() != null )
+        {
+            writeDependencyManagement( (DependencyManagement) model.getDependencyManagement(), "dependencyManagement", serializer );
+        }
+        if ( ( model.getDependencies() != null ) && ( model.getDependencies().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "dependencies" );
+            for ( Iterator iter = model.getDependencies().iterator(); iter.hasNext(); )
+            {
+                Dependency o = (Dependency) iter.next();
+                writeDependency( o, "dependency", serializer );
+            }
+            serializer.endTag( NAMESPACE, "dependencies" );
+        }
+        if ( ( model.getRepositories() != null ) && ( model.getRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "repositories" );
+            for ( Iterator iter = model.getRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "repository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "repositories" );
+        }
+        if ( ( model.getPluginRepositories() != null ) && ( model.getPluginRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "pluginRepositories" );
+            for ( Iterator iter = model.getPluginRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "pluginRepository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "pluginRepositories" );
+        }
+        if ( model.getBuild() != null )
+        {
+            writeBuild( (Build) model.getBuild(), "build", serializer );
+        }
+        if ( model.getReports() != null )
+        {
+            ((Xpp3Dom) model.getReports()).writeToSerializer( NAMESPACE, serializer );
+        }
+        if ( model.getReporting() != null )
+        {
+            writeReporting( (Reporting) model.getReporting(), "reporting", serializer );
+        }
+        if ( ( model.getProfiles() != null ) && ( model.getProfiles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "profiles" );
+            for ( Iterator iter = model.getProfiles().iterator(); iter.hasNext(); )
+            {
+                Profile o = (Profile) iter.next();
+                writeProfile( o, "profile", serializer );
+            }
+            serializer.endTag( NAMESPACE, "profiles" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeModel( Model, String, XmlSerializer )
+
+    /**
+     * Method writeModelBase.
+     * 
+     * @param modelBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeModelBase( ModelBase modelBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( modelBase.getModules() != null ) && ( modelBase.getModules().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "modules" );
+            for ( Iterator iter = modelBase.getModules().iterator(); iter.hasNext(); )
+            {
+                String module = (String) iter.next();
+                serializer.startTag( NAMESPACE, "module" ).text( module ).endTag( NAMESPACE, "module" );
+            }
+            serializer.endTag( NAMESPACE, "modules" );
+        }
+        if ( modelBase.getDistributionManagement() != null )
+        {
+            writeDistributionManagement( (DistributionManagement) modelBase.getDistributionManagement(), "distributionManagement", serializer );
+        }
+        if ( ( modelBase.getProperties() != null ) && ( modelBase.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = modelBase.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) modelBase.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        if ( modelBase.getDependencyManagement() != null )
+        {
+            writeDependencyManagement( (DependencyManagement) modelBase.getDependencyManagement(), "dependencyManagement", serializer );
+        }
+        if ( ( modelBase.getDependencies() != null ) && ( modelBase.getDependencies().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "dependencies" );
+            for ( Iterator iter = modelBase.getDependencies().iterator(); iter.hasNext(); )
+            {
+                Dependency o = (Dependency) iter.next();
+                writeDependency( o, "dependency", serializer );
+            }
+            serializer.endTag( NAMESPACE, "dependencies" );
+        }
+        if ( ( modelBase.getRepositories() != null ) && ( modelBase.getRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "repositories" );
+            for ( Iterator iter = modelBase.getRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "repository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "repositories" );
+        }
+        if ( ( modelBase.getPluginRepositories() != null ) && ( modelBase.getPluginRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "pluginRepositories" );
+            for ( Iterator iter = modelBase.getPluginRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "pluginRepository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "pluginRepositories" );
+        }
+        if ( modelBase.getReports() != null )
+        {
+            ((Xpp3Dom) modelBase.getReports()).writeToSerializer( NAMESPACE, serializer );
+        }
+        if ( modelBase.getReporting() != null )
+        {
+            writeReporting( (Reporting) modelBase.getReporting(), "reporting", serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeModelBase( ModelBase, String, XmlSerializer )
+
+    /**
+     * Method writeNotifier.
+     * 
+     * @param notifier
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeNotifier( Notifier notifier, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( notifier.getType() != null ) && !notifier.getType().equals( "mail" ) )
+        {
+            serializer.startTag( NAMESPACE, "type" ).text( notifier.getType() ).endTag( NAMESPACE, "type" );
+        }
+        if ( notifier.isSendOnError() != true )
+        {
+            serializer.startTag( NAMESPACE, "sendOnError" ).text( String.valueOf( notifier.isSendOnError() ) ).endTag( NAMESPACE, "sendOnError" );
+        }
+        if ( notifier.isSendOnFailure() != true )
+        {
+            serializer.startTag( NAMESPACE, "sendOnFailure" ).text( String.valueOf( notifier.isSendOnFailure() ) ).endTag( NAMESPACE, "sendOnFailure" );
+        }
+        if ( notifier.isSendOnSuccess() != true )
+        {
+            serializer.startTag( NAMESPACE, "sendOnSuccess" ).text( String.valueOf( notifier.isSendOnSuccess() ) ).endTag( NAMESPACE, "sendOnSuccess" );
+        }
+        if ( notifier.isSendOnWarning() != true )
+        {
+            serializer.startTag( NAMESPACE, "sendOnWarning" ).text( String.valueOf( notifier.isSendOnWarning() ) ).endTag( NAMESPACE, "sendOnWarning" );
+        }
+        if ( notifier.getAddress() != null )
+        {
+            serializer.startTag( NAMESPACE, "address" ).text( notifier.getAddress() ).endTag( NAMESPACE, "address" );
+        }
+        if ( ( notifier.getConfiguration() != null ) && ( notifier.getConfiguration().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "configuration" );
+            for ( Iterator iter = notifier.getConfiguration().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) notifier.getConfiguration().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "configuration" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeNotifier( Notifier, String, XmlSerializer )
+
+    /**
+     * Method writeOrganization.
+     * 
+     * @param organization
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeOrganization( Organization organization, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( organization.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( organization.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( organization.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( organization.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeOrganization( Organization, String, XmlSerializer )
+
+    /**
+     * Method writeParent.
+     * 
+     * @param parent
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeParent( Parent parent, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( parent.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( parent.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( parent.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( parent.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( parent.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( parent.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( ( parent.getRelativePath() != null ) && !parent.getRelativePath().equals( "../pom.xml" ) )
+        {
+            serializer.startTag( NAMESPACE, "relativePath" ).text( parent.getRelativePath() ).endTag( NAMESPACE, "relativePath" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeParent( Parent, String, XmlSerializer )
+
+    /**
+     * Method writePatternSet.
+     * 
+     * @param patternSet
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePatternSet( PatternSet patternSet, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( patternSet.getIncludes() != null ) && ( patternSet.getIncludes().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "includes" );
+            for ( Iterator iter = patternSet.getIncludes().iterator(); iter.hasNext(); )
+            {
+                String include = (String) iter.next();
+                serializer.startTag( NAMESPACE, "include" ).text( include ).endTag( NAMESPACE, "include" );
+            }
+            serializer.endTag( NAMESPACE, "includes" );
+        }
+        if ( ( patternSet.getExcludes() != null ) && ( patternSet.getExcludes().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "excludes" );
+            for ( Iterator iter = patternSet.getExcludes().iterator(); iter.hasNext(); )
+            {
+                String exclude = (String) iter.next();
+                serializer.startTag( NAMESPACE, "exclude" ).text( exclude ).endTag( NAMESPACE, "exclude" );
+            }
+            serializer.endTag( NAMESPACE, "excludes" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePatternSet( PatternSet, String, XmlSerializer )
+
+    /**
+     * Method writePlugin.
+     * 
+     * @param plugin
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePlugin( Plugin plugin, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( plugin.getGroupId() != null ) && !plugin.getGroupId().equals( "org.apache.maven.plugins" ) )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( plugin.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( plugin.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( plugin.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( plugin.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( plugin.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( plugin.getExtensions() != null )
+        {
+            serializer.startTag( NAMESPACE, "extensions" ).text( plugin.getExtensions() ).endTag( NAMESPACE, "extensions" );
+        }
+        if ( ( plugin.getExecutions() != null ) && ( plugin.getExecutions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "executions" );
+            for ( Iterator iter = plugin.getExecutions().iterator(); iter.hasNext(); )
+            {
+                PluginExecution o = (PluginExecution) iter.next();
+                writePluginExecution( o, "execution", serializer );
+            }
+            serializer.endTag( NAMESPACE, "executions" );
+        }
+        if ( ( plugin.getDependencies() != null ) && ( plugin.getDependencies().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "dependencies" );
+            for ( Iterator iter = plugin.getDependencies().iterator(); iter.hasNext(); )
+            {
+                Dependency o = (Dependency) iter.next();
+                writeDependency( o, "dependency", serializer );
+            }
+            serializer.endTag( NAMESPACE, "dependencies" );
+        }
+        if ( plugin.getGoals() != null )
+        {
+            ((Xpp3Dom) plugin.getGoals()).writeToSerializer( NAMESPACE, serializer );
+        }
+        if ( plugin.getInherited() != null )
+        {
+            serializer.startTag( NAMESPACE, "inherited" ).text( plugin.getInherited() ).endTag( NAMESPACE, "inherited" );
+        }
+        if ( plugin.getConfiguration() != null )
+        {
+            ((Xpp3Dom) plugin.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePlugin( Plugin, String, XmlSerializer )
+
+    /**
+     * Method writePluginConfiguration.
+     * 
+     * @param pluginConfiguration
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePluginConfiguration( PluginConfiguration pluginConfiguration, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( pluginConfiguration.getPluginManagement() != null )
+        {
+            writePluginManagement( (PluginManagement) pluginConfiguration.getPluginManagement(), "pluginManagement", serializer );
+        }
+        if ( ( pluginConfiguration.getPlugins() != null ) && ( pluginConfiguration.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = pluginConfiguration.getPlugins().iterator(); iter.hasNext(); )
+            {
+                Plugin o = (Plugin) iter.next();
+                writePlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePluginConfiguration( PluginConfiguration, String, XmlSerializer )
+
+    /**
+     * Method writePluginContainer.
+     * 
+     * @param pluginContainer
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePluginContainer( PluginContainer pluginContainer, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( pluginContainer.getPlugins() != null ) && ( pluginContainer.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = pluginContainer.getPlugins().iterator(); iter.hasNext(); )
+            {
+                Plugin o = (Plugin) iter.next();
+                writePlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePluginContainer( PluginContainer, String, XmlSerializer )
+
+    /**
+     * Method writePluginExecution.
+     * 
+     * @param pluginExecution
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePluginExecution( PluginExecution pluginExecution, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( pluginExecution.getId() != null ) && !pluginExecution.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( pluginExecution.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( pluginExecution.getPhase() != null )
+        {
+            serializer.startTag( NAMESPACE, "phase" ).text( pluginExecution.getPhase() ).endTag( NAMESPACE, "phase" );
+        }
+        if ( ( pluginExecution.getGoals() != null ) && ( pluginExecution.getGoals().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "goals" );
+            for ( Iterator iter = pluginExecution.getGoals().iterator(); iter.hasNext(); )
+            {
+                String goal = (String) iter.next();
+                serializer.startTag( NAMESPACE, "goal" ).text( goal ).endTag( NAMESPACE, "goal" );
+            }
+            serializer.endTag( NAMESPACE, "goals" );
+        }
+        if ( pluginExecution.getInherited() != null )
+        {
+            serializer.startTag( NAMESPACE, "inherited" ).text( pluginExecution.getInherited() ).endTag( NAMESPACE, "inherited" );
+        }
+        if ( pluginExecution.getConfiguration() != null )
+        {
+            ((Xpp3Dom) pluginExecution.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePluginExecution( PluginExecution, String, XmlSerializer )
+
+    /**
+     * Method writePluginManagement.
+     * 
+     * @param pluginManagement
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePluginManagement( PluginManagement pluginManagement, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( pluginManagement.getPlugins() != null ) && ( pluginManagement.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = pluginManagement.getPlugins().iterator(); iter.hasNext(); )
+            {
+                Plugin o = (Plugin) iter.next();
+                writePlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePluginManagement( PluginManagement, String, XmlSerializer )
+
+    /**
+     * Method writePrerequisites.
+     * 
+     * @param prerequisites
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePrerequisites( Prerequisites prerequisites, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( prerequisites.getMaven() != null ) && !prerequisites.getMaven().equals( "2.0" ) )
+        {
+            serializer.startTag( NAMESPACE, "maven" ).text( prerequisites.getMaven() ).endTag( NAMESPACE, "maven" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePrerequisites( Prerequisites, String, XmlSerializer )
+
+    /**
+     * Method writeProfile.
+     * 
+     * @param profile
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeProfile( Profile profile, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( profile.getId() != null ) && !profile.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( profile.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( profile.getActivation() != null )
+        {
+            writeActivation( (Activation) profile.getActivation(), "activation", serializer );
+        }
+        if ( profile.getBuild() != null )
+        {
+            writeBuildBase( (BuildBase) profile.getBuild(), "build", serializer );
+        }
+        if ( ( profile.getModules() != null ) && ( profile.getModules().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "modules" );
+            for ( Iterator iter = profile.getModules().iterator(); iter.hasNext(); )
+            {
+                String module = (String) iter.next();
+                serializer.startTag( NAMESPACE, "module" ).text( module ).endTag( NAMESPACE, "module" );
+            }
+            serializer.endTag( NAMESPACE, "modules" );
+        }
+        if ( profile.getDistributionManagement() != null )
+        {
+            writeDistributionManagement( (DistributionManagement) profile.getDistributionManagement(), "distributionManagement", serializer );
+        }
+        if ( ( profile.getProperties() != null ) && ( profile.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = profile.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) profile.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        if ( profile.getDependencyManagement() != null )
+        {
+            writeDependencyManagement( (DependencyManagement) profile.getDependencyManagement(), "dependencyManagement", serializer );
+        }
+        if ( ( profile.getDependencies() != null ) && ( profile.getDependencies().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "dependencies" );
+            for ( Iterator iter = profile.getDependencies().iterator(); iter.hasNext(); )
+            {
+                Dependency o = (Dependency) iter.next();
+                writeDependency( o, "dependency", serializer );
+            }
+            serializer.endTag( NAMESPACE, "dependencies" );
+        }
+        if ( ( profile.getRepositories() != null ) && ( profile.getRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "repositories" );
+            for ( Iterator iter = profile.getRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "repository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "repositories" );
+        }
+        if ( ( profile.getPluginRepositories() != null ) && ( profile.getPluginRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "pluginRepositories" );
+            for ( Iterator iter = profile.getPluginRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "pluginRepository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "pluginRepositories" );
+        }
+        if ( profile.getReports() != null )
+        {
+            ((Xpp3Dom) profile.getReports()).writeToSerializer( NAMESPACE, serializer );
+        }
+        if ( profile.getReporting() != null )
+        {
+            writeReporting( (Reporting) profile.getReporting(), "reporting", serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeProfile( Profile, String, XmlSerializer )
+
+    /**
+     * Method writeRelocation.
+     * 
+     * @param relocation
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRelocation( Relocation relocation, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( relocation.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( relocation.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( relocation.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( relocation.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( relocation.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( relocation.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( relocation.getMessage() != null )
+        {
+            serializer.startTag( NAMESPACE, "message" ).text( relocation.getMessage() ).endTag( NAMESPACE, "message" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRelocation( Relocation, String, XmlSerializer )
+
+    /**
+     * Method writeReportPlugin.
+     * 
+     * @param reportPlugin
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeReportPlugin( ReportPlugin reportPlugin, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( reportPlugin.getGroupId() != null ) && !reportPlugin.getGroupId().equals( "org.apache.maven.plugins" ) )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( reportPlugin.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( reportPlugin.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( reportPlugin.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( reportPlugin.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( reportPlugin.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( ( reportPlugin.getReportSets() != null ) && ( reportPlugin.getReportSets().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "reportSets" );
+            for ( Iterator iter = reportPlugin.getReportSets().iterator(); iter.hasNext(); )
+            {
+                ReportSet o = (ReportSet) iter.next();
+                writeReportSet( o, "reportSet", serializer );
+            }
+            serializer.endTag( NAMESPACE, "reportSets" );
+        }
+        if ( reportPlugin.getInherited() != null )
+        {
+            serializer.startTag( NAMESPACE, "inherited" ).text( reportPlugin.getInherited() ).endTag( NAMESPACE, "inherited" );
+        }
+        if ( reportPlugin.getConfiguration() != null )
+        {
+            ((Xpp3Dom) reportPlugin.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeReportPlugin( ReportPlugin, String, XmlSerializer )
+
+    /**
+     * Method writeReportSet.
+     * 
+     * @param reportSet
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeReportSet( ReportSet reportSet, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( reportSet.getId() != null ) && !reportSet.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( reportSet.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( ( reportSet.getReports() != null ) && ( reportSet.getReports().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "reports" );
+            for ( Iterator iter = reportSet.getReports().iterator(); iter.hasNext(); )
+            {
+                String report = (String) iter.next();
+                serializer.startTag( NAMESPACE, "report" ).text( report ).endTag( NAMESPACE, "report" );
+            }
+            serializer.endTag( NAMESPACE, "reports" );
+        }
+        if ( reportSet.getInherited() != null )
+        {
+            serializer.startTag( NAMESPACE, "inherited" ).text( reportSet.getInherited() ).endTag( NAMESPACE, "inherited" );
+        }
+        if ( reportSet.getConfiguration() != null )
+        {
+            ((Xpp3Dom) reportSet.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeReportSet( ReportSet, String, XmlSerializer )
+
+    /**
+     * Method writeReporting.
+     * 
+     * @param reporting
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeReporting( Reporting reporting, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( reporting.getExcludeDefaults() != null )
+        {
+            serializer.startTag( NAMESPACE, "excludeDefaults" ).text( reporting.getExcludeDefaults() ).endTag( NAMESPACE, "excludeDefaults" );
+        }
+        if ( reporting.getOutputDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "outputDirectory" ).text( reporting.getOutputDirectory() ).endTag( NAMESPACE, "outputDirectory" );
+        }
+        if ( ( reporting.getPlugins() != null ) && ( reporting.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = reporting.getPlugins().iterator(); iter.hasNext(); )
+            {
+                ReportPlugin o = (ReportPlugin) iter.next();
+                writeReportPlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeReporting( Reporting, String, XmlSerializer )
+
+    /**
+     * Method writeRepository.
+     * 
+     * @param repository
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepository( Repository repository, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repository.getReleases() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) repository.getReleases(), "releases", serializer );
+        }
+        if ( repository.getSnapshots() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) repository.getSnapshots(), "snapshots", serializer );
+        }
+        if ( repository.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( repository.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( repository.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( repository.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( repository.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( repository.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( repository.getLayout() != null ) && !repository.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( repository.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepository( Repository, String, XmlSerializer )
+
+    /**
+     * Method writeRepositoryBase.
+     * 
+     * @param repositoryBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepositoryBase( RepositoryBase repositoryBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repositoryBase.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( repositoryBase.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( repositoryBase.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( repositoryBase.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( repositoryBase.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( repositoryBase.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( repositoryBase.getLayout() != null ) && !repositoryBase.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( repositoryBase.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepositoryBase( RepositoryBase, String, XmlSerializer )
+
+    /**
+     * Method writeRepositoryPolicy.
+     * 
+     * @param repositoryPolicy
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepositoryPolicy( RepositoryPolicy repositoryPolicy, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repositoryPolicy.getEnabled() != null )
+        {
+            serializer.startTag( NAMESPACE, "enabled" ).text( repositoryPolicy.getEnabled() ).endTag( NAMESPACE, "enabled" );
+        }
+        if ( repositoryPolicy.getUpdatePolicy() != null )
+        {
+            serializer.startTag( NAMESPACE, "updatePolicy" ).text( repositoryPolicy.getUpdatePolicy() ).endTag( NAMESPACE, "updatePolicy" );
+        }
+        if ( repositoryPolicy.getChecksumPolicy() != null )
+        {
+            serializer.startTag( NAMESPACE, "checksumPolicy" ).text( repositoryPolicy.getChecksumPolicy() ).endTag( NAMESPACE, "checksumPolicy" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepositoryPolicy( RepositoryPolicy, String, XmlSerializer )
+
+    /**
+     * Method writeResource.
+     * 
+     * @param resource
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeResource( Resource resource, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( resource.getTargetPath() != null )
+        {
+            serializer.startTag( NAMESPACE, "targetPath" ).text( resource.getTargetPath() ).endTag( NAMESPACE, "targetPath" );
+        }
+        if ( resource.getFiltering() != null )
+        {
+            serializer.startTag( NAMESPACE, "filtering" ).text( resource.getFiltering() ).endTag( NAMESPACE, "filtering" );
+        }
+        if ( resource.getDirectory() != null )
+        {
+            serializer.startTag( NAMESPACE, "directory" ).text( resource.getDirectory() ).endTag( NAMESPACE, "directory" );
+        }
+        if ( ( resource.getIncludes() != null ) && ( resource.getIncludes().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "includes" );
+            for ( Iterator iter = resource.getIncludes().iterator(); iter.hasNext(); )
+            {
+                String include = (String) iter.next();
+                serializer.startTag( NAMESPACE, "include" ).text( include ).endTag( NAMESPACE, "include" );
+            }
+            serializer.endTag( NAMESPACE, "includes" );
+        }
+        if ( ( resource.getExcludes() != null ) && ( resource.getExcludes().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "excludes" );
+            for ( Iterator iter = resource.getExcludes().iterator(); iter.hasNext(); )
+            {
+                String exclude = (String) iter.next();
+                serializer.startTag( NAMESPACE, "exclude" ).text( exclude ).endTag( NAMESPACE, "exclude" );
+            }
+            serializer.endTag( NAMESPACE, "excludes" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeResource( Resource, String, XmlSerializer )
+
+    /**
+     * Method writeScm.
+     * 
+     * @param scm
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeScm( Scm scm, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( scm.getConnection() != null )
+        {
+            serializer.startTag( NAMESPACE, "connection" ).text( scm.getConnection() ).endTag( NAMESPACE, "connection" );
+        }
+        if ( scm.getDeveloperConnection() != null )
+        {
+            serializer.startTag( NAMESPACE, "developerConnection" ).text( scm.getDeveloperConnection() ).endTag( NAMESPACE, "developerConnection" );
+        }
+        if ( ( scm.getTag() != null ) && !scm.getTag().equals( "HEAD" ) )
+        {
+            serializer.startTag( NAMESPACE, "tag" ).text( scm.getTag() ).endTag( NAMESPACE, "tag" );
+        }
+        if ( scm.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( scm.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeScm( Scm, String, XmlSerializer )
+
+    /**
+     * Method writeSite.
+     * 
+     * @param site
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeSite( Site site, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( site.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( site.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( site.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( site.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( site.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( site.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeSite( Site, String, XmlSerializer )
+
+}
diff --git a/maven-plugin-api/pom.xml b/maven-plugin-api/pom.xml
index a35ad93..269fd48 100644
--- a/maven-plugin-api/pom.xml
+++ b/maven-plugin-api/pom.xml
@@ -57,25 +57,20 @@ under the License.
   <build>
     <plugins>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <models>
-            <model>src/main/mdo/lifecycle.mdo</model>
-          </models>
-          <version>1.0.0</version>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
         <executions>
           <execution>
-            <id>plugin-site-doc</id>
-            <phase>pre-site</phase>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
             <goals>
-              <goal>xdoc</goal>
+              <goal>add-source</goal>
             </goals>
             <configuration>
-              <models>
-                <model>src/main/mdo/plugin.mdo</model>
-              </models>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
             </configuration>
           </execution>
         </executions>
diff --git a/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Execution.java b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Execution.java
new file mode 100644
index 0000000..04e2c27
--- /dev/null
+++ b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Execution.java
@@ -0,0 +1,102 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.plugin.lifecycle;
+
+/**
+ * A set of goals to execute.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Execution
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Configuration to pass to the goals.
+     */
+    private Object configuration;
+
+    /**
+     * Field goals.
+     */
+    private java.util.List<String> goals;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addGoal.
+     * 
+     * @param string
+     */
+    public void addGoal( String string )
+    {
+        getGoals().add( string );
+    } //-- void addGoal( String )
+
+    /**
+     * Get configuration to pass to the goals.
+     * 
+     * @return Object
+     */
+    public Object getConfiguration()
+    {
+        return this.configuration;
+    } //-- Object getConfiguration()
+
+    /**
+     * Method getGoals.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getGoals()
+    {
+        if ( this.goals == null )
+        {
+            this.goals = new java.util.ArrayList<String>();
+        }
+
+        return this.goals;
+    } //-- java.util.List<String> getGoals()
+
+    /**
+     * Method removeGoal.
+     * 
+     * @param string
+     */
+    public void removeGoal( String string )
+    {
+        getGoals().remove( string );
+    } //-- void removeGoal( String )
+
+    /**
+     * Set configuration to pass to the goals.
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( Object configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( Object )
+
+    /**
+     * Set the goals to execute.
+     * 
+     * @param goals
+     */
+    public void setGoals( java.util.List<String> goals )
+    {
+        this.goals = goals;
+    } //-- void setGoals( java.util.List )
+
+}
diff --git a/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Lifecycle.java b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Lifecycle.java
new file mode 100644
index 0000000..88ee734
--- /dev/null
+++ b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Lifecycle.java
@@ -0,0 +1,107 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.plugin.lifecycle;
+
+/**
+ * 
+ *         A custom lifecycle mapping definition.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Lifecycle
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The ID of this lifecycle, for identification in the mojo
+     * descriptor.
+     */
+    private String id;
+
+    /**
+     * Field phases.
+     */
+    private java.util.List<Phase> phases;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addPhase.
+     * 
+     * @param phase
+     */
+    public void addPhase( Phase phase )
+    {
+        getPhases().add( phase );
+    } //-- void addPhase( Phase )
+
+    /**
+     * Get the ID of this lifecycle, for identification in the mojo
+     * descriptor.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Method getPhases.
+     * 
+     * @return List
+     */
+    public java.util.List<Phase> getPhases()
+    {
+        if ( this.phases == null )
+        {
+            this.phases = new java.util.ArrayList<Phase>();
+        }
+
+        return this.phases;
+    } //-- java.util.List<Phase> getPhases()
+
+    /**
+     * Method removePhase.
+     * 
+     * @param phase
+     */
+    public void removePhase( Phase phase )
+    {
+        getPhases().remove( phase );
+    } //-- void removePhase( Phase )
+
+    /**
+     * Set the ID of this lifecycle, for identification in the mojo
+     * descriptor.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the phase mappings for this lifecycle.
+     * 
+     * @param phases
+     */
+    public void setPhases( java.util.List<Phase> phases )
+    {
+        this.phases = phases;
+    } //-- void setPhases( java.util.List )
+
+}
diff --git a/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java
new file mode 100644
index 0000000..ed0ec1d
--- /dev/null
+++ b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java
@@ -0,0 +1,102 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.plugin.lifecycle;
+
+/**
+ * Root element of the <code>lifecycle.xml</code> file.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class LifecycleConfiguration
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field lifecycles.
+     */
+    private java.util.List<Lifecycle> lifecycles;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addLifecycle.
+     * 
+     * @param lifecycle
+     */
+    public void addLifecycle( Lifecycle lifecycle )
+    {
+        getLifecycles().add( lifecycle );
+    } //-- void addLifecycle( Lifecycle )
+
+    /**
+     * Method getLifecycles.
+     * 
+     * @return List
+     */
+    public java.util.List<Lifecycle> getLifecycles()
+    {
+        if ( this.lifecycles == null )
+        {
+            this.lifecycles = new java.util.ArrayList<Lifecycle>();
+        }
+
+        return this.lifecycles;
+    } //-- java.util.List<Lifecycle> getLifecycles()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method removeLifecycle.
+     * 
+     * @param lifecycle
+     */
+    public void removeLifecycle( Lifecycle lifecycle )
+    {
+        getLifecycles().remove( lifecycle );
+    } //-- void removeLifecycle( Lifecycle )
+
+    /**
+     * Set the lifecycles field.
+     * 
+     * @param lifecycles
+     */
+    public void setLifecycles( java.util.List<Lifecycle> lifecycles )
+    {
+        this.lifecycles = lifecycles;
+    } //-- void setLifecycles( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+}
diff --git a/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Phase.java b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Phase.java
new file mode 100644
index 0000000..bcacc06
--- /dev/null
+++ b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/Phase.java
@@ -0,0 +1,127 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.plugin.lifecycle;
+
+/**
+ * A phase mapping definition.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Phase
+    implements java.io.Serializable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The ID of this phase, eg <code>generate-sources</code>.
+     */
+    private String id;
+
+    /**
+     * Field executions.
+     */
+    private java.util.List<Execution> executions;
+
+    /**
+     * Configuration to pass to all goals run in this phase.
+     */
+    private Object configuration;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExecution.
+     * 
+     * @param execution
+     */
+    public void addExecution( Execution execution )
+    {
+        getExecutions().add( execution );
+    } //-- void addExecution( Execution )
+
+    /**
+     * Get configuration to pass to all goals run in this phase.
+     * 
+     * @return Object
+     */
+    public Object getConfiguration()
+    {
+        return this.configuration;
+    } //-- Object getConfiguration()
+
+    /**
+     * Method getExecutions.
+     * 
+     * @return List
+     */
+    public java.util.List<Execution> getExecutions()
+    {
+        if ( this.executions == null )
+        {
+            this.executions = new java.util.ArrayList<Execution>();
+        }
+
+        return this.executions;
+    } //-- java.util.List<Execution> getExecutions()
+
+    /**
+     * Get the ID of this phase, eg <code>generate-sources</code>.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Method removeExecution.
+     * 
+     * @param execution
+     */
+    public void removeExecution( Execution execution )
+    {
+        getExecutions().remove( execution );
+    } //-- void removeExecution( Execution )
+
+    /**
+     * Set configuration to pass to all goals run in this phase.
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( Object configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( Object )
+
+    /**
+     * Set the goals to execute within the phase.
+     * 
+     * @param executions
+     */
+    public void setExecutions( java.util.List<Execution> executions )
+    {
+        this.executions = executions;
+    } //-- void setExecutions( java.util.List )
+
+    /**
+     * Set the ID of this phase, eg <code>generate-sources</code>.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+}
diff --git a/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java
new file mode 100644
index 0000000..c48388f
--- /dev/null
+++ b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java
@@ -0,0 +1,888 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.plugin.lifecycle.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.plugin.lifecycle.Execution;
+import org.apache.maven.plugin.lifecycle.Lifecycle;
+import org.apache.maven.plugin.lifecycle.LifecycleConfiguration;
+import org.apache.maven.plugin.lifecycle.Phase;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class LifecycleMappingsXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class LifecycleMappingsXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public LifecycleMappingsXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.plugin.lifecycle.io.xpp3.LifecycleMappingsXpp3Reader()
+
+    public LifecycleMappingsXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.plugin.lifecycle.io.xpp3.LifecycleMappingsXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return LifecycleConfiguration
+     */
+    public LifecycleConfiguration read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- LifecycleConfiguration read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return LifecycleConfiguration
+     */
+    public LifecycleConfiguration read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- LifecycleConfiguration read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return LifecycleConfiguration
+     */
+    public LifecycleConfiguration read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- LifecycleConfiguration read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return LifecycleConfiguration
+     */
+    public LifecycleConfiguration read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- LifecycleConfiguration read( InputStream )
+
+    /**
+     * Method parseExecution.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Execution
+     */
+    private Execution parseExecution( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Execution execution = new Execution();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                execution.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
+            {
+                java.util.List goals = new java.util.ArrayList/*<String>*/();
+                execution.setGoals( goals );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "goal".equals( parser.getName() ) )
+                    {
+                        goals.add( interpolatedTrimmed( parser.nextText(), "goals" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return execution;
+    } //-- Execution parseExecution( XmlPullParser, boolean )
+
+    /**
+     * Method parseLifecycle.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Lifecycle
+     */
+    private Lifecycle parseLifecycle( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Lifecycle lifecycle = new Lifecycle();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                lifecycle.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "phases", null, parsed ) )
+            {
+                java.util.List phases = new java.util.ArrayList/*<Phase>*/();
+                lifecycle.setPhases( phases );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "phase".equals( parser.getName() ) )
+                    {
+                        phases.add( parsePhase( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return lifecycle;
+    } //-- Lifecycle parseLifecycle( XmlPullParser, boolean )
+
+    /**
+     * Method parseLifecycleConfiguration.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return LifecycleConfiguration
+     */
+    private LifecycleConfiguration parseLifecycleConfiguration( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        LifecycleConfiguration lifecycleConfiguration = new LifecycleConfiguration();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( "lifecycle".equals( parser.getName() ) )
+            {
+                java.util.List lifecycles = lifecycleConfiguration.getLifecycles();
+                if ( lifecycles == null )
+                {
+                    lifecycles = new java.util.ArrayList/*<Lifecycle>*/();
+                    lifecycleConfiguration.setLifecycles( lifecycles );
+                }
+                lifecycles.add( parseLifecycle( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return lifecycleConfiguration;
+    } //-- LifecycleConfiguration parseLifecycleConfiguration( XmlPullParser, boolean )
+
+    /**
+     * Method parsePhase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Phase
+     */
+    private Phase parsePhase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Phase phase = new Phase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                phase.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "executions", null, parsed ) )
+            {
+                java.util.List executions = new java.util.ArrayList/*<Execution>*/();
+                phase.setExecutions( executions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "execution".equals( parser.getName() ) )
+                    {
+                        executions.add( parseExecution( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                phase.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return phase;
+    } //-- Phase parsePhase( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return LifecycleConfiguration
+     */
+    private LifecycleConfiguration read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "lifecycles".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'lifecycles' but found '" + parser.getName() + "'", parser, null );
+                }
+                LifecycleConfiguration lifecycleConfiguration = parseLifecycleConfiguration( parser, strict );
+                lifecycleConfiguration.setModelEncoding( parser.getInputEncoding() );
+                return lifecycleConfiguration;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'lifecycles' but found no element at all: invalid XML document", parser, null );
+    } //-- LifecycleConfiguration read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java
new file mode 100644
index 0000000..83096d6
--- /dev/null
+++ b/maven-plugin-api/target/generated-sources/modello/org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java
@@ -0,0 +1,201 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.plugin.lifecycle.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.plugin.lifecycle.Execution;
+import org.apache.maven.plugin.lifecycle.Lifecycle;
+import org.apache.maven.plugin.lifecycle.LifecycleConfiguration;
+import org.apache.maven.plugin.lifecycle.Phase;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class LifecycleMappingsXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class LifecycleMappingsXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param lifecycleConfiguration
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, LifecycleConfiguration lifecycleConfiguration )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( lifecycleConfiguration.getModelEncoding(), null );
+        writeLifecycleConfiguration( lifecycleConfiguration, "lifecycles", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, LifecycleConfiguration )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param lifecycleConfiguration
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, LifecycleConfiguration lifecycleConfiguration )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, lifecycleConfiguration.getModelEncoding() );
+        serializer.startDocument( lifecycleConfiguration.getModelEncoding(), null );
+        writeLifecycleConfiguration( lifecycleConfiguration, "lifecycles", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, LifecycleConfiguration )
+
+    /**
+     * Method writeExecution.
+     * 
+     * @param execution
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeExecution( Execution execution, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( execution.getConfiguration() != null )
+        {
+            ((Xpp3Dom) execution.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        if ( ( execution.getGoals() != null ) && ( execution.getGoals().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "goals" );
+            for ( Iterator iter = execution.getGoals().iterator(); iter.hasNext(); )
+            {
+                String goal = (String) iter.next();
+                serializer.startTag( NAMESPACE, "goal" ).text( goal ).endTag( NAMESPACE, "goal" );
+            }
+            serializer.endTag( NAMESPACE, "goals" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeExecution( Execution, String, XmlSerializer )
+
+    /**
+     * Method writeLifecycle.
+     * 
+     * @param lifecycle
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeLifecycle( Lifecycle lifecycle, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( lifecycle.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( lifecycle.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( ( lifecycle.getPhases() != null ) && ( lifecycle.getPhases().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "phases" );
+            for ( Iterator iter = lifecycle.getPhases().iterator(); iter.hasNext(); )
+            {
+                Phase o = (Phase) iter.next();
+                writePhase( o, "phase", serializer );
+            }
+            serializer.endTag( NAMESPACE, "phases" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeLifecycle( Lifecycle, String, XmlSerializer )
+
+    /**
+     * Method writeLifecycleConfiguration.
+     * 
+     * @param lifecycleConfiguration
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeLifecycleConfiguration( LifecycleConfiguration lifecycleConfiguration, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/LIFECYCLE/1.0.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/LIFECYCLE/1.0.0 http://maven.apache.org/xsd/lifecycle-1.0.0.xsd" );
+        if ( ( lifecycleConfiguration.getLifecycles() != null ) && ( lifecycleConfiguration.getLifecycles().size() > 0 ) )
+        {
+            for ( Iterator iter = lifecycleConfiguration.getLifecycles().iterator(); iter.hasNext(); )
+            {
+                Lifecycle o = (Lifecycle) iter.next();
+                writeLifecycle( o, "lifecycle", serializer );
+            }
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeLifecycleConfiguration( LifecycleConfiguration, String, XmlSerializer )
+
+    /**
+     * Method writePhase.
+     * 
+     * @param phase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePhase( Phase phase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( phase.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( phase.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( ( phase.getExecutions() != null ) && ( phase.getExecutions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "executions" );
+            for ( Iterator iter = phase.getExecutions().iterator(); iter.hasNext(); )
+            {
+                Execution o = (Execution) iter.next();
+                writeExecution( o, "execution", serializer );
+            }
+            serializer.endTag( NAMESPACE, "executions" );
+        }
+        if ( phase.getConfiguration() != null )
+        {
+            ((Xpp3Dom) phase.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePhase( Phase, String, XmlSerializer )
+
+}
diff --git a/maven-repository-metadata/pom.xml b/maven-repository-metadata/pom.xml
index 14990ad..b7432a7 100644
--- a/maven-repository-metadata/pom.xml
+++ b/maven-repository-metadata/pom.xml
@@ -43,14 +43,23 @@ under the License.
   <build>
     <plugins>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <version>1.1.0</version>
-          <models>
-            <model>src/main/mdo/metadata.mdo</model>
-          </models>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
+        <executions>
+          <execution>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
+            <goals>
+              <goal>add-source</goal>
+            </goals>
+            <configuration>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Metadata.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Metadata.java
new file mode 100644
index 0000000..80c7806
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Metadata.java
@@ -0,0 +1,386 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata;
+
+/**
+ * Class Metadata.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Metadata
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The version of the underlying metadata model.
+     */
+    private String modelVersion;
+
+    /**
+     * The groupId that this directory represents, if any.
+     */
+    private String groupId;
+
+    /**
+     * The artifactId that this directory represents, if any.
+     */
+    private String artifactId;
+
+    /**
+     * The version that this directory represents, if any. It is
+     * used for artifact snapshots only.
+     */
+    private String version;
+
+    /**
+     * Versioning information for the artifact.
+     */
+    private Versioning versioning;
+
+    /**
+     * Field plugins.
+     */
+    private java.util.List<Plugin> plugins;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addPlugin.
+     * 
+     * @param plugin
+     */
+    public void addPlugin( Plugin plugin )
+    {
+        getPlugins().add( plugin );
+    } //-- void addPlugin( Plugin )
+
+    /**
+     * Method clone.
+     * 
+     * @return Metadata
+     */
+    public Metadata clone()
+    {
+        try
+        {
+            Metadata copy = (Metadata) super.clone();
+
+            if ( this.versioning != null )
+            {
+                copy.versioning = (Versioning) this.versioning.clone();
+            }
+
+            if ( this.plugins != null )
+            {
+                copy.plugins = new java.util.ArrayList<Plugin>();
+                for ( Plugin item : this.plugins )
+                {
+                    copy.plugins.add( ( (Plugin) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Metadata clone()
+
+    /**
+     * Get the artifactId that this directory represents, if any.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get the groupId that this directory represents, if any.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Get the version of the underlying metadata model.
+     * 
+     * @return String
+     */
+    public String getModelVersion()
+    {
+        return this.modelVersion;
+    } //-- String getModelVersion()
+
+    /**
+     * Method getPlugins.
+     * 
+     * @return List
+     */
+    public java.util.List<Plugin> getPlugins()
+    {
+        if ( this.plugins == null )
+        {
+            this.plugins = new java.util.ArrayList<Plugin>();
+        }
+
+        return this.plugins;
+    } //-- java.util.List<Plugin> getPlugins()
+
+    /**
+     * Get the version that this directory represents, if any. It
+     * is used for artifact snapshots only.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Get versioning information for the artifact.
+     * 
+     * @return Versioning
+     */
+    public Versioning getVersioning()
+    {
+        return this.versioning;
+    } //-- Versioning getVersioning()
+
+    /**
+     * Method removePlugin.
+     * 
+     * @param plugin
+     */
+    public void removePlugin( Plugin plugin )
+    {
+        getPlugins().remove( plugin );
+    } //-- void removePlugin( Plugin )
+
+    /**
+     * Set the artifactId that this directory represents, if any.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set the groupId that this directory represents, if any.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set the version of the underlying metadata model.
+     * 
+     * @param modelVersion
+     */
+    public void setModelVersion( String modelVersion )
+    {
+        this.modelVersion = modelVersion;
+    } //-- void setModelVersion( String )
+
+    /**
+     * Set the set of plugin mappings for the group represented by
+     * this directory.
+     * 
+     * @param plugins
+     */
+    public void setPlugins( java.util.List<Plugin> plugins )
+    {
+        this.plugins = plugins;
+    } //-- void setPlugins( java.util.List )
+
+    /**
+     * Set the version that this directory represents, if any. It
+     * is used for artifact snapshots only.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    /**
+     * Set versioning information for the artifact.
+     * 
+     * @param versioning
+     */
+    public void setVersioning( Versioning versioning )
+    {
+        this.versioning = versioning;
+    } //-- void setVersioning( Versioning )
+
+    
+    public boolean merge( Metadata sourceMetadata )
+    {
+        boolean changed = false;
+
+        for ( Plugin plugin : sourceMetadata.getPlugins() )
+        {
+            boolean found = false;
+
+            for ( Plugin preExisting : getPlugins() )
+            {
+                if ( preExisting.getPrefix().equals( plugin.getPrefix() ) )
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if ( !found )
+            {
+                Plugin mappedPlugin = new Plugin();
+
+                mappedPlugin.setArtifactId( plugin.getArtifactId() );
+
+                mappedPlugin.setPrefix( plugin.getPrefix() );
+
+                mappedPlugin.setName( plugin.getName() );
+
+                addPlugin( mappedPlugin );
+
+                changed = true;
+            }
+        }
+
+        Versioning versioning = sourceMetadata.getVersioning();
+        if ( versioning != null )
+        {
+            Versioning v = getVersioning();
+            if ( v == null )
+            {
+                v = new Versioning();
+                setVersioning( v );
+                changed = true;
+            }
+
+            for ( String version : versioning.getVersions() )
+            {
+                if ( !v.getVersions().contains( version ) )
+                {
+                    changed = true;
+                    v.getVersions().add( version );
+                }
+            }
+
+            if ( "null".equals( versioning.getLastUpdated() ) )
+            {
+                versioning.setLastUpdated( null );
+            }
+
+            if ( "null".equals( v.getLastUpdated() ) )
+            {
+                v.setLastUpdated( null );
+            }
+
+            if ( versioning.getLastUpdated() == null || versioning.getLastUpdated().length() == 0 )
+            {
+                // this should only be for historical reasons - we assume local is newer
+                versioning.setLastUpdated( v.getLastUpdated() );
+            }
+
+            if ( v.getLastUpdated() == null || v.getLastUpdated().length() == 0
+                 || versioning.getLastUpdated().compareTo( v.getLastUpdated() ) >= 0 )
+            {
+                changed = true;
+                v.setLastUpdated( versioning.getLastUpdated() );
+
+                if ( versioning.getRelease() != null )
+                {
+                    changed = true;
+                    v.setRelease( versioning.getRelease() );
+                }
+                if ( versioning.getLatest() != null )
+                {
+                    changed = true;
+                    v.setLatest( versioning.getLatest() );
+                }
+
+                Snapshot s = v.getSnapshot();
+                Snapshot snapshot = versioning.getSnapshot();
+                if ( snapshot != null )
+                {
+                    if ( s == null )
+                    {
+                        s = new Snapshot();
+                        v.setSnapshot( s );
+                        changed = true;
+                    }
+
+                    // overwrite
+                    if ( s.getTimestamp() == null ? snapshot.getTimestamp() != null
+                        : !s.getTimestamp().equals( snapshot.getTimestamp() ) )
+                    {
+                        s.setTimestamp( snapshot.getTimestamp() );
+                        changed = true;
+                    }
+                    if ( s.getBuildNumber() != snapshot.getBuildNumber() )
+                    {
+                        s.setBuildNumber( snapshot.getBuildNumber() );
+                        changed = true;
+                    }
+                    if ( s.isLocalCopy() != snapshot.isLocalCopy() )
+                    {
+                        s.setLocalCopy( snapshot.isLocalCopy() );
+                        changed = true;
+                    }
+                }
+            }
+        }
+        return changed;
+    }
+          
+}
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Plugin.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Plugin.java
new file mode 100644
index 0000000..b6e0ce4
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Plugin.java
@@ -0,0 +1,125 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata;
+
+/**
+ * Mapping information for a single plugin within this group.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Plugin
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Display name for the plugin.
+     */
+    private String name;
+
+    /**
+     * The plugin invocation prefix (i.e. eclipse for
+     * eclipse:eclipse).
+     */
+    private String prefix;
+
+    /**
+     * The plugin artifactId.
+     */
+    private String artifactId;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Plugin
+     */
+    public Plugin clone()
+    {
+        try
+        {
+            Plugin copy = (Plugin) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Plugin clone()
+
+    /**
+     * Get the plugin artifactId.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get display name for the plugin.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the plugin invocation prefix (i.e. eclipse for
+     * eclipse:eclipse).
+     * 
+     * @return String
+     */
+    public String getPrefix()
+    {
+        return this.prefix;
+    } //-- String getPrefix()
+
+    /**
+     * Set the plugin artifactId.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set display name for the plugin.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the plugin invocation prefix (i.e. eclipse for
+     * eclipse:eclipse).
+     * 
+     * @param prefix
+     */
+    public void setPrefix( String prefix )
+    {
+        this.prefix = prefix;
+    } //-- void setPrefix( String )
+
+}
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Snapshot.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Snapshot.java
new file mode 100644
index 0000000..90ddf72
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Snapshot.java
@@ -0,0 +1,125 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata;
+
+/**
+ * Snapshot data for the current artifact version.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Snapshot
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The time it was deployed.
+     */
+    private String timestamp;
+
+    /**
+     * The incremental build number.
+     */
+    private int buildNumber = 0;
+
+    /**
+     * Whether to use a local copy instead (with filename that
+     * includes the base version).
+     */
+    private boolean localCopy = false;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Snapshot
+     */
+    public Snapshot clone()
+    {
+        try
+        {
+            Snapshot copy = (Snapshot) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Snapshot clone()
+
+    /**
+     * Get the incremental build number.
+     * 
+     * @return int
+     */
+    public int getBuildNumber()
+    {
+        return this.buildNumber;
+    } //-- int getBuildNumber()
+
+    /**
+     * Get the time it was deployed.
+     * 
+     * @return String
+     */
+    public String getTimestamp()
+    {
+        return this.timestamp;
+    } //-- String getTimestamp()
+
+    /**
+     * Get whether to use a local copy instead (with filename that
+     * includes the base version).
+     * 
+     * @return boolean
+     */
+    public boolean isLocalCopy()
+    {
+        return this.localCopy;
+    } //-- boolean isLocalCopy()
+
+    /**
+     * Set the incremental build number.
+     * 
+     * @param buildNumber
+     */
+    public void setBuildNumber( int buildNumber )
+    {
+        this.buildNumber = buildNumber;
+    } //-- void setBuildNumber( int )
+
+    /**
+     * Set whether to use a local copy instead (with filename that
+     * includes the base version).
+     * 
+     * @param localCopy
+     */
+    public void setLocalCopy( boolean localCopy )
+    {
+        this.localCopy = localCopy;
+    } //-- void setLocalCopy( boolean )
+
+    /**
+     * Set the time it was deployed.
+     * 
+     * @param timestamp
+     */
+    public void setTimestamp( String timestamp )
+    {
+        this.timestamp = timestamp;
+    } //-- void setTimestamp( String )
+
+}
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/SnapshotVersion.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/SnapshotVersion.java
new file mode 100644
index 0000000..3c49332
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/SnapshotVersion.java
@@ -0,0 +1,154 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata;
+
+/**
+ * Versioning information for a sub-artifact of the current
+ * snapshot artifact.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class SnapshotVersion
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The classifier of the sub-artifact.
+     */
+    private String classifier = "";
+
+    /**
+     * The file extension of thesub-artifact.
+     */
+    private String extension;
+
+    /**
+     * The resolved snapshot version of the sub-artifact.
+     */
+    private String version;
+
+    /**
+     * The timestamp when this version information was last
+     * updated. The timestamp is expressed using UTC in the format
+     * yyyyMMddHHmmss.
+     */
+    private String updated;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return SnapshotVersion
+     */
+    public SnapshotVersion clone()
+    {
+        try
+        {
+            SnapshotVersion copy = (SnapshotVersion) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- SnapshotVersion clone()
+
+    /**
+     * Get the classifier of the sub-artifact.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Get the file extension of thesub-artifact.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get the timestamp when this version information was last
+     * updated. The timestamp is expressed using UTC in the format
+     * yyyyMMddHHmmss.
+     * 
+     * @return String
+     */
+    public String getUpdated()
+    {
+        return this.updated;
+    } //-- String getUpdated()
+
+    /**
+     * Get the resolved snapshot version of the sub-artifact.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the classifier of the sub-artifact.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set the file extension of thesub-artifact.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set the timestamp when this version information was last
+     * updated. The timestamp is expressed using UTC in the format
+     * yyyyMMddHHmmss.
+     * 
+     * @param updated
+     */
+    public void setUpdated( String updated )
+    {
+        this.updated = updated;
+    } //-- void setUpdated( String )
+
+    /**
+     * Set the resolved snapshot version of the sub-artifact.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Versioning.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Versioning.java
new file mode 100644
index 0000000..4c021f4
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/Versioning.java
@@ -0,0 +1,293 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata;
+
+/**
+ * Versioning information for an artifact (un-versioned or
+ * snapshot).
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Versioning
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * What the latest version in the directory is, including
+     * snapshots.
+     */
+    private String latest;
+
+    /**
+     * What the latest version in the directory is, of the releases
+     * only.
+     */
+    private String release;
+
+    /**
+     * The current snapshot data in use for this version (artifact
+     * snapshots only).
+     */
+    private Snapshot snapshot;
+
+    /**
+     * Field versions.
+     */
+    private java.util.List<String> versions;
+
+    /**
+     * When the metadata was last updated.
+     */
+    private String lastUpdated;
+
+    /**
+     * Field snapshotVersions.
+     */
+    private java.util.List<SnapshotVersion> snapshotVersions;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addSnapshotVersion.
+     * 
+     * @param snapshotVersion
+     */
+    public void addSnapshotVersion( SnapshotVersion snapshotVersion )
+    {
+        getSnapshotVersions().add( snapshotVersion );
+    } //-- void addSnapshotVersion( SnapshotVersion )
+
+    /**
+     * Method addVersion.
+     * 
+     * @param string
+     */
+    public void addVersion( String string )
+    {
+        getVersions().add( string );
+    } //-- void addVersion( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return Versioning
+     */
+    public Versioning clone()
+    {
+        try
+        {
+            Versioning copy = (Versioning) super.clone();
+
+            if ( this.snapshot != null )
+            {
+                copy.snapshot = (Snapshot) this.snapshot.clone();
+            }
+
+            if ( this.versions != null )
+            {
+                copy.versions = new java.util.ArrayList<String>();
+                copy.versions.addAll( this.versions );
+            }
+
+            if ( this.snapshotVersions != null )
+            {
+                copy.snapshotVersions = new java.util.ArrayList<SnapshotVersion>();
+                for ( SnapshotVersion item : this.snapshotVersions )
+                {
+                    copy.snapshotVersions.add( ( (SnapshotVersion) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Versioning clone()
+
+    /**
+     * Get when the metadata was last updated.
+     * 
+     * @return String
+     */
+    public String getLastUpdated()
+    {
+        return this.lastUpdated;
+    } //-- String getLastUpdated()
+
+    /**
+     * Get what the latest version in the directory is, including
+     * snapshots.
+     * 
+     * @return String
+     */
+    public String getLatest()
+    {
+        return this.latest;
+    } //-- String getLatest()
+
+    /**
+     * Get what the latest version in the directory is, of the
+     * releases only.
+     * 
+     * @return String
+     */
+    public String getRelease()
+    {
+        return this.release;
+    } //-- String getRelease()
+
+    /**
+     * Get the current snapshot data in use for this version
+     * (artifact snapshots only).
+     * 
+     * @return Snapshot
+     */
+    public Snapshot getSnapshot()
+    {
+        return this.snapshot;
+    } //-- Snapshot getSnapshot()
+
+    /**
+     * Method getSnapshotVersions.
+     * 
+     * @return List
+     */
+    public java.util.List<SnapshotVersion> getSnapshotVersions()
+    {
+        if ( this.snapshotVersions == null )
+        {
+            this.snapshotVersions = new java.util.ArrayList<SnapshotVersion>();
+        }
+
+        return this.snapshotVersions;
+    } //-- java.util.List<SnapshotVersion> getSnapshotVersions()
+
+    /**
+     * Method getVersions.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getVersions()
+    {
+        if ( this.versions == null )
+        {
+            this.versions = new java.util.ArrayList<String>();
+        }
+
+        return this.versions;
+    } //-- java.util.List<String> getVersions()
+
+    /**
+     * Method removeSnapshotVersion.
+     * 
+     * @param snapshotVersion
+     */
+    public void removeSnapshotVersion( SnapshotVersion snapshotVersion )
+    {
+        getSnapshotVersions().remove( snapshotVersion );
+    } //-- void removeSnapshotVersion( SnapshotVersion )
+
+    /**
+     * Method removeVersion.
+     * 
+     * @param string
+     */
+    public void removeVersion( String string )
+    {
+        getVersions().remove( string );
+    } //-- void removeVersion( String )
+
+    /**
+     * Set when the metadata was last updated.
+     * 
+     * @param lastUpdated
+     */
+    public void setLastUpdated( String lastUpdated )
+    {
+        this.lastUpdated = lastUpdated;
+    } //-- void setLastUpdated( String )
+
+    /**
+     * Set what the latest version in the directory is, including
+     * snapshots.
+     * 
+     * @param latest
+     */
+    public void setLatest( String latest )
+    {
+        this.latest = latest;
+    } //-- void setLatest( String )
+
+    /**
+     * Set what the latest version in the directory is, of the
+     * releases only.
+     * 
+     * @param release
+     */
+    public void setRelease( String release )
+    {
+        this.release = release;
+    } //-- void setRelease( String )
+
+    /**
+     * Set the current snapshot data in use for this version
+     * (artifact snapshots only).
+     * 
+     * @param snapshot
+     */
+    public void setSnapshot( Snapshot snapshot )
+    {
+        this.snapshot = snapshot;
+    } //-- void setSnapshot( Snapshot )
+
+    /**
+     * Set information for each sub-artifact available in this
+     * artifact snapshot.
+     * 
+     * @param snapshotVersions
+     */
+    public void setSnapshotVersions( java.util.List<SnapshotVersion> snapshotVersions )
+    {
+        this.snapshotVersions = snapshotVersions;
+    } //-- void setSnapshotVersions( java.util.List )
+
+    /**
+     * Set versions available of the artifact (both releases and
+     * snapshots).
+     * 
+     * @param versions
+     */
+    public void setVersions( java.util.List<String> versions )
+    {
+        this.versions = versions;
+    } //-- void setVersions( java.util.List )
+
+    
+    public void updateTimestamp()
+    {
+        setLastUpdatedTimestamp( new java.util.Date() );
+    }
+
+    public void setLastUpdatedTimestamp( java.util.Date date )
+    {
+        java.util.TimeZone timezone = java.util.TimeZone.getTimeZone( "UTC" );
+        java.text.DateFormat fmt = new java.text.SimpleDateFormat( "yyyyMMddHHmmss" );
+        fmt.setTimeZone( timezone );
+        setLastUpdated( fmt.format( date ) );
+    }
+          
+}
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java
new file mode 100644
index 0000000..be15de0
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java
@@ -0,0 +1,978 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.artifact.repository.metadata.Metadata;
+import org.apache.maven.artifact.repository.metadata.Plugin;
+import org.apache.maven.artifact.repository.metadata.Snapshot;
+import org.apache.maven.artifact.repository.metadata.SnapshotVersion;
+import org.apache.maven.artifact.repository.metadata.Versioning;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class MetadataXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MetadataXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MetadataXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader()
+
+    public MetadataXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Metadata
+     */
+    public Metadata read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- Metadata read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Metadata
+     */
+    public Metadata read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- Metadata read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Metadata
+     */
+    public Metadata read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- Metadata read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Metadata
+     */
+    public Metadata read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- Metadata read( InputStream )
+
+    /**
+     * Method parseMetadata.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Metadata
+     */
+    private Metadata parseMetadata( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Metadata metadata = new Metadata();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else if ( "modelVersion".equals( name ) )
+            {
+                metadata.setModelVersion( interpolatedTrimmed( value, "modelVersion" ) );
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
+            {
+                metadata.setGroupId( interpolatedTrimmed( parser.nextText(), "groupId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                metadata.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                metadata.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "versioning", null, parsed ) )
+            {
+                metadata.setVersioning( parseVersioning( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
+            {
+                java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();
+                metadata.setPlugins( plugins );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "plugin".equals( parser.getName() ) )
+                    {
+                        plugins.add( parsePlugin( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return metadata;
+    } //-- Metadata parseMetadata( XmlPullParser, boolean )
+
+    /**
+     * Method parsePlugin.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Plugin
+     */
+    private Plugin parsePlugin( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Plugin plugin = new Plugin();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                plugin.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "prefix", null, parsed ) )
+            {
+                plugin.setPrefix( interpolatedTrimmed( parser.nextText(), "prefix" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
+            {
+                plugin.setArtifactId( interpolatedTrimmed( parser.nextText(), "artifactId" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return plugin;
+    } //-- Plugin parsePlugin( XmlPullParser, boolean )
+
+    /**
+     * Method parseSnapshot.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Snapshot
+     */
+    private Snapshot parseSnapshot( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Snapshot snapshot = new Snapshot();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "timestamp", null, parsed ) )
+            {
+                snapshot.setTimestamp( interpolatedTrimmed( parser.nextText(), "timestamp" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "buildNumber", null, parsed ) )
+            {
+                snapshot.setBuildNumber( getIntegerValue( interpolatedTrimmed( parser.nextText(), "buildNumber" ), "buildNumber", parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "localCopy", null, parsed ) )
+            {
+                snapshot.setLocalCopy( getBooleanValue( interpolatedTrimmed( parser.nextText(), "localCopy" ), "localCopy", parser, "false" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return snapshot;
+    } //-- Snapshot parseSnapshot( XmlPullParser, boolean )
+
+    /**
+     * Method parseSnapshotVersion.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return SnapshotVersion
+     */
+    private SnapshotVersion parseSnapshotVersion( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        SnapshotVersion snapshotVersion = new SnapshotVersion();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "classifier", null, parsed ) )
+            {
+                snapshotVersion.setClassifier( interpolatedTrimmed( parser.nextText(), "classifier" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "extension", null, parsed ) )
+            {
+                snapshotVersion.setExtension( interpolatedTrimmed( parser.nextText(), "extension" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "value", null, parsed ) )
+            {
+                snapshotVersion.setVersion( interpolatedTrimmed( parser.nextText(), "value" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "updated", null, parsed ) )
+            {
+                snapshotVersion.setUpdated( interpolatedTrimmed( parser.nextText(), "updated" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return snapshotVersion;
+    } //-- SnapshotVersion parseSnapshotVersion( XmlPullParser, boolean )
+
+    /**
+     * Method parseVersioning.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Versioning
+     */
+    private Versioning parseVersioning( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Versioning versioning = new Versioning();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "latest", null, parsed ) )
+            {
+                versioning.setLatest( interpolatedTrimmed( parser.nextText(), "latest" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "release", null, parsed ) )
+            {
+                versioning.setRelease( interpolatedTrimmed( parser.nextText(), "release" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshot", null, parsed ) )
+            {
+                versioning.setSnapshot( parseSnapshot( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "versions", null, parsed ) )
+            {
+                java.util.List versions = new java.util.ArrayList/*<String>*/();
+                versioning.setVersions( versions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "version".equals( parser.getName() ) )
+                    {
+                        versions.add( interpolatedTrimmed( parser.nextText(), "versions" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "lastUpdated", null, parsed ) )
+            {
+                versioning.setLastUpdated( interpolatedTrimmed( parser.nextText(), "lastUpdated" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshotVersions", null, parsed ) )
+            {
+                java.util.List snapshotVersions = new java.util.ArrayList/*<SnapshotVersion>*/();
+                versioning.setSnapshotVersions( snapshotVersions );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "snapshotVersion".equals( parser.getName() ) )
+                    {
+                        snapshotVersions.add( parseSnapshotVersion( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return versioning;
+    } //-- Versioning parseVersioning( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Metadata
+     */
+    private Metadata read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "metadata".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'metadata' but found '" + parser.getName() + "'", parser, null );
+                }
+                Metadata metadata = parseMetadata( parser, strict );
+                metadata.setModelEncoding( parser.getInputEncoding() );
+                return metadata;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'metadata' but found no element at all: invalid XML document", parser, null );
+    } //-- Metadata read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java
new file mode 100644
index 0000000..319151d
--- /dev/null
+++ b/maven-repository-metadata/target/generated-sources/modello/org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java
@@ -0,0 +1,265 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.artifact.repository.metadata.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.artifact.repository.metadata.Metadata;
+import org.apache.maven.artifact.repository.metadata.Plugin;
+import org.apache.maven.artifact.repository.metadata.Snapshot;
+import org.apache.maven.artifact.repository.metadata.SnapshotVersion;
+import org.apache.maven.artifact.repository.metadata.Versioning;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class MetadataXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MetadataXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param metadata
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, Metadata metadata )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( metadata.getModelEncoding(), null );
+        writeMetadata( metadata, "metadata", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, Metadata )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param metadata
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, Metadata metadata )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, metadata.getModelEncoding() );
+        serializer.startDocument( metadata.getModelEncoding(), null );
+        writeMetadata( metadata, "metadata", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, Metadata )
+
+    /**
+     * Method writeMetadata.
+     * 
+     * @param metadata
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeMetadata( Metadata metadata, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( metadata.getModelVersion() != null )
+        {
+            serializer.attribute( NAMESPACE, "modelVersion", metadata.getModelVersion() );
+        }
+        if ( metadata.getGroupId() != null )
+        {
+            serializer.startTag( NAMESPACE, "groupId" ).text( metadata.getGroupId() ).endTag( NAMESPACE, "groupId" );
+        }
+        if ( metadata.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( metadata.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        if ( metadata.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( metadata.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        if ( metadata.getVersioning() != null )
+        {
+            writeVersioning( (Versioning) metadata.getVersioning(), "versioning", serializer );
+        }
+        if ( ( metadata.getPlugins() != null ) && ( metadata.getPlugins().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "plugins" );
+            for ( Iterator iter = metadata.getPlugins().iterator(); iter.hasNext(); )
+            {
+                Plugin o = (Plugin) iter.next();
+                writePlugin( o, "plugin", serializer );
+            }
+            serializer.endTag( NAMESPACE, "plugins" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeMetadata( Metadata, String, XmlSerializer )
+
+    /**
+     * Method writePlugin.
+     * 
+     * @param plugin
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writePlugin( Plugin plugin, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( plugin.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( plugin.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( plugin.getPrefix() != null )
+        {
+            serializer.startTag( NAMESPACE, "prefix" ).text( plugin.getPrefix() ).endTag( NAMESPACE, "prefix" );
+        }
+        if ( plugin.getArtifactId() != null )
+        {
+            serializer.startTag( NAMESPACE, "artifactId" ).text( plugin.getArtifactId() ).endTag( NAMESPACE, "artifactId" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writePlugin( Plugin, String, XmlSerializer )
+
+    /**
+     * Method writeSnapshot.
+     * 
+     * @param snapshot
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeSnapshot( Snapshot snapshot, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( snapshot.getTimestamp() != null )
+        {
+            serializer.startTag( NAMESPACE, "timestamp" ).text( snapshot.getTimestamp() ).endTag( NAMESPACE, "timestamp" );
+        }
+        if ( snapshot.getBuildNumber() != 0 )
+        {
+            serializer.startTag( NAMESPACE, "buildNumber" ).text( String.valueOf( snapshot.getBuildNumber() ) ).endTag( NAMESPACE, "buildNumber" );
+        }
+        if ( snapshot.isLocalCopy() != false )
+        {
+            serializer.startTag( NAMESPACE, "localCopy" ).text( String.valueOf( snapshot.isLocalCopy() ) ).endTag( NAMESPACE, "localCopy" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeSnapshot( Snapshot, String, XmlSerializer )
+
+    /**
+     * Method writeSnapshotVersion.
+     * 
+     * @param snapshotVersion
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeSnapshotVersion( SnapshotVersion snapshotVersion, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( snapshotVersion.getClassifier() != null ) && !snapshotVersion.getClassifier().equals( "" ) )
+        {
+            serializer.startTag( NAMESPACE, "classifier" ).text( snapshotVersion.getClassifier() ).endTag( NAMESPACE, "classifier" );
+        }
+        if ( snapshotVersion.getExtension() != null )
+        {
+            serializer.startTag( NAMESPACE, "extension" ).text( snapshotVersion.getExtension() ).endTag( NAMESPACE, "extension" );
+        }
+        if ( snapshotVersion.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "value" ).text( snapshotVersion.getVersion() ).endTag( NAMESPACE, "value" );
+        }
+        if ( snapshotVersion.getUpdated() != null )
+        {
+            serializer.startTag( NAMESPACE, "updated" ).text( snapshotVersion.getUpdated() ).endTag( NAMESPACE, "updated" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeSnapshotVersion( SnapshotVersion, String, XmlSerializer )
+
+    /**
+     * Method writeVersioning.
+     * 
+     * @param versioning
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeVersioning( Versioning versioning, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( versioning.getLatest() != null )
+        {
+            serializer.startTag( NAMESPACE, "latest" ).text( versioning.getLatest() ).endTag( NAMESPACE, "latest" );
+        }
+        if ( versioning.getRelease() != null )
+        {
+            serializer.startTag( NAMESPACE, "release" ).text( versioning.getRelease() ).endTag( NAMESPACE, "release" );
+        }
+        if ( versioning.getSnapshot() != null )
+        {
+            writeSnapshot( (Snapshot) versioning.getSnapshot(), "snapshot", serializer );
+        }
+        if ( ( versioning.getVersions() != null ) && ( versioning.getVersions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "versions" );
+            for ( Iterator iter = versioning.getVersions().iterator(); iter.hasNext(); )
+            {
+                String version = (String) iter.next();
+                serializer.startTag( NAMESPACE, "version" ).text( version ).endTag( NAMESPACE, "version" );
+            }
+            serializer.endTag( NAMESPACE, "versions" );
+        }
+        if ( versioning.getLastUpdated() != null )
+        {
+            serializer.startTag( NAMESPACE, "lastUpdated" ).text( versioning.getLastUpdated() ).endTag( NAMESPACE, "lastUpdated" );
+        }
+        if ( ( versioning.getSnapshotVersions() != null ) && ( versioning.getSnapshotVersions().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "snapshotVersions" );
+            for ( Iterator iter = versioning.getSnapshotVersions().iterator(); iter.hasNext(); )
+            {
+                SnapshotVersion o = (SnapshotVersion) iter.next();
+                writeSnapshotVersion( o, "snapshotVersion", serializer );
+            }
+            serializer.endTag( NAMESPACE, "snapshotVersions" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeVersioning( Versioning, String, XmlSerializer )
+
+}
diff --git a/maven-settings/pom.xml b/maven-settings/pom.xml
index 28ceb51..f5de187 100644
--- a/maven-settings/pom.xml
+++ b/maven-settings/pom.xml
@@ -43,14 +43,23 @@ under the License.
   <build>
     <plugins>
       <plugin>
-        <groupId>org.codehaus.modello</groupId>
-        <artifactId>modello-maven-plugin</artifactId>
-        <configuration>
-          <version>1.1.0</version>
-          <models>
-            <model>src/main/mdo/settings.mdo</model>
-          </models>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <version>1.10</version>
+        <executions>
+          <execution>
+            <id>add-modello-sources</id>
+            <phase>generate-sources</phase>
+            <goals>
+              <goal>add-source</goal>
+            </goals>
+            <configuration>
+              <sources>
+                <source>${basedir}/target/generated-sources/modello</source>
+              </sources>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Activation.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Activation.java
new file mode 100644
index 0000000..f10d253
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Activation.java
@@ -0,0 +1,226 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         The conditions within the build runtime environment
+ * which will trigger
+ *         the automatic inclusion of the parent build profile.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Activation
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Flag specifying whether this profile is active
+     * as a default.
+     *           
+     */
+    private boolean activeByDefault = false;
+
+    /**
+     * 
+     *             
+     *             Specifies that this profile will be activated
+     * when a matching JDK is detected.
+     *             
+     *           
+     */
+    private String jdk;
+
+    /**
+     * 
+     *             
+     *             Specifies that this profile will be activated
+     * when matching OS attributes are detected.
+     *             
+     *           
+     */
+    private ActivationOS os;
+
+    /**
+     * 
+     *             
+     *             Specifies that this profile will be activated
+     * when this System property is specified.
+     *             
+     *           
+     */
+    private ActivationProperty property;
+
+    /**
+     * 
+     *             
+     *             Specifies that this profile will be activated
+     * based on existence of a file.
+     *             
+     *           
+     */
+    private ActivationFile file;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Activation
+     */
+    public Activation clone()
+    {
+        try
+        {
+            Activation copy = (Activation) super.clone();
+
+            if ( this.os != null )
+            {
+                copy.os = (ActivationOS) this.os.clone();
+            }
+
+            if ( this.property != null )
+            {
+                copy.property = (ActivationProperty) this.property.clone();
+            }
+
+            if ( this.file != null )
+            {
+                copy.file = (ActivationFile) this.file.clone();
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Activation clone()
+
+    /**
+     * Get specifies that this profile will be activated based on
+     * existence of a file.
+     * 
+     * @return ActivationFile
+     */
+    public ActivationFile getFile()
+    {
+        return this.file;
+    } //-- ActivationFile getFile()
+
+    /**
+     * Get specifies that this profile will be activated when a
+     * matching JDK is detected.
+     * 
+     * @return String
+     */
+    public String getJdk()
+    {
+        return this.jdk;
+    } //-- String getJdk()
+
+    /**
+     * Get specifies that this profile will be activated when
+     * matching OS attributes are detected.
+     * 
+     * @return ActivationOS
+     */
+    public ActivationOS getOs()
+    {
+        return this.os;
+    } //-- ActivationOS getOs()
+
+    /**
+     * Get specifies that this profile will be activated when this
+     * System property is specified.
+     * 
+     * @return ActivationProperty
+     */
+    public ActivationProperty getProperty()
+    {
+        return this.property;
+    } //-- ActivationProperty getProperty()
+
+    /**
+     * Get flag specifying whether this profile is active as a
+     * default.
+     * 
+     * @return boolean
+     */
+    public boolean isActiveByDefault()
+    {
+        return this.activeByDefault;
+    } //-- boolean isActiveByDefault()
+
+    /**
+     * Set flag specifying whether this profile is active as a
+     * default.
+     * 
+     * @param activeByDefault
+     */
+    public void setActiveByDefault( boolean activeByDefault )
+    {
+        this.activeByDefault = activeByDefault;
+    } //-- void setActiveByDefault( boolean )
+
+    /**
+     * Set specifies that this profile will be activated based on
+     * existence of a file.
+     * 
+     * @param file
+     */
+    public void setFile( ActivationFile file )
+    {
+        this.file = file;
+    } //-- void setFile( ActivationFile )
+
+    /**
+     * Set specifies that this profile will be activated when a
+     * matching JDK is detected.
+     * 
+     * @param jdk
+     */
+    public void setJdk( String jdk )
+    {
+        this.jdk = jdk;
+    } //-- void setJdk( String )
+
+    /**
+     * Set specifies that this profile will be activated when
+     * matching OS attributes are detected.
+     * 
+     * @param os
+     */
+    public void setOs( ActivationOS os )
+    {
+        this.os = os;
+    } //-- void setOs( ActivationOS )
+
+    /**
+     * Set specifies that this profile will be activated when this
+     * System property is specified.
+     * 
+     * @param property
+     */
+    public void setProperty( ActivationProperty property )
+    {
+        this.property = property;
+    } //-- void setProperty( ActivationProperty )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationFile.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationFile.java
new file mode 100644
index 0000000..cc02669
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationFile.java
@@ -0,0 +1,119 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         This is the file specification used to activate a
+ * profile. The missing value will be a the location
+ *         of a file that needs to exist, and if it doesn't the
+ * profile must run.  On the other hand exists will test
+ *         for the existence of the file and if it is there will
+ * run the profile.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationFile
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             The name of the file that should be missing to
+     * activate a
+     *             profile.
+     *           
+     */
+    private String missing;
+
+    /**
+     * 
+     *             The name of the file that should exist to
+     * activate a profile.
+     *           
+     */
+    private String exists;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ActivationFile
+     */
+    public ActivationFile clone()
+    {
+        try
+        {
+            ActivationFile copy = (ActivationFile) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ActivationFile clone()
+
+    /**
+     * Get the name of the file that should exist to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getExists()
+    {
+        return this.exists;
+    } //-- String getExists()
+
+    /**
+     * Get the name of the file that should be missing to activate
+     * a
+     *             profile.
+     * 
+     * @return String
+     */
+    public String getMissing()
+    {
+        return this.missing;
+    } //-- String getMissing()
+
+    /**
+     * Set the name of the file that should exist to activate a
+     * profile.
+     * 
+     * @param exists
+     */
+    public void setExists( String exists )
+    {
+        this.exists = exists;
+    } //-- void setExists( String )
+
+    /**
+     * Set the name of the file that should be missing to activate
+     * a
+     *             profile.
+     * 
+     * @param missing
+     */
+    public void setMissing( String missing )
+    {
+        this.missing = missing;
+    } //-- void setMissing( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationOS.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationOS.java
new file mode 100644
index 0000000..934bf05
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationOS.java
@@ -0,0 +1,170 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         This is an activator which will detect an operating
+ * system's attributes in order to activate
+ *         its profile.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationOS
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             The name of the OS to be used to activate a
+     * profile.
+     *           
+     */
+    private String name;
+
+    /**
+     * 
+     *             The general family of the OS to be used to
+     * activate a
+     *             profile (e.g. 'windows')
+     *           .
+     */
+    private String family;
+
+    /**
+     * 
+     *             The architecture of the OS to be used to
+     * activate a profile.
+     *           
+     */
+    private String arch;
+
+    /**
+     * 
+     *             The version of the OS to be used to activate a
+     * profile.
+     *           
+     */
+    private String version;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ActivationOS
+     */
+    public ActivationOS clone()
+    {
+        try
+        {
+            ActivationOS copy = (ActivationOS) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ActivationOS clone()
+
+    /**
+     * Get the architecture of the OS to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getArch()
+    {
+        return this.arch;
+    } //-- String getArch()
+
+    /**
+     * Get the general family of the OS to be used to activate a
+     *             profile (e.g. 'windows').
+     * 
+     * @return String
+     */
+    public String getFamily()
+    {
+        return this.family;
+    } //-- String getFamily()
+
+    /**
+     * Get the name of the OS to be used to activate a profile.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the version of the OS to be used to activate a profile.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set the architecture of the OS to be used to activate a
+     * profile.
+     * 
+     * @param arch
+     */
+    public void setArch( String arch )
+    {
+        this.arch = arch;
+    } //-- void setArch( String )
+
+    /**
+     * Set the general family of the OS to be used to activate a
+     *             profile (e.g. 'windows').
+     * 
+     * @param family
+     */
+    public void setFamily( String family )
+    {
+        this.family = family;
+    } //-- void setFamily( String )
+
+    /**
+     * Set the name of the OS to be used to activate a profile.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the version of the OS to be used to activate a profile.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationProperty.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationProperty.java
new file mode 100644
index 0000000..1d6780c
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/ActivationProperty.java
@@ -0,0 +1,115 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         This is the property specification used to activate a
+ * profile. If the value field is empty,
+ *         then the existence of the named property will activate
+ * the profile, otherwise it does a case-sensitive
+ *         match against the property value as well.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ActivationProperty
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             The name of the property to be used to activate
+     * a profile.
+     *           
+     */
+    private String name;
+
+    /**
+     * 
+     *             The value of the property to be used to activate
+     * a profile.
+     *           
+     */
+    private String value;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ActivationProperty
+     */
+    public ActivationProperty clone()
+    {
+        try
+        {
+            ActivationProperty copy = (ActivationProperty) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ActivationProperty clone()
+
+    /**
+     * Get the name of the property to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the value of the property to be used to activate a
+     * profile.
+     * 
+     * @return String
+     */
+    public String getValue()
+    {
+        return this.value;
+    } //-- String getValue()
+
+    /**
+     * Set the name of the property to be used to activate a
+     * profile.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the value of the property to be used to activate a
+     * profile.
+     * 
+     * @param value
+     */
+    public void setValue( String value )
+    {
+        this.value = value;
+    } //-- void setValue( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/IdentifiableBase.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/IdentifiableBase.java
new file mode 100644
index 0000000..76d23dd
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/IdentifiableBase.java
@@ -0,0 +1,78 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         Base class for <code>Mirror</code>,
+ * <code>Profile</code>, <code>Proxy</code> and
+ * <code>Server</code>.
+ *         
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class IdentifiableBase
+    extends TrackableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field id.
+     */
+    private String id = "default";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return IdentifiableBase
+     */
+    public IdentifiableBase clone()
+    {
+        try
+        {
+            IdentifiableBase copy = (IdentifiableBase) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- IdentifiableBase clone()
+
+    /**
+     * Get the id field.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Set the id field.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Mirror.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Mirror.java
new file mode 100644
index 0000000..b123fc5
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Mirror.java
@@ -0,0 +1,210 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         A download mirror for a given repository.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Mirror
+    extends IdentifiableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             The server ID of the repository being mirrored,
+     * eg
+     *             "central". This MUST NOT match the mirror id.
+     *           
+     */
+    private String mirrorOf;
+
+    /**
+     * 
+     *             The optional name that describes the mirror.
+     *           
+     */
+    private String name;
+
+    /**
+     * The URL of the mirror repository.
+     */
+    private String url;
+
+    /**
+     * The layout of the mirror repository. Since Maven 3.
+     */
+    private String layout = "default";
+
+    /**
+     * 
+     *             The layouts of repositories being mirrored. This
+     * value can be used to restrict the usage
+     *             of the mirror to repositories with a matching
+     * layout (apart from a matching id). Since Maven 3.
+     *           
+     */
+    private String mirrorOfLayouts = "default,legacy";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Mirror
+     */
+    public Mirror clone()
+    {
+        try
+        {
+            Mirror copy = (Mirror) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Mirror clone()
+
+    /**
+     * Get the layout of the mirror repository. Since Maven 3.
+     * 
+     * @return String
+     */
+    public String getLayout()
+    {
+        return this.layout;
+    } //-- String getLayout()
+
+    /**
+     * Get the server ID of the repository being mirrored, eg
+     *             "central". This MUST NOT match the mirror id.
+     * 
+     * @return String
+     */
+    public String getMirrorOf()
+    {
+        return this.mirrorOf;
+    } //-- String getMirrorOf()
+
+    /**
+     * Get the layouts of repositories being mirrored. This value
+     * can be used to restrict the usage
+     *             of the mirror to repositories with a matching
+     * layout (apart from a matching id). Since Maven 3.
+     * 
+     * @return String
+     */
+    public String getMirrorOfLayouts()
+    {
+        return this.mirrorOfLayouts;
+    } //-- String getMirrorOfLayouts()
+
+    /**
+     * Get the optional name that describes the mirror.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the URL of the mirror repository.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Set the layout of the mirror repository. Since Maven 3.
+     * 
+     * @param layout
+     */
+    public void setLayout( String layout )
+    {
+        this.layout = layout;
+    } //-- void setLayout( String )
+
+    /**
+     * Set the server ID of the repository being mirrored, eg
+     *             "central". This MUST NOT match the mirror id.
+     * 
+     * @param mirrorOf
+     */
+    public void setMirrorOf( String mirrorOf )
+    {
+        this.mirrorOf = mirrorOf;
+    } //-- void setMirrorOf( String )
+
+    /**
+     * Set the layouts of repositories being mirrored. This value
+     * can be used to restrict the usage
+     *             of the mirror to repositories with a matching
+     * layout (apart from a matching id). Since Maven 3.
+     * 
+     * @param mirrorOfLayouts
+     */
+    public void setMirrorOfLayouts( String mirrorOfLayouts )
+    {
+        this.mirrorOfLayouts = mirrorOfLayouts;
+    } //-- void setMirrorOfLayouts( String )
+
+    /**
+     * Set the optional name that describes the mirror.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the URL of the mirror repository.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+    
+            
+
+    public String toString()
+    {
+        StringBuilder sb = new StringBuilder( 128 );
+        sb.append( "Mirror[" );
+        sb.append( "id=" ).append( this.getId() );
+        sb.append( ",mirrorOf=" ).append( mirrorOf );
+        sb.append( ",url=" ).append( this.url );
+        sb.append( ",name=" ).append( this.name );
+        sb.append( "]" );
+        return sb.toString();
+    }
+            
+          
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Profile.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Profile.java
new file mode 100644
index 0000000..a5572e8
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Profile.java
@@ -0,0 +1,267 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         Modifications to the build process which is keyed on
+ * some
+ *         sort of environmental parameter.
+ *         
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Profile
+    extends IdentifiableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The conditional logic which will automatically
+     *             trigger the inclusion of this profile.
+     *             
+     *           
+     */
+    private Activation activation;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Field repositories.
+     */
+    private java.util.List<Repository> repositories;
+
+    /**
+     * 
+     *             
+     *             This may be removed or relocated in the near
+     *             future. It is undecided whether plugins really
+     * need a remote
+     *             repository set of their own.
+     *             
+     *           
+     */
+    private java.util.List<Repository> pluginRepositories;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addPluginRepository.
+     * 
+     * @param repository
+     */
+    public void addPluginRepository( Repository repository )
+    {
+        getPluginRepositories().add( repository );
+    } //-- void addPluginRepository( Repository )
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addRepository.
+     * 
+     * @param repository
+     */
+    public void addRepository( Repository repository )
+    {
+        getRepositories().add( repository );
+    } //-- void addRepository( Repository )
+
+    /**
+     * Method clone.
+     * 
+     * @return Profile
+     */
+    public Profile clone()
+    {
+        try
+        {
+            Profile copy = (Profile) super.clone();
+
+            if ( this.activation != null )
+            {
+                copy.activation = (Activation) this.activation.clone();
+            }
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( this.repositories != null )
+            {
+                copy.repositories = new java.util.ArrayList<Repository>();
+                for ( Repository item : this.repositories )
+                {
+                    copy.repositories.add( ( (Repository) item).clone() );
+                }
+            }
+
+            if ( this.pluginRepositories != null )
+            {
+                copy.pluginRepositories = new java.util.ArrayList<Repository>();
+                for ( Repository item : this.pluginRepositories )
+                {
+                    copy.pluginRepositories.add( ( (Repository) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Profile clone()
+
+    /**
+     * Get the conditional logic which will automatically
+     *             trigger the inclusion of this profile.
+     * 
+     * @return Activation
+     */
+    public Activation getActivation()
+    {
+        return this.activation;
+    } //-- Activation getActivation()
+
+    /**
+     * Method getPluginRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getPluginRepositories()
+    {
+        if ( this.pluginRepositories == null )
+        {
+            this.pluginRepositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.pluginRepositories;
+    } //-- java.util.List<Repository> getPluginRepositories()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Method getRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getRepositories()
+    {
+        if ( this.repositories == null )
+        {
+            this.repositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.repositories;
+    } //-- java.util.List<Repository> getRepositories()
+
+    /**
+     * Method removePluginRepository.
+     * 
+     * @param repository
+     */
+    public void removePluginRepository( Repository repository )
+    {
+        getPluginRepositories().remove( repository );
+    } //-- void removePluginRepository( Repository )
+
+    /**
+     * Method removeRepository.
+     * 
+     * @param repository
+     */
+    public void removeRepository( Repository repository )
+    {
+        getRepositories().remove( repository );
+    } //-- void removeRepository( Repository )
+
+    /**
+     * Set the conditional logic which will automatically
+     *             trigger the inclusion of this profile.
+     * 
+     * @param activation
+     */
+    public void setActivation( Activation activation )
+    {
+        this.activation = activation;
+    } //-- void setActivation( Activation )
+
+    /**
+     * Set the lists of the remote repositories for discovering
+     * plugins.
+     * 
+     * @param pluginRepositories
+     */
+    public void setPluginRepositories( java.util.List<Repository> pluginRepositories )
+    {
+        this.pluginRepositories = pluginRepositories;
+    } //-- void setPluginRepositories( java.util.List )
+
+    /**
+     * Set extended configuration specific to this profile goes
+     * here.
+     *             Contents take the form of
+     *            
+     * <code>&lt;property.name&gt;property.value&lt;/property.name&gt;</code>
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set the lists of the remote repositories.
+     * 
+     * @param repositories
+     */
+    public void setRepositories( java.util.List<Repository> repositories )
+    {
+        this.repositories = repositories;
+    } //-- void setRepositories( java.util.List )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Proxy.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Proxy.java
new file mode 100644
index 0000000..8b931e9
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Proxy.java
@@ -0,0 +1,256 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;proxy&gt;</code> element contains
+ * informations required to a proxy settings.
+ *         
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Proxy
+    extends IdentifiableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             Whether this proxy configuration is the active
+     * one.
+     *             
+     *           
+     */
+    private boolean active = true;
+
+    /**
+     * 
+     *             
+     *             The proxy protocol.
+     *             
+     *           
+     */
+    private String protocol = "http";
+
+    /**
+     * 
+     *             
+     *             The proxy user.
+     *             
+     *           
+     */
+    private String username;
+
+    /**
+     * 
+     *             
+     *             The proxy password.
+     *             
+     *           
+     */
+    private String password;
+
+    /**
+     * 
+     *             
+     *             The proxy port.
+     *             
+     *           
+     */
+    private int port = 8080;
+
+    /**
+     * 
+     *             
+     *             The proxy host.
+     *             
+     *           
+     */
+    private String host;
+
+    /**
+     * 
+     *             
+     *             The list of non-proxied hosts (delimited by |).
+     *             
+     *           
+     */
+    private String nonProxyHosts;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Proxy
+     */
+    public Proxy clone()
+    {
+        try
+        {
+            Proxy copy = (Proxy) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Proxy clone()
+
+    /**
+     * Get the proxy host.
+     * 
+     * @return String
+     */
+    public String getHost()
+    {
+        return this.host;
+    } //-- String getHost()
+
+    /**
+     * Get the list of non-proxied hosts (delimited by |).
+     * 
+     * @return String
+     */
+    public String getNonProxyHosts()
+    {
+        return this.nonProxyHosts;
+    } //-- String getNonProxyHosts()
+
+    /**
+     * Get the proxy password.
+     * 
+     * @return String
+     */
+    public String getPassword()
+    {
+        return this.password;
+    } //-- String getPassword()
+
+    /**
+     * Get the proxy port.
+     * 
+     * @return int
+     */
+    public int getPort()
+    {
+        return this.port;
+    } //-- int getPort()
+
+    /**
+     * Get the proxy protocol.
+     * 
+     * @return String
+     */
+    public String getProtocol()
+    {
+        return this.protocol;
+    } //-- String getProtocol()
+
+    /**
+     * Get the proxy user.
+     * 
+     * @return String
+     */
+    public String getUsername()
+    {
+        return this.username;
+    } //-- String getUsername()
+
+    /**
+     * Get whether this proxy configuration is the active one.
+     * 
+     * @return boolean
+     */
+    public boolean isActive()
+    {
+        return this.active;
+    } //-- boolean isActive()
+
+    /**
+     * Set whether this proxy configuration is the active one.
+     * 
+     * @param active
+     */
+    public void setActive( boolean active )
+    {
+        this.active = active;
+    } //-- void setActive( boolean )
+
+    /**
+     * Set the proxy host.
+     * 
+     * @param host
+     */
+    public void setHost( String host )
+    {
+        this.host = host;
+    } //-- void setHost( String )
+
+    /**
+     * Set the list of non-proxied hosts (delimited by |).
+     * 
+     * @param nonProxyHosts
+     */
+    public void setNonProxyHosts( String nonProxyHosts )
+    {
+        this.nonProxyHosts = nonProxyHosts;
+    } //-- void setNonProxyHosts( String )
+
+    /**
+     * Set the proxy password.
+     * 
+     * @param password
+     */
+    public void setPassword( String password )
+    {
+        this.password = password;
+    } //-- void setPassword( String )
+
+    /**
+     * Set the proxy port.
+     * 
+     * @param port
+     */
+    public void setPort( int port )
+    {
+        this.port = port;
+    } //-- void setPort( int )
+
+    /**
+     * Set the proxy protocol.
+     * 
+     * @param protocol
+     */
+    public void setProtocol( String protocol )
+    {
+        this.protocol = protocol;
+    } //-- void setProtocol( String )
+
+    /**
+     * Set the proxy user.
+     * 
+     * @param username
+     */
+    public void setUsername( String username )
+    {
+        this.username = username;
+    } //-- void setUsername( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Repository.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Repository.java
new file mode 100644
index 0000000..d2d935b
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Repository.java
@@ -0,0 +1,133 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         Repository contains the information needed for
+ * establishing
+ *         connections with remote repository
+ *       .
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Repository
+    extends RepositoryBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             How to handle downloading of releases from this
+     * repository
+     *           .
+     */
+    private RepositoryPolicy releases;
+
+    /**
+     * 
+     *             How to handle downloading of snapshots from this
+     * repository
+     *           .
+     */
+    private RepositoryPolicy snapshots;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Repository
+     */
+    public Repository clone()
+    {
+        try
+        {
+            Repository copy = (Repository) super.clone();
+
+            if ( this.releases != null )
+            {
+                copy.releases = (RepositoryPolicy) this.releases.clone();
+            }
+
+            if ( this.snapshots != null )
+            {
+                copy.snapshots = (RepositoryPolicy) this.snapshots.clone();
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Repository clone()
+
+    /**
+     * Get how to handle downloading of releases from this
+     * repository.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy getReleases()
+    {
+        return this.releases;
+    } //-- RepositoryPolicy getReleases()
+
+    /**
+     * Get how to handle downloading of snapshots from this
+     * repository.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy getSnapshots()
+    {
+        return this.snapshots;
+    } //-- RepositoryPolicy getSnapshots()
+
+    /**
+     * Set how to handle downloading of releases from this
+     * repository.
+     * 
+     * @param releases
+     */
+    public void setReleases( RepositoryPolicy releases )
+    {
+        this.releases = releases;
+    } //-- void setReleases( RepositoryPolicy )
+
+    /**
+     * Set how to handle downloading of snapshots from this
+     * repository.
+     * 
+     * @param snapshots
+     */
+    public void setSnapshots( RepositoryPolicy snapshots )
+    {
+        this.snapshots = snapshots;
+    } //-- void setSnapshots( RepositoryPolicy )
+
+    
+            
+    /**
+     * @see org.apache.maven.settings.RepositoryBase#equals(java.lang.Object)
+     */
+    public boolean equals( Object obj )
+    {
+        return super.equals( obj );
+    }
+            
+          
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryBase.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryBase.java
new file mode 100644
index 0000000..f50d1bc
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryBase.java
@@ -0,0 +1,193 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         Repository contains the information needed
+ *         for establishing connections with remote repoistory
+ *         
+ *       .
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class RepositoryBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             A unique identifier for a repository.
+     *             
+     *           
+     */
+    private String id;
+
+    /**
+     * 
+     *             
+     *             Human readable name of the repository.
+     *             
+     *           
+     */
+    private String name;
+
+    /**
+     * 
+     *             
+     *             The url of the repository.
+     *             
+     *           
+     */
+    private String url;
+
+    /**
+     * 
+     *             The type of layout this repository uses for
+     * locating and
+     *             storing artifacts - can be "legacy" or
+     * "default".
+     *           
+     */
+    private String layout = "default";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return RepositoryBase
+     */
+    public RepositoryBase clone()
+    {
+        try
+        {
+            RepositoryBase copy = (RepositoryBase) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- RepositoryBase clone()
+
+    /**
+     * Get a unique identifier for a repository.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Get the type of layout this repository uses for locating and
+     *             storing artifacts - can be "legacy" or
+     * "default".
+     * 
+     * @return String
+     */
+    public String getLayout()
+    {
+        return this.layout;
+    } //-- String getLayout()
+
+    /**
+     * Get human readable name of the repository.
+     * 
+     * @return String
+     */
+    public String getName()
+    {
+        return this.name;
+    } //-- String getName()
+
+    /**
+     * Get the url of the repository.
+     * 
+     * @return String
+     */
+    public String getUrl()
+    {
+        return this.url;
+    } //-- String getUrl()
+
+    /**
+     * Set a unique identifier for a repository.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set the type of layout this repository uses for locating and
+     *             storing artifacts - can be "legacy" or
+     * "default".
+     * 
+     * @param layout
+     */
+    public void setLayout( String layout )
+    {
+        this.layout = layout;
+    } //-- void setLayout( String )
+
+    /**
+     * Set human readable name of the repository.
+     * 
+     * @param name
+     */
+    public void setName( String name )
+    {
+        this.name = name;
+    } //-- void setName( String )
+
+    /**
+     * Set the url of the repository.
+     * 
+     * @param url
+     */
+    public void setUrl( String url )
+    {
+        this.url = url;
+    } //-- void setUrl( String )
+
+    
+            
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals( Object obj )
+    {
+        RepositoryBase other =  (RepositoryBase) obj;
+
+        boolean retValue = false;
+
+        if ( id != null )
+        {
+            retValue = id.equals( other.id );
+        }
+
+        return retValue;
+    }
+            
+          
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryPolicy.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryPolicy.java
new file mode 100644
index 0000000..d791a32
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/RepositoryPolicy.java
@@ -0,0 +1,153 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * Download policy.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class RepositoryPolicy
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Whether to use this repository for downloading
+     * this type of
+     *             artifact.
+     *           
+     */
+    private boolean enabled = true;
+
+    /**
+     * 
+     *             The frequency for downloading updates - can be
+     * "always",
+     *             "daily" (default), "interval:XXX" (in minutes)
+     * or "never"
+     *             (only if it doesn't exist locally).
+     *           
+     */
+    private String updatePolicy;
+
+    /**
+     * 
+     *             What to do when verification of an artifact
+     * checksum fails -
+     *             warn, fail, etc. Valid values are "fail" or
+     * "warn".
+     *           
+     */
+    private String checksumPolicy;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return RepositoryPolicy
+     */
+    public RepositoryPolicy clone()
+    {
+        try
+        {
+            RepositoryPolicy copy = (RepositoryPolicy) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- RepositoryPolicy clone()
+
+    /**
+     * Get what to do when verification of an artifact checksum
+     * fails -
+     *             warn, fail, etc. Valid values are "fail" or
+     * "warn".
+     * 
+     * @return String
+     */
+    public String getChecksumPolicy()
+    {
+        return this.checksumPolicy;
+    } //-- String getChecksumPolicy()
+
+    /**
+     * Get the frequency for downloading updates - can be "always",
+     *             "daily" (default), "interval:XXX" (in minutes)
+     * or "never"
+     *             (only if it doesn't exist locally).
+     * 
+     * @return String
+     */
+    public String getUpdatePolicy()
+    {
+        return this.updatePolicy;
+    } //-- String getUpdatePolicy()
+
+    /**
+     * Get whether to use this repository for downloading this type
+     * of
+     *             artifact.
+     * 
+     * @return boolean
+     */
+    public boolean isEnabled()
+    {
+        return this.enabled;
+    } //-- boolean isEnabled()
+
+    /**
+     * Set what to do when verification of an artifact checksum
+     * fails -
+     *             warn, fail, etc. Valid values are "fail" or
+     * "warn".
+     * 
+     * @param checksumPolicy
+     */
+    public void setChecksumPolicy( String checksumPolicy )
+    {
+        this.checksumPolicy = checksumPolicy;
+    } //-- void setChecksumPolicy( String )
+
+    /**
+     * Set whether to use this repository for downloading this type
+     * of
+     *             artifact.
+     * 
+     * @param enabled
+     */
+    public void setEnabled( boolean enabled )
+    {
+        this.enabled = enabled;
+    } //-- void setEnabled( boolean )
+
+    /**
+     * Set the frequency for downloading updates - can be "always",
+     *             "daily" (default), "interval:XXX" (in minutes)
+     * or "never"
+     *             (only if it doesn't exist locally).
+     * 
+     * @param updatePolicy
+     */
+    public void setUpdatePolicy( String updatePolicy )
+    {
+        this.updatePolicy = updatePolicy;
+    } //-- void setUpdatePolicy( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Server.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Server.java
new file mode 100644
index 0000000..595da54
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Server.java
@@ -0,0 +1,267 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         
+ *         The <code>&lt;server&gt;</code> element contains
+ * informations required to a server settings.
+ *         
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Server
+    extends IdentifiableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The username used to authenticate.
+     *             
+     *           
+     */
+    private String username;
+
+    /**
+     * 
+     *             
+     *             The password used in conjunction with the
+     * username to authenticate.
+     *             
+     *           
+     */
+    private String password;
+
+    /**
+     * 
+     *             
+     *             The private key location used to authenticate.
+     *             
+     *           
+     */
+    private String privateKey;
+
+    /**
+     * 
+     *             
+     *             The passphrase used in conjunction with the
+     * privateKey to authenticate.
+     *             
+     *           
+     */
+    private String passphrase;
+
+    /**
+     * 
+     *             
+     *             The permissions for files when they are created.
+     *             
+     *           
+     */
+    private String filePermissions;
+
+    /**
+     * 
+     *             
+     *             The permissions for directories when they are
+     * created.
+     *             
+     *           
+     */
+    private String directoryPermissions;
+
+    /**
+     * 
+     *             
+     *             Extra configuration for the transport layer.
+     *             
+     *           
+     */
+    private Object configuration;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Server
+     */
+    public Server clone()
+    {
+        try
+        {
+            Server copy = (Server) super.clone();
+
+            if ( this.configuration != null )
+            {
+                copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Server clone()
+
+    /**
+     * Get extra configuration for the transport layer.
+     * 
+     * @return Object
+     */
+    public Object getConfiguration()
+    {
+        return this.configuration;
+    } //-- Object getConfiguration()
+
+    /**
+     * Get the permissions for directories when they are created.
+     * 
+     * @return String
+     */
+    public String getDirectoryPermissions()
+    {
+        return this.directoryPermissions;
+    } //-- String getDirectoryPermissions()
+
+    /**
+     * Get the permissions for files when they are created.
+     * 
+     * @return String
+     */
+    public String getFilePermissions()
+    {
+        return this.filePermissions;
+    } //-- String getFilePermissions()
+
+    /**
+     * Get the passphrase used in conjunction with the privateKey
+     * to authenticate.
+     * 
+     * @return String
+     */
+    public String getPassphrase()
+    {
+        return this.passphrase;
+    } //-- String getPassphrase()
+
+    /**
+     * Get the password used in conjunction with the username to
+     * authenticate.
+     * 
+     * @return String
+     */
+    public String getPassword()
+    {
+        return this.password;
+    } //-- String getPassword()
+
+    /**
+     * Get the private key location used to authenticate.
+     * 
+     * @return String
+     */
+    public String getPrivateKey()
+    {
+        return this.privateKey;
+    } //-- String getPrivateKey()
+
+    /**
+     * Get the username used to authenticate.
+     * 
+     * @return String
+     */
+    public String getUsername()
+    {
+        return this.username;
+    } //-- String getUsername()
+
+    /**
+     * Set extra configuration for the transport layer.
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( Object configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( Object )
+
+    /**
+     * Set the permissions for directories when they are created.
+     * 
+     * @param directoryPermissions
+     */
+    public void setDirectoryPermissions( String directoryPermissions )
+    {
+        this.directoryPermissions = directoryPermissions;
+    } //-- void setDirectoryPermissions( String )
+
+    /**
+     * Set the permissions for files when they are created.
+     * 
+     * @param filePermissions
+     */
+    public void setFilePermissions( String filePermissions )
+    {
+        this.filePermissions = filePermissions;
+    } //-- void setFilePermissions( String )
+
+    /**
+     * Set the passphrase used in conjunction with the privateKey
+     * to authenticate.
+     * 
+     * @param passphrase
+     */
+    public void setPassphrase( String passphrase )
+    {
+        this.passphrase = passphrase;
+    } //-- void setPassphrase( String )
+
+    /**
+     * Set the password used in conjunction with the username to
+     * authenticate.
+     * 
+     * @param password
+     */
+    public void setPassword( String password )
+    {
+        this.password = password;
+    } //-- void setPassword( String )
+
+    /**
+     * Set the private key location used to authenticate.
+     * 
+     * @param privateKey
+     */
+    public void setPrivateKey( String privateKey )
+    {
+        this.privateKey = privateKey;
+    } //-- void setPrivateKey( String )
+
+    /**
+     * Set the username used to authenticate.
+     * 
+     * @param username
+     */
+    public void setUsername( String username )
+    {
+        this.username = username;
+    } //-- void setUsername( String )
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Settings.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Settings.java
new file mode 100644
index 0000000..505a4f9
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/Settings.java
@@ -0,0 +1,683 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         Root element of the user configuration file.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Settings
+    extends TrackableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             
+     *             The local repository.<br /><b>Default value
+     * is:</b> <tt>${user.home}/.m2/repository</tt>
+     *             
+     *           
+     */
+    private String localRepository;
+
+    /**
+     * 
+     *             
+     *             Whether Maven should attempt to interact with
+     * the user for input.
+     *             
+     *           
+     */
+    private boolean interactiveMode = true;
+
+    /**
+     * 
+     *             
+     *             Whether Maven should use the plugin-registry.xml
+     * file to manage plugin versions.
+     *             
+     *           
+     */
+    private boolean usePluginRegistry = false;
+
+    /**
+     * 
+     *             
+     *             Indicate whether maven should operate in offline
+     * mode full-time.
+     *             
+     *           
+     */
+    private boolean offline = false;
+
+    /**
+     * Field proxies.
+     */
+    private java.util.List<Proxy> proxies;
+
+    /**
+     * Field servers.
+     */
+    private java.util.List<Server> servers;
+
+    /**
+     * Field mirrors.
+     */
+    private java.util.List<Mirror> mirrors;
+
+    /**
+     * Field profiles.
+     */
+    private java.util.List<Profile> profiles;
+
+    /**
+     * Field activeProfiles.
+     */
+    private java.util.List<String> activeProfiles;
+
+    /**
+     * Field pluginGroups.
+     */
+    private java.util.List<String> pluginGroups;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addActiveProfile.
+     * 
+     * @param string
+     */
+    public void addActiveProfile( String string )
+    {
+        getActiveProfiles().add( string );
+    } //-- void addActiveProfile( String )
+
+    /**
+     * Method addMirror.
+     * 
+     * @param mirror
+     */
+    public void addMirror( Mirror mirror )
+    {
+        getMirrors().add( mirror );
+    } //-- void addMirror( Mirror )
+
+    /**
+     * Method addPluginGroup.
+     * 
+     * @param string
+     */
+    public void addPluginGroup( String string )
+    {
+        getPluginGroups().add( string );
+    } //-- void addPluginGroup( String )
+
+    /**
+     * Method addProfile.
+     * 
+     * @param profile
+     */
+    public void addProfile( Profile profile )
+    {
+        getProfiles().add( profile );
+    } //-- void addProfile( Profile )
+
+    /**
+     * Method addProxy.
+     * 
+     * @param proxy
+     */
+    public void addProxy( Proxy proxy )
+    {
+        getProxies().add( proxy );
+    } //-- void addProxy( Proxy )
+
+    /**
+     * Method addServer.
+     * 
+     * @param server
+     */
+    public void addServer( Server server )
+    {
+        getServers().add( server );
+    } //-- void addServer( Server )
+
+    /**
+     * Method clone.
+     * 
+     * @return Settings
+     */
+    public Settings clone()
+    {
+        try
+        {
+            Settings copy = (Settings) super.clone();
+
+            if ( this.proxies != null )
+            {
+                copy.proxies = new java.util.ArrayList<Proxy>();
+                for ( Proxy item : this.proxies )
+                {
+                    copy.proxies.add( ( (Proxy) item).clone() );
+                }
+            }
+
+            if ( this.servers != null )
+            {
+                copy.servers = new java.util.ArrayList<Server>();
+                for ( Server item : this.servers )
+                {
+                    copy.servers.add( ( (Server) item).clone() );
+                }
+            }
+
+            if ( this.mirrors != null )
+            {
+                copy.mirrors = new java.util.ArrayList<Mirror>();
+                for ( Mirror item : this.mirrors )
+                {
+                    copy.mirrors.add( ( (Mirror) item).clone() );
+                }
+            }
+
+            if ( this.profiles != null )
+            {
+                copy.profiles = new java.util.ArrayList<Profile>();
+                for ( Profile item : this.profiles )
+                {
+                    copy.profiles.add( ( (Profile) item).clone() );
+                }
+            }
+
+            if ( this.activeProfiles != null )
+            {
+                copy.activeProfiles = new java.util.ArrayList<String>();
+                copy.activeProfiles.addAll( this.activeProfiles );
+            }
+
+            if ( this.pluginGroups != null )
+            {
+                copy.pluginGroups = new java.util.ArrayList<String>();
+                copy.pluginGroups.addAll( this.pluginGroups );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Settings clone()
+
+    /**
+     * Method getActiveProfiles.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getActiveProfiles()
+    {
+        if ( this.activeProfiles == null )
+        {
+            this.activeProfiles = new java.util.ArrayList<String>();
+        }
+
+        return this.activeProfiles;
+    } //-- java.util.List<String> getActiveProfiles()
+
+    /**
+     * Get the local repository.<br /><b>Default value is:</b>
+     * <tt>${user.home}/.m2/repository</tt>
+     * 
+     * @return String
+     */
+    public String getLocalRepository()
+    {
+        return this.localRepository;
+    } //-- String getLocalRepository()
+
+    /**
+     * Method getMirrors.
+     * 
+     * @return List
+     */
+    public java.util.List<Mirror> getMirrors()
+    {
+        if ( this.mirrors == null )
+        {
+            this.mirrors = new java.util.ArrayList<Mirror>();
+        }
+
+        return this.mirrors;
+    } //-- java.util.List<Mirror> getMirrors()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method getPluginGroups.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getPluginGroups()
+    {
+        if ( this.pluginGroups == null )
+        {
+            this.pluginGroups = new java.util.ArrayList<String>();
+        }
+
+        return this.pluginGroups;
+    } //-- java.util.List<String> getPluginGroups()
+
+    /**
+     * Method getProfiles.
+     * 
+     * @return List
+     */
+    public java.util.List<Profile> getProfiles()
+    {
+        if ( this.profiles == null )
+        {
+            this.profiles = new java.util.ArrayList<Profile>();
+        }
+
+        return this.profiles;
+    } //-- java.util.List<Profile> getProfiles()
+
+    /**
+     * Method getProxies.
+     * 
+     * @return List
+     */
+    public java.util.List<Proxy> getProxies()
+    {
+        if ( this.proxies == null )
+        {
+            this.proxies = new java.util.ArrayList<Proxy>();
+        }
+
+        return this.proxies;
+    } //-- java.util.List<Proxy> getProxies()
+
+    /**
+     * Method getServers.
+     * 
+     * @return List
+     */
+    public java.util.List<Server> getServers()
+    {
+        if ( this.servers == null )
+        {
+            this.servers = new java.util.ArrayList<Server>();
+        }
+
+        return this.servers;
+    } //-- java.util.List<Server> getServers()
+
+    /**
+     * Get whether Maven should attempt to interact with the user
+     * for input.
+     * 
+     * @return boolean
+     */
+    public boolean isInteractiveMode()
+    {
+        return this.interactiveMode;
+    } //-- boolean isInteractiveMode()
+
+    /**
+     * Get indicate whether maven should operate in offline mode
+     * full-time.
+     * 
+     * @return boolean
+     */
+    public boolean isOffline()
+    {
+        return this.offline;
+    } //-- boolean isOffline()
+
+    /**
+     * Get whether Maven should use the plugin-registry.xml file to
+     * manage plugin versions.
+     * 
+     * @return boolean
+     */
+    public boolean isUsePluginRegistry()
+    {
+        return this.usePluginRegistry;
+    } //-- boolean isUsePluginRegistry()
+
+    /**
+     * Method removeActiveProfile.
+     * 
+     * @param string
+     */
+    public void removeActiveProfile( String string )
+    {
+        getActiveProfiles().remove( string );
+    } //-- void removeActiveProfile( String )
+
+    /**
+     * Method removeMirror.
+     * 
+     * @param mirror
+     */
+    public void removeMirror( Mirror mirror )
+    {
+        getMirrors().remove( mirror );
+    } //-- void removeMirror( Mirror )
+
+    /**
+     * Method removePluginGroup.
+     * 
+     * @param string
+     */
+    public void removePluginGroup( String string )
+    {
+        getPluginGroups().remove( string );
+    } //-- void removePluginGroup( String )
+
+    /**
+     * Method removeProfile.
+     * 
+     * @param profile
+     */
+    public void removeProfile( Profile profile )
+    {
+        getProfiles().remove( profile );
+    } //-- void removeProfile( Profile )
+
+    /**
+     * Method removeProxy.
+     * 
+     * @param proxy
+     */
+    public void removeProxy( Proxy proxy )
+    {
+        getProxies().remove( proxy );
+    } //-- void removeProxy( Proxy )
+
+    /**
+     * Method removeServer.
+     * 
+     * @param server
+     */
+    public void removeServer( Server server )
+    {
+        getServers().remove( server );
+    } //-- void removeServer( Server )
+
+    /**
+     * Set list of manually-activated build profiles, specified in
+     * the order in which
+     *             they should be applied.
+     * 
+     * @param activeProfiles
+     */
+    public void setActiveProfiles( java.util.List<String> activeProfiles )
+    {
+        this.activeProfiles = activeProfiles;
+    } //-- void setActiveProfiles( java.util.List )
+
+    /**
+     * Set whether Maven should attempt to interact with the user
+     * for input.
+     * 
+     * @param interactiveMode
+     */
+    public void setInteractiveMode( boolean interactiveMode )
+    {
+        this.interactiveMode = interactiveMode;
+    } //-- void setInteractiveMode( boolean )
+
+    /**
+     * Set the local repository.<br /><b>Default value is:</b>
+     * <tt>${user.home}/.m2/repository</tt>
+     * 
+     * @param localRepository
+     */
+    public void setLocalRepository( String localRepository )
+    {
+        this.localRepository = localRepository;
+    } //-- void setLocalRepository( String )
+
+    /**
+     * Set configuration of download mirrors for repositories.
+     * 
+     * @param mirrors
+     */
+    public void setMirrors( java.util.List<Mirror> mirrors )
+    {
+        this.mirrors = mirrors;
+    } //-- void setMirrors( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set indicate whether maven should operate in offline mode
+     * full-time.
+     * 
+     * @param offline
+     */
+    public void setOffline( boolean offline )
+    {
+        this.offline = offline;
+    } //-- void setOffline( boolean )
+
+    /**
+     * Set list of groupIds to search for a plugin when that plugin
+     *             groupId is not explicitly provided.
+     * 
+     * @param pluginGroups
+     */
+    public void setPluginGroups( java.util.List<String> pluginGroups )
+    {
+        this.pluginGroups = pluginGroups;
+    } //-- void setPluginGroups( java.util.List )
+
+    /**
+     * Set configuration of build profiles for adjusting the build
+     *             according to environmental parameters.
+     * 
+     * @param profiles
+     */
+    public void setProfiles( java.util.List<Profile> profiles )
+    {
+        this.profiles = profiles;
+    } //-- void setProfiles( java.util.List )
+
+    /**
+     * Set configuration for different proxy profiles. Multiple
+     * proxy profiles
+     *             might come in handy for anyone working from a
+     * notebook or other
+     *             mobile platform, to enable easy switching of
+     * entire proxy
+     *             configurations by simply specifying the profile
+     * id, again either from
+     *             the command line or from the defaults section
+     * below.
+     * 
+     * @param proxies
+     */
+    public void setProxies( java.util.List<Proxy> proxies )
+    {
+        this.proxies = proxies;
+    } //-- void setProxies( java.util.List )
+
+    /**
+     * Set configuration of server-specific settings, mainly
+     * authentication
+     *             method. This allows configuration of
+     * authentication on a per-server
+     *             basis.
+     * 
+     * @param servers
+     */
+    public void setServers( java.util.List<Server> servers )
+    {
+        this.servers = servers;
+    } //-- void setServers( java.util.List )
+
+    /**
+     * Set whether Maven should use the plugin-registry.xml file to
+     * manage plugin versions.
+     * 
+     * @param usePluginRegistry
+     */
+    public void setUsePluginRegistry( boolean usePluginRegistry )
+    {
+        this.usePluginRegistry = usePluginRegistry;
+    } //-- void setUsePluginRegistry( boolean )
+
+    
+            
+    public Boolean getInteractiveMode()
+    {
+        return Boolean.valueOf( isInteractiveMode() );
+    }
+
+    private Proxy activeProxy;
+
+    /**
+     * Reset the <code>activeProxy</code> field to <code>null</code>
+     */
+    public void flushActiveProxy()
+    {
+        this.activeProxy = null;
+    }
+
+    /**
+     * @return the first active proxy
+     */
+    public synchronized Proxy getActiveProxy()
+    {
+        if ( activeProxy == null )
+        {
+            java.util.List<Proxy> proxies = getProxies();
+            if ( proxies != null && !proxies.isEmpty() )
+            {
+                for ( Proxy proxy : proxies )
+                {
+                    if ( proxy.isActive() )
+                    {
+                        activeProxy = proxy;
+                        break;
+                    }
+                }
+            }
+        }
+
+        return activeProxy;
+    }
+
+    public Server getServer( String serverId )
+    {
+        Server match = null;
+
+        java.util.List<Server> servers = getServers();
+        if ( servers != null && serverId != null )
+        {
+            for ( Server server : servers )
+            {
+                if ( serverId.equals( server.getId() ) )
+                {
+                    match = server;
+                    break;
+                }
+            }
+        }
+
+        return match;
+    }
+
+    @Deprecated
+    public Mirror getMirrorOf( String repositoryId )
+    {
+        Mirror match = null;
+
+        java.util.List<Mirror> mirrors = getMirrors();
+        if ( mirrors != null && repositoryId != null )
+        {
+            for ( Mirror mirror : mirrors )
+            {
+                if ( repositoryId.equals( mirror.getMirrorOf() ) )
+                {
+                    match = mirror;
+                    break;
+                }
+            }
+        }
+
+        return match;
+    }
+
+    private java.util.Map<String, Profile> profileMap;
+
+    /**
+     * Reset the <code>profileMap</code> field to <code>null</code>
+     */
+    public void flushProfileMap()
+    {
+        this.profileMap = null;
+    }
+
+    /**
+     * @return a Map of profiles field with <code>Profile#getId()</code> as key
+     * @see org.apache.maven.settings.Profile#getId()
+     */
+    public java.util.Map<String, Profile> getProfilesAsMap()
+    {
+        if ( profileMap == null )
+        {
+            profileMap = new java.util.LinkedHashMap<String, Profile>();
+
+            if ( getProfiles() != null )
+            {
+                for ( Profile profile : getProfiles() )
+                {
+                    profileMap.put( profile.getId(), profile );
+                }
+            }
+        }
+
+        return profileMap;
+    }
+            
+          
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/TrackableBase.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/TrackableBase.java
new file mode 100644
index 0000000..75c5d28
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/TrackableBase.java
@@ -0,0 +1,77 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings;
+
+/**
+ * 
+ *         common base class that contains code to track the source
+ * for
+ *         this instance (USER|GLOBAL)
+ *       .
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class TrackableBase
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return TrackableBase
+     */
+    public TrackableBase clone()
+    {
+        try
+        {
+            TrackableBase copy = (TrackableBase) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- TrackableBase clone()
+
+    
+            
+    public static final String USER_LEVEL = "user-level";
+    public static final String GLOBAL_LEVEL = "global-level";
+
+    private String sourceLevel = USER_LEVEL;
+    private boolean sourceLevelSet = false;
+
+    public void setSourceLevel( String sourceLevel )
+    {
+        if ( sourceLevelSet )
+        {
+            throw new IllegalStateException( "Cannot reset sourceLevel attribute; it is already set to: " + sourceLevel );
+        }
+        else if ( !( USER_LEVEL.equals( sourceLevel ) || GLOBAL_LEVEL.equals( sourceLevel ) ) )
+        {
+            throw new IllegalArgumentException( "sourceLevel must be one of: {" + USER_LEVEL + "," + GLOBAL_LEVEL + "}" );
+        }
+        else
+        {
+            this.sourceLevel = sourceLevel;
+            this.sourceLevelSet = true;
+        }
+    }
+
+    public String getSourceLevel()
+    {
+        return sourceLevel;
+    }
+            
+          
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java
new file mode 100644
index 0000000..11c6a46
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java
@@ -0,0 +1,1568 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.text.DateFormat;
+import org.apache.maven.settings.Activation;
+import org.apache.maven.settings.ActivationFile;
+import org.apache.maven.settings.ActivationOS;
+import org.apache.maven.settings.ActivationProperty;
+import org.apache.maven.settings.IdentifiableBase;
+import org.apache.maven.settings.Mirror;
+import org.apache.maven.settings.Profile;
+import org.apache.maven.settings.Proxy;
+import org.apache.maven.settings.Repository;
+import org.apache.maven.settings.RepositoryBase;
+import org.apache.maven.settings.RepositoryPolicy;
+import org.apache.maven.settings.Server;
+import org.apache.maven.settings.Settings;
+import org.apache.maven.settings.TrackableBase;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+/**
+ * Class SettingsXpp3Reader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class SettingsXpp3Reader
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * If set the parser will be loaded with all single characters
+     * from the XHTML specification.
+     * The entities used:
+     * <ul>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent</li>
+     * <li>http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</li>
+     * </ul>
+     */
+    private boolean addDefaultEntities = true;
+
+    /**
+     * Field contentTransformer.
+     */
+    public final ContentTransformer contentTransformer;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public SettingsXpp3Reader()
+    {
+        this( new ContentTransformer()
+        {
+            public String transform( String source, String fieldName )
+            {
+                return source;
+            }
+        } );
+    } //-- org.apache.maven.settings.io.xpp3.SettingsXpp3Reader()
+
+    public SettingsXpp3Reader(ContentTransformer contentTransformer)
+    {
+        this.contentTransformer = contentTransformer;
+    } //-- org.apache.maven.settings.io.xpp3.SettingsXpp3Reader(ContentTransformer)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param parser
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set parsed )
+        throws XmlPullParserException
+    {
+        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownAttribute.
+     * 
+     * @param parser
+     * @param strict
+     * @param tagName
+     * @param attribute
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
+        }
+    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param parser
+     * @param strict
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    private void checkUnknownElement( XmlPullParser parser, boolean strict )
+        throws XmlPullParserException, IOException
+    {
+        if ( strict )
+        {
+            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
+        }
+
+        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
+        {
+            int eventType = parser.next();
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( eventType == XmlPullParser.END_TAG )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XmlPullParser, boolean )
+
+    /**
+     * Returns the state of the "add default entities" flag.
+     * 
+     * @return boolean
+     */
+    public boolean getAddDefaultEntities()
+    {
+        return addDefaultEntities;
+    } //-- boolean getAddDefaultEntities()
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getBooleanValue( s, attribute, parser, null );
+    } //-- boolean getBooleanValue( String, String, XmlPullParser )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param defaultValue
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XmlPullParser parser, String defaultValue )
+        throws XmlPullParserException
+    {
+        if ( s != null && s.length() != 0 )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        if ( defaultValue != null )
+        {
+            return Boolean.valueOf( defaultValue ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        return getDateValue( s, attribute, null, parser );
+    } //-- java.util.Date getDateValue( String, String, XmlPullParser )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param parser
+     * @param dateFormat
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XmlPullParser parser )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XmlPullParserException( e.getMessage(), parser, e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XmlPullParser )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param parser
+     * @param attribute
+     * @throws XmlPullParserException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XmlPullParser parser, boolean strict )
+        throws XmlPullParserException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XmlPullParser, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method interpolatedTrimmed.
+     * 
+     * @param value
+     * @param context
+     * @return String
+     */
+    private String interpolatedTrimmed( String value, String context )
+    {
+        return getTrimmedValue( contentTransformer.transform( value, context ) );
+    } //-- String interpolatedTrimmed( String, String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param parser
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return int
+     */
+    private int nextTag( XmlPullParser parser )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.next();
+        if ( eventType == XmlPullParser.TEXT )
+        {
+            eventType = parser.next();
+        }
+        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
+        {
+            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
+        }
+        return eventType;
+    } //-- int nextTag( XmlPullParser )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Settings
+     */
+    public Settings read( Reader reader, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        XmlPullParser parser = addDefaultEntities ? new MXParser(EntityReplacementMap.defaultEntityReplacementMap) : new MXParser( );
+
+        parser.setInput( reader );
+
+
+        return read( parser, strict );
+    } //-- Settings read( Reader, boolean )
+
+    /**
+     * @see ReaderFactory#newXmlReader
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Settings
+     */
+    public Settings read( Reader reader )
+        throws IOException, XmlPullParserException
+    {
+        return read( reader, true );
+    } //-- Settings read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Settings
+     */
+    public Settings read( InputStream in, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ), strict );
+    } //-- Settings read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param in
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Settings
+     */
+    public Settings read( InputStream in )
+        throws IOException, XmlPullParserException
+    {
+        return read( ReaderFactory.newXmlReader( in ) );
+    } //-- Settings read( InputStream )
+
+    /**
+     * Method parseActivation.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Activation
+     */
+    private Activation parseActivation( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Activation activation = new Activation();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "activeByDefault", null, parsed ) )
+            {
+                activation.setActiveByDefault( getBooleanValue( interpolatedTrimmed( parser.nextText(), "activeByDefault" ), "activeByDefault", parser, "false" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "jdk", null, parsed ) )
+            {
+                activation.setJdk( interpolatedTrimmed( parser.nextText(), "jdk" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "os", null, parsed ) )
+            {
+                activation.setOs( parseActivationOS( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "property", null, parsed ) )
+            {
+                activation.setProperty( parseActivationProperty( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "file", null, parsed ) )
+            {
+                activation.setFile( parseActivationFile( parser, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activation;
+    } //-- Activation parseActivation( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationFile.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationFile
+     */
+    private ActivationFile parseActivationFile( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationFile activationFile = new ActivationFile();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "missing", null, parsed ) )
+            {
+                activationFile.setMissing( interpolatedTrimmed( parser.nextText(), "missing" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "exists", null, parsed ) )
+            {
+                activationFile.setExists( interpolatedTrimmed( parser.nextText(), "exists" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationFile;
+    } //-- ActivationFile parseActivationFile( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationOS.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationOS
+     */
+    private ActivationOS parseActivationOS( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationOS activationOS = new ActivationOS();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                activationOS.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "family", null, parsed ) )
+            {
+                activationOS.setFamily( interpolatedTrimmed( parser.nextText(), "family" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "arch", null, parsed ) )
+            {
+                activationOS.setArch( interpolatedTrimmed( parser.nextText(), "arch" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
+            {
+                activationOS.setVersion( interpolatedTrimmed( parser.nextText(), "version" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationOS;
+    } //-- ActivationOS parseActivationOS( XmlPullParser, boolean )
+
+    /**
+     * Method parseActivationProperty.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return ActivationProperty
+     */
+    private ActivationProperty parseActivationProperty( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        ActivationProperty activationProperty = new ActivationProperty();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                activationProperty.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "value", null, parsed ) )
+            {
+                activationProperty.setValue( interpolatedTrimmed( parser.nextText(), "value" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return activationProperty;
+    } //-- ActivationProperty parseActivationProperty( XmlPullParser, boolean )
+
+    /**
+     * Method parseIdentifiableBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return IdentifiableBase
+     */
+    private IdentifiableBase parseIdentifiableBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        IdentifiableBase identifiableBase = new IdentifiableBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                identifiableBase.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return identifiableBase;
+    } //-- IdentifiableBase parseIdentifiableBase( XmlPullParser, boolean )
+
+    /**
+     * Method parseMirror.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Mirror
+     */
+    private Mirror parseMirror( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Mirror mirror = new Mirror();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "mirrorOf", null, parsed ) )
+            {
+                mirror.setMirrorOf( interpolatedTrimmed( parser.nextText(), "mirrorOf" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                mirror.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                mirror.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                mirror.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "mirrorOfLayouts", null, parsed ) )
+            {
+                mirror.setMirrorOfLayouts( interpolatedTrimmed( parser.nextText(), "mirrorOfLayouts" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                mirror.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return mirror;
+    } //-- Mirror parseMirror( XmlPullParser, boolean )
+
+    /**
+     * Method parseProfile.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Profile
+     */
+    private Profile parseProfile( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Profile profile = new Profile();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "activation", null, parsed ) )
+            {
+                profile.setActivation( parseActivation( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
+            {
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    String key = parser.getName();
+                    String value = parser.nextText().trim();
+                    profile.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setRepositories( repositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "repository".equals( parser.getName() ) )
+                    {
+                        repositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
+            {
+                java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();
+                profile.setPluginRepositories( pluginRepositories );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginRepository".equals( parser.getName() ) )
+                    {
+                        pluginRepositories.add( parseRepository( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                profile.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return profile;
+    } //-- Profile parseProfile( XmlPullParser, boolean )
+
+    /**
+     * Method parseProxy.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Proxy
+     */
+    private Proxy parseProxy( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Proxy proxy = new Proxy();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "active", null, parsed ) )
+            {
+                proxy.setActive( getBooleanValue( interpolatedTrimmed( parser.nextText(), "active" ), "active", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "protocol", null, parsed ) )
+            {
+                proxy.setProtocol( interpolatedTrimmed( parser.nextText(), "protocol" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "username", null, parsed ) )
+            {
+                proxy.setUsername( interpolatedTrimmed( parser.nextText(), "username" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "password", null, parsed ) )
+            {
+                proxy.setPassword( interpolatedTrimmed( parser.nextText(), "password" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "port", null, parsed ) )
+            {
+                proxy.setPort( getIntegerValue( interpolatedTrimmed( parser.nextText(), "port" ), "port", parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "host", null, parsed ) )
+            {
+                proxy.setHost( interpolatedTrimmed( parser.nextText(), "host" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "nonProxyHosts", null, parsed ) )
+            {
+                proxy.setNonProxyHosts( interpolatedTrimmed( parser.nextText(), "nonProxyHosts" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                proxy.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return proxy;
+    } //-- Proxy parseProxy( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepository.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Repository
+     */
+    private Repository parseRepository( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Repository repository = new Repository();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
+            {
+                repository.setReleases( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
+            {
+                repository.setSnapshots( parseRepositoryPolicy( parser, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                repository.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                repository.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                repository.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                repository.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repository;
+    } //-- Repository parseRepository( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepositoryBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryBase
+     */
+    private RepositoryBase parseRepositoryBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryBase repositoryBase = new RepositoryBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                repositoryBase.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
+            {
+                repositoryBase.setName( interpolatedTrimmed( parser.nextText(), "name" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
+            {
+                repositoryBase.setUrl( interpolatedTrimmed( parser.nextText(), "url" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
+            {
+                repositoryBase.setLayout( interpolatedTrimmed( parser.nextText(), "layout" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryBase;
+    } //-- RepositoryBase parseRepositoryBase( XmlPullParser, boolean )
+
+    /**
+     * Method parseRepositoryPolicy.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return RepositoryPolicy
+     */
+    private RepositoryPolicy parseRepositoryPolicy( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        RepositoryPolicy repositoryPolicy = new RepositoryPolicy();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "enabled", null, parsed ) )
+            {
+                repositoryPolicy.setEnabled( getBooleanValue( interpolatedTrimmed( parser.nextText(), "enabled" ), "enabled", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "updatePolicy", null, parsed ) )
+            {
+                repositoryPolicy.setUpdatePolicy( interpolatedTrimmed( parser.nextText(), "updatePolicy" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "checksumPolicy", null, parsed ) )
+            {
+                repositoryPolicy.setChecksumPolicy( interpolatedTrimmed( parser.nextText(), "checksumPolicy" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return repositoryPolicy;
+    } //-- RepositoryPolicy parseRepositoryPolicy( XmlPullParser, boolean )
+
+    /**
+     * Method parseServer.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Server
+     */
+    private Server parseServer( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Server server = new Server();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "username", null, parsed ) )
+            {
+                server.setUsername( interpolatedTrimmed( parser.nextText(), "username" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "password", null, parsed ) )
+            {
+                server.setPassword( interpolatedTrimmed( parser.nextText(), "password" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "privateKey", null, parsed ) )
+            {
+                server.setPrivateKey( interpolatedTrimmed( parser.nextText(), "privateKey" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "passphrase", null, parsed ) )
+            {
+                server.setPassphrase( interpolatedTrimmed( parser.nextText(), "passphrase" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "filePermissions", null, parsed ) )
+            {
+                server.setFilePermissions( interpolatedTrimmed( parser.nextText(), "filePermissions" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "directoryPermissions", null, parsed ) )
+            {
+                server.setDirectoryPermissions( interpolatedTrimmed( parser.nextText(), "directoryPermissions" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
+            {
+                server.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
+            {
+                server.setId( interpolatedTrimmed( parser.nextText(), "id" ) );
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return server;
+    } //-- Server parseServer( XmlPullParser, boolean )
+
+    /**
+     * Method parseSettings.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Settings
+     */
+    private Settings parseSettings( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        Settings settings = new Settings();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else if ( "xmlns".equals( name ) )
+            {
+                // ignore xmlns attribute in root class, which is a reserved attribute name
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            if ( checkFieldWithDuplicate( parser, "localRepository", null, parsed ) )
+            {
+                settings.setLocalRepository( interpolatedTrimmed( parser.nextText(), "localRepository" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "interactiveMode", null, parsed ) )
+            {
+                settings.setInteractiveMode( getBooleanValue( interpolatedTrimmed( parser.nextText(), "interactiveMode" ), "interactiveMode", parser, "true" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "usePluginRegistry", null, parsed ) )
+            {
+                settings.setUsePluginRegistry( getBooleanValue( interpolatedTrimmed( parser.nextText(), "usePluginRegistry" ), "usePluginRegistry", parser, "false" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "offline", null, parsed ) )
+            {
+                settings.setOffline( getBooleanValue( interpolatedTrimmed( parser.nextText(), "offline" ), "offline", parser, "false" ) );
+            }
+            else if ( checkFieldWithDuplicate( parser, "proxies", null, parsed ) )
+            {
+                java.util.List proxies = new java.util.ArrayList/*<Proxy>*/();
+                settings.setProxies( proxies );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "proxy".equals( parser.getName() ) )
+                    {
+                        proxies.add( parseProxy( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "servers", null, parsed ) )
+            {
+                java.util.List servers = new java.util.ArrayList/*<Server>*/();
+                settings.setServers( servers );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "server".equals( parser.getName() ) )
+                    {
+                        servers.add( parseServer( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "mirrors", null, parsed ) )
+            {
+                java.util.List mirrors = new java.util.ArrayList/*<Mirror>*/();
+                settings.setMirrors( mirrors );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "mirror".equals( parser.getName() ) )
+                    {
+                        mirrors.add( parseMirror( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "profiles", null, parsed ) )
+            {
+                java.util.List profiles = new java.util.ArrayList/*<Profile>*/();
+                settings.setProfiles( profiles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "profile".equals( parser.getName() ) )
+                    {
+                        profiles.add( parseProfile( parser, strict ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "activeProfiles", null, parsed ) )
+            {
+                java.util.List activeProfiles = new java.util.ArrayList/*<String>*/();
+                settings.setActiveProfiles( activeProfiles );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "activeProfile".equals( parser.getName() ) )
+                    {
+                        activeProfiles.add( interpolatedTrimmed( parser.nextText(), "activeProfiles" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( parser, "pluginGroups", null, parsed ) )
+            {
+                java.util.List pluginGroups = new java.util.ArrayList/*<String>*/();
+                settings.setPluginGroups( pluginGroups );
+                while ( parser.nextTag() == XmlPullParser.START_TAG )
+                {
+                    if ( "pluginGroup".equals( parser.getName() ) )
+                    {
+                        pluginGroups.add( interpolatedTrimmed( parser.nextText(), "pluginGroups" ) );
+                    }
+                    else
+                    {
+                        checkUnknownElement( parser, strict );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( parser, strict );
+            }
+        }
+        return settings;
+    } //-- Settings parseSettings( XmlPullParser, boolean )
+
+    /**
+     * Method parseTrackableBase.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return TrackableBase
+     */
+    private TrackableBase parseTrackableBase( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        String tagName = parser.getName();
+        TrackableBase trackableBase = new TrackableBase();
+        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
+        {
+            String name = parser.getAttributeName( i );
+            String value = parser.getAttributeValue( i );
+
+            if ( name.indexOf( ':' ) >= 0 )
+            {
+                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
+            }
+            else
+            {
+                checkUnknownAttribute( parser, name, tagName, strict );
+            }
+        }
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
+        {
+            checkUnknownElement( parser, strict );
+        }
+        return trackableBase;
+    } //-- TrackableBase parseTrackableBase( XmlPullParser, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param parser
+     * @param strict
+     * @throws IOException
+     * @throws XmlPullParserException
+     * @return Settings
+     */
+    private Settings read( XmlPullParser parser, boolean strict )
+        throws IOException, XmlPullParserException
+    {
+        int eventType = parser.getEventType();
+        while ( eventType != XmlPullParser.END_DOCUMENT )
+        {
+            if ( eventType == XmlPullParser.START_TAG )
+            {
+                if ( strict && ! "settings".equals( parser.getName() ) )
+                {
+                    throw new XmlPullParserException( "Expected root element 'settings' but found '" + parser.getName() + "'", parser, null );
+                }
+                Settings settings = parseSettings( parser, strict );
+                settings.setModelEncoding( parser.getInputEncoding() );
+                return settings;
+            }
+            eventType = parser.next();
+        }
+        throw new XmlPullParserException( "Expected root element 'settings' but found no element at all: invalid XML document", parser, null );
+    } //-- Settings read( XmlPullParser, boolean )
+
+    /**
+     * Sets the state of the "add default entities" flag.
+     * 
+     * @param addDefaultEntities
+     */
+    public void setAddDefaultEntities( boolean addDefaultEntities )
+    {
+        this.addDefaultEntities = addDefaultEntities;
+    } //-- void setAddDefaultEntities( boolean )
+
+    public static interface ContentTransformer
+{
+    /**
+     * Interpolate the value read from the xpp3 document
+     * @param source The source value
+     * @param fieldName A description of the field being interpolated. The implementation may use this to
+     *                           log stuff.
+     * @return The interpolated value.
+     */
+    String transform( String source, String fieldName );
+}
+
+}
diff --git a/maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java
new file mode 100644
index 0000000..a630544
--- /dev/null
+++ b/maven-settings/target/generated-sources/modello/org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java
@@ -0,0 +1,618 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.3,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.apache.maven.settings.io.xpp3;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Iterator;
+import org.apache.maven.settings.Activation;
+import org.apache.maven.settings.ActivationFile;
+import org.apache.maven.settings.ActivationOS;
+import org.apache.maven.settings.ActivationProperty;
+import org.apache.maven.settings.IdentifiableBase;
+import org.apache.maven.settings.Mirror;
+import org.apache.maven.settings.Profile;
+import org.apache.maven.settings.Proxy;
+import org.apache.maven.settings.Repository;
+import org.apache.maven.settings.RepositoryBase;
+import org.apache.maven.settings.RepositoryPolicy;
+import org.apache.maven.settings.Server;
+import org.apache.maven.settings.Settings;
+import org.apache.maven.settings.TrackableBase;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.codehaus.plexus.util.xml.pull.MXSerializer;
+import org.codehaus.plexus.util.xml.pull.XmlSerializer;
+
+/**
+ * Class SettingsXpp3Writer.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class SettingsXpp3Writer
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field NAMESPACE.
+     */
+    private static final String NAMESPACE = null;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param settings
+     * @throws java.io.IOException
+     */
+    public void write( Writer writer, Settings settings )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( writer );
+        serializer.startDocument( settings.getModelEncoding(), null );
+        writeSettings( settings, "settings", serializer );
+        serializer.endDocument();
+    } //-- void write( Writer, Settings )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param settings
+     * @throws java.io.IOException
+     */
+    public void write( OutputStream stream, Settings settings )
+        throws java.io.IOException
+    {
+        XmlSerializer serializer = new MXSerializer();
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "  " );
+        serializer.setProperty( "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n" );
+        serializer.setOutput( stream, settings.getModelEncoding() );
+        serializer.startDocument( settings.getModelEncoding(), null );
+        writeSettings( settings, "settings", serializer );
+        serializer.endDocument();
+    } //-- void write( OutputStream, Settings )
+
+    /**
+     * Method writeActivation.
+     * 
+     * @param activation
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivation( Activation activation, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activation.isActiveByDefault() != false )
+        {
+            serializer.startTag( NAMESPACE, "activeByDefault" ).text( String.valueOf( activation.isActiveByDefault() ) ).endTag( NAMESPACE, "activeByDefault" );
+        }
+        if ( activation.getJdk() != null )
+        {
+            serializer.startTag( NAMESPACE, "jdk" ).text( activation.getJdk() ).endTag( NAMESPACE, "jdk" );
+        }
+        if ( activation.getOs() != null )
+        {
+            writeActivationOS( (ActivationOS) activation.getOs(), "os", serializer );
+        }
+        if ( activation.getProperty() != null )
+        {
+            writeActivationProperty( (ActivationProperty) activation.getProperty(), "property", serializer );
+        }
+        if ( activation.getFile() != null )
+        {
+            writeActivationFile( (ActivationFile) activation.getFile(), "file", serializer );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivation( Activation, String, XmlSerializer )
+
+    /**
+     * Method writeActivationFile.
+     * 
+     * @param activationFile
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationFile( ActivationFile activationFile, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationFile.getMissing() != null )
+        {
+            serializer.startTag( NAMESPACE, "missing" ).text( activationFile.getMissing() ).endTag( NAMESPACE, "missing" );
+        }
+        if ( activationFile.getExists() != null )
+        {
+            serializer.startTag( NAMESPACE, "exists" ).text( activationFile.getExists() ).endTag( NAMESPACE, "exists" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationFile( ActivationFile, String, XmlSerializer )
+
+    /**
+     * Method writeActivationOS.
+     * 
+     * @param activationOS
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationOS( ActivationOS activationOS, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationOS.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( activationOS.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( activationOS.getFamily() != null )
+        {
+            serializer.startTag( NAMESPACE, "family" ).text( activationOS.getFamily() ).endTag( NAMESPACE, "family" );
+        }
+        if ( activationOS.getArch() != null )
+        {
+            serializer.startTag( NAMESPACE, "arch" ).text( activationOS.getArch() ).endTag( NAMESPACE, "arch" );
+        }
+        if ( activationOS.getVersion() != null )
+        {
+            serializer.startTag( NAMESPACE, "version" ).text( activationOS.getVersion() ).endTag( NAMESPACE, "version" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationOS( ActivationOS, String, XmlSerializer )
+
+    /**
+     * Method writeActivationProperty.
+     * 
+     * @param activationProperty
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeActivationProperty( ActivationProperty activationProperty, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( activationProperty.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( activationProperty.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( activationProperty.getValue() != null )
+        {
+            serializer.startTag( NAMESPACE, "value" ).text( activationProperty.getValue() ).endTag( NAMESPACE, "value" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeActivationProperty( ActivationProperty, String, XmlSerializer )
+
+    /**
+     * Method writeIdentifiableBase.
+     * 
+     * @param identifiableBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeIdentifiableBase( IdentifiableBase identifiableBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( ( identifiableBase.getId() != null ) && !identifiableBase.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( identifiableBase.getId() ).endTag( NAMESPACE, "id" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeIdentifiableBase( IdentifiableBase, String, XmlSerializer )
+
+    /**
+     * Method writeMirror.
+     * 
+     * @param mirror
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeMirror( Mirror mirror, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( mirror.getMirrorOf() != null )
+        {
+            serializer.startTag( NAMESPACE, "mirrorOf" ).text( mirror.getMirrorOf() ).endTag( NAMESPACE, "mirrorOf" );
+        }
+        if ( mirror.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( mirror.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( mirror.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( mirror.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( mirror.getLayout() != null ) && !mirror.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( mirror.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        if ( ( mirror.getMirrorOfLayouts() != null ) && !mirror.getMirrorOfLayouts().equals( "default,legacy" ) )
+        {
+            serializer.startTag( NAMESPACE, "mirrorOfLayouts" ).text( mirror.getMirrorOfLayouts() ).endTag( NAMESPACE, "mirrorOfLayouts" );
+        }
+        if ( ( mirror.getId() != null ) && !mirror.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( mirror.getId() ).endTag( NAMESPACE, "id" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeMirror( Mirror, String, XmlSerializer )
+
+    /**
+     * Method writeProfile.
+     * 
+     * @param profile
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeProfile( Profile profile, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( profile.getActivation() != null )
+        {
+            writeActivation( (Activation) profile.getActivation(), "activation", serializer );
+        }
+        if ( ( profile.getProperties() != null ) && ( profile.getProperties().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "properties" );
+            for ( Iterator iter = profile.getProperties().keySet().iterator(); iter.hasNext(); )
+            {
+                String key = (String) iter.next();
+                String value = (String) profile.getProperties().get( key );
+                serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );
+            }
+            serializer.endTag( NAMESPACE, "properties" );
+        }
+        if ( ( profile.getRepositories() != null ) && ( profile.getRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "repositories" );
+            for ( Iterator iter = profile.getRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "repository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "repositories" );
+        }
+        if ( ( profile.getPluginRepositories() != null ) && ( profile.getPluginRepositories().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "pluginRepositories" );
+            for ( Iterator iter = profile.getPluginRepositories().iterator(); iter.hasNext(); )
+            {
+                Repository o = (Repository) iter.next();
+                writeRepository( o, "pluginRepository", serializer );
+            }
+            serializer.endTag( NAMESPACE, "pluginRepositories" );
+        }
+        if ( ( profile.getId() != null ) && !profile.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( profile.getId() ).endTag( NAMESPACE, "id" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeProfile( Profile, String, XmlSerializer )
+
+    /**
+     * Method writeProxy.
+     * 
+     * @param proxy
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeProxy( Proxy proxy, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( proxy.isActive() != true )
+        {
+            serializer.startTag( NAMESPACE, "active" ).text( String.valueOf( proxy.isActive() ) ).endTag( NAMESPACE, "active" );
+        }
+        if ( ( proxy.getProtocol() != null ) && !proxy.getProtocol().equals( "http" ) )
+        {
+            serializer.startTag( NAMESPACE, "protocol" ).text( proxy.getProtocol() ).endTag( NAMESPACE, "protocol" );
+        }
+        if ( proxy.getUsername() != null )
+        {
+            serializer.startTag( NAMESPACE, "username" ).text( proxy.getUsername() ).endTag( NAMESPACE, "username" );
+        }
+        if ( proxy.getPassword() != null )
+        {
+            serializer.startTag( NAMESPACE, "password" ).text( proxy.getPassword() ).endTag( NAMESPACE, "password" );
+        }
+        if ( proxy.getPort() != 8080 )
+        {
+            serializer.startTag( NAMESPACE, "port" ).text( String.valueOf( proxy.getPort() ) ).endTag( NAMESPACE, "port" );
+        }
+        if ( proxy.getHost() != null )
+        {
+            serializer.startTag( NAMESPACE, "host" ).text( proxy.getHost() ).endTag( NAMESPACE, "host" );
+        }
+        if ( proxy.getNonProxyHosts() != null )
+        {
+            serializer.startTag( NAMESPACE, "nonProxyHosts" ).text( proxy.getNonProxyHosts() ).endTag( NAMESPACE, "nonProxyHosts" );
+        }
+        if ( ( proxy.getId() != null ) && !proxy.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( proxy.getId() ).endTag( NAMESPACE, "id" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeProxy( Proxy, String, XmlSerializer )
+
+    /**
+     * Method writeRepository.
+     * 
+     * @param repository
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepository( Repository repository, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repository.getReleases() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) repository.getReleases(), "releases", serializer );
+        }
+        if ( repository.getSnapshots() != null )
+        {
+            writeRepositoryPolicy( (RepositoryPolicy) repository.getSnapshots(), "snapshots", serializer );
+        }
+        if ( repository.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( repository.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( repository.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( repository.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( repository.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( repository.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( repository.getLayout() != null ) && !repository.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( repository.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepository( Repository, String, XmlSerializer )
+
+    /**
+     * Method writeRepositoryBase.
+     * 
+     * @param repositoryBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepositoryBase( RepositoryBase repositoryBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repositoryBase.getId() != null )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( repositoryBase.getId() ).endTag( NAMESPACE, "id" );
+        }
+        if ( repositoryBase.getName() != null )
+        {
+            serializer.startTag( NAMESPACE, "name" ).text( repositoryBase.getName() ).endTag( NAMESPACE, "name" );
+        }
+        if ( repositoryBase.getUrl() != null )
+        {
+            serializer.startTag( NAMESPACE, "url" ).text( repositoryBase.getUrl() ).endTag( NAMESPACE, "url" );
+        }
+        if ( ( repositoryBase.getLayout() != null ) && !repositoryBase.getLayout().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "layout" ).text( repositoryBase.getLayout() ).endTag( NAMESPACE, "layout" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepositoryBase( RepositoryBase, String, XmlSerializer )
+
+    /**
+     * Method writeRepositoryPolicy.
+     * 
+     * @param repositoryPolicy
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeRepositoryPolicy( RepositoryPolicy repositoryPolicy, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( repositoryPolicy.isEnabled() != true )
+        {
+            serializer.startTag( NAMESPACE, "enabled" ).text( String.valueOf( repositoryPolicy.isEnabled() ) ).endTag( NAMESPACE, "enabled" );
+        }
+        if ( repositoryPolicy.getUpdatePolicy() != null )
+        {
+            serializer.startTag( NAMESPACE, "updatePolicy" ).text( repositoryPolicy.getUpdatePolicy() ).endTag( NAMESPACE, "updatePolicy" );
+        }
+        if ( repositoryPolicy.getChecksumPolicy() != null )
+        {
+            serializer.startTag( NAMESPACE, "checksumPolicy" ).text( repositoryPolicy.getChecksumPolicy() ).endTag( NAMESPACE, "checksumPolicy" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeRepositoryPolicy( RepositoryPolicy, String, XmlSerializer )
+
+    /**
+     * Method writeServer.
+     * 
+     * @param server
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeServer( Server server, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        if ( server.getUsername() != null )
+        {
+            serializer.startTag( NAMESPACE, "username" ).text( server.getUsername() ).endTag( NAMESPACE, "username" );
+        }
+        if ( server.getPassword() != null )
+        {
+            serializer.startTag( NAMESPACE, "password" ).text( server.getPassword() ).endTag( NAMESPACE, "password" );
+        }
+        if ( server.getPrivateKey() != null )
+        {
+            serializer.startTag( NAMESPACE, "privateKey" ).text( server.getPrivateKey() ).endTag( NAMESPACE, "privateKey" );
+        }
+        if ( server.getPassphrase() != null )
+        {
+            serializer.startTag( NAMESPACE, "passphrase" ).text( server.getPassphrase() ).endTag( NAMESPACE, "passphrase" );
+        }
+        if ( server.getFilePermissions() != null )
+        {
+            serializer.startTag( NAMESPACE, "filePermissions" ).text( server.getFilePermissions() ).endTag( NAMESPACE, "filePermissions" );
+        }
+        if ( server.getDirectoryPermissions() != null )
+        {
+            serializer.startTag( NAMESPACE, "directoryPermissions" ).text( server.getDirectoryPermissions() ).endTag( NAMESPACE, "directoryPermissions" );
+        }
+        if ( server.getConfiguration() != null )
+        {
+            ((Xpp3Dom) server.getConfiguration()).writeToSerializer( NAMESPACE, serializer );
+        }
+        if ( ( server.getId() != null ) && !server.getId().equals( "default" ) )
+        {
+            serializer.startTag( NAMESPACE, "id" ).text( server.getId() ).endTag( NAMESPACE, "id" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeServer( Server, String, XmlSerializer )
+
+    /**
+     * Method writeSettings.
+     * 
+     * @param settings
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeSettings( Settings settings, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.setPrefix( "", "http://maven.apache.org/SETTINGS/1.1.0" );
+        serializer.setPrefix( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.attribute( "", "xsi:schemaLocation", "http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd" );
+        if ( settings.getLocalRepository() != null )
+        {
+            serializer.startTag( NAMESPACE, "localRepository" ).text( settings.getLocalRepository() ).endTag( NAMESPACE, "localRepository" );
+        }
+        if ( settings.isInteractiveMode() != true )
+        {
+            serializer.startTag( NAMESPACE, "interactiveMode" ).text( String.valueOf( settings.isInteractiveMode() ) ).endTag( NAMESPACE, "interactiveMode" );
+        }
+        if ( settings.isUsePluginRegistry() != false )
+        {
+            serializer.startTag( NAMESPACE, "usePluginRegistry" ).text( String.valueOf( settings.isUsePluginRegistry() ) ).endTag( NAMESPACE, "usePluginRegistry" );
+        }
+        if ( settings.isOffline() != false )
+        {
+            serializer.startTag( NAMESPACE, "offline" ).text( String.valueOf( settings.isOffline() ) ).endTag( NAMESPACE, "offline" );
+        }
+        if ( ( settings.getProxies() != null ) && ( settings.getProxies().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "proxies" );
+            for ( Iterator iter = settings.getProxies().iterator(); iter.hasNext(); )
+            {
+                Proxy o = (Proxy) iter.next();
+                writeProxy( o, "proxy", serializer );
+            }
+            serializer.endTag( NAMESPACE, "proxies" );
+        }
+        if ( ( settings.getServers() != null ) && ( settings.getServers().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "servers" );
+            for ( Iterator iter = settings.getServers().iterator(); iter.hasNext(); )
+            {
+                Server o = (Server) iter.next();
+                writeServer( o, "server", serializer );
+            }
+            serializer.endTag( NAMESPACE, "servers" );
+        }
+        if ( ( settings.getMirrors() != null ) && ( settings.getMirrors().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "mirrors" );
+            for ( Iterator iter = settings.getMirrors().iterator(); iter.hasNext(); )
+            {
+                Mirror o = (Mirror) iter.next();
+                writeMirror( o, "mirror", serializer );
+            }
+            serializer.endTag( NAMESPACE, "mirrors" );
+        }
+        if ( ( settings.getProfiles() != null ) && ( settings.getProfiles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "profiles" );
+            for ( Iterator iter = settings.getProfiles().iterator(); iter.hasNext(); )
+            {
+                Profile o = (Profile) iter.next();
+                writeProfile( o, "profile", serializer );
+            }
+            serializer.endTag( NAMESPACE, "profiles" );
+        }
+        if ( ( settings.getActiveProfiles() != null ) && ( settings.getActiveProfiles().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "activeProfiles" );
+            for ( Iterator iter = settings.getActiveProfiles().iterator(); iter.hasNext(); )
+            {
+                String activeProfile = (String) iter.next();
+                serializer.startTag( NAMESPACE, "activeProfile" ).text( activeProfile ).endTag( NAMESPACE, "activeProfile" );
+            }
+            serializer.endTag( NAMESPACE, "activeProfiles" );
+        }
+        if ( ( settings.getPluginGroups() != null ) && ( settings.getPluginGroups().size() > 0 ) )
+        {
+            serializer.startTag( NAMESPACE, "pluginGroups" );
+            for ( Iterator iter = settings.getPluginGroups().iterator(); iter.hasNext(); )
+            {
+                String pluginGroup = (String) iter.next();
+                serializer.startTag( NAMESPACE, "pluginGroup" ).text( pluginGroup ).endTag( NAMESPACE, "pluginGroup" );
+            }
+            serializer.endTag( NAMESPACE, "pluginGroups" );
+        }
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeSettings( Settings, String, XmlSerializer )
+
+    /**
+     * Method writeTrackableBase.
+     * 
+     * @param trackableBase
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     */
+    private void writeTrackableBase( TrackableBase trackableBase, String tagName, XmlSerializer serializer )
+        throws java.io.IOException
+    {
+        serializer.startTag( NAMESPACE, tagName );
+        serializer.endTag( NAMESPACE, tagName );
+    } //-- void writeTrackableBase( TrackableBase, String, XmlSerializer )
+
+}
-- 
1.8.3.1

